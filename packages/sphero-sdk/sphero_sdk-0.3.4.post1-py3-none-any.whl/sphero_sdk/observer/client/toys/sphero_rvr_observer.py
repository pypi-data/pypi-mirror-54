#!/usr/bin/env python3
# This file is automatically generated!
# Toy Name:           Sphero RVR
# Prefix:             RV
# Command Count:      65
# Timestamp:          10/12/2019 @ 01:43:14.095668 (UTC)

import time
import logging.config
from sphero_sdk.observer.config import logging_config
from sphero_sdk.common.log_level import LogLevel
from sphero_sdk import Observer
from sphero_sdk import SerialObserverDal
from sphero_sdk.common.commands import api_and_shell
from sphero_sdk.common.commands import system_info
from sphero_sdk.common.commands import power
from sphero_sdk.common.commands import drive
from sphero_sdk.common.commands import sensor
from sphero_sdk.common.commands import connection
from sphero_sdk.common.commands import io
from sphero_sdk import LedControlObserver
from sphero_sdk import DriveControlObserver
from sphero_sdk import InfraredControlObserver
from sphero_sdk import SensorControlObserver
from sphero_sdk import RvrFwCheckObserver


class SpheroRvrObserver(Observer, RvrFwCheckObserver):
    def __init__(self, log_level=LogLevel.Silent):
        logging.config.dictConfig(logging_config.get_dict(log_level))
        Observer.__init__(self)
        RvrFwCheckObserver.__init__(self)
        self._dal = SerialObserverDal()
        self._led_control = LedControlObserver(self)
        self._drive_control = DriveControlObserver(self)
        self._infrared_control = InfraredControlObserver(self)
        self._sensor_control = SensorControlObserver(self)
        self._check_rvr_fw()

    @property
    def led_control(self):
        return self._led_control

    @property
    def drive_control(self):
        return self._drive_control

    @property
    def infrared_control(self):
        return self._infrared_control

    @property
    def sensor_control(self):
        return self._sensor_control

    def close(self):
        if len(self._sensor_control.enabled_sensors) > 0:
            self._sensor_control.clear()
            time.sleep(.2)

        self._dal.close()

    def echo(self, data, handler, target, timeout=None):
        """Echo back the payload data (zero data is equivalent to a ping).

        Args:
            data (list(uint8_t)): Payload data to be echoed as an integer between 0 and 255.
            handler (function): called when response is received, takes form handler(data).
            target (unit8_t): 1 or 2.
            timeout (float): maximum time to await a response.

        Returns:
            data (list(uint8_t)): Payload data that is echoed back as an integer between 0 and 255.
        """
        command_dict = api_and_shell.echo(data, target=target, timeout=timeout)
        self._register_handler(handler, **command_dict)
        self._dal.send_command(**command_dict)

    def get_main_application_version(self, handler, target, timeout=None):
        """Gets the version of the main application.

        Args:
            handler (function): called when response is received, takes form handler(major, minor, revision).
            target (unit8_t): 1 or 2.
            timeout (float): maximum time to await a response.

        Returns:
            major (uint16_t): The x value for version x.y.z
            minor (uint16_t): The y value for version x.y.z
            revision (uint16_t): The z value for version x.y.z
        """
        command_dict = system_info.get_main_application_version(target=target, timeout=timeout)
        self._register_handler(handler, **command_dict)
        self._dal.send_command(**command_dict)

    def get_bootloader_version(self, handler, target, timeout=None):
        """Gets the version of the bootloader.

        Args:
            handler (function): called when response is received, takes form handler(major, minor, revision).
            target (unit8_t): 1 or 2.
            timeout (float): maximum time to await a response.

        Returns:
            major (uint16_t): The x value for version x.y.z
            minor (uint16_t): The y value for version x.y.z
            revision (uint16_t): The z value for version x.y.z
        """
        command_dict = system_info.get_bootloader_version(target=target, timeout=timeout)
        self._register_handler(handler, **command_dict)
        self._dal.send_command(**command_dict)

    def get_board_revision(self, handler, timeout=None):
        """Gets the board revision number.

        Args:
            handler (function): called when response is received, takes form handler(revision).
            timeout (float): maximum time to await a response.

        Returns:
            revision (uint8_t): The hardware version for the board.
        """
        command_dict = system_info.get_board_revision(target=1, timeout=timeout)
        self._register_handler(handler, **command_dict)
        self._dal.send_command(**command_dict)

    def get_mac_address(self, handler, timeout=None):
        """Gets the robot's MAC address.

        Args:
            handler (function): called when response is received, takes form handler(macAddress).
            timeout (float): maximum time to await a response.

        Returns:
            mac_address (str): A 12-byte string representing the robot's MAC address.
        """
        command_dict = system_info.get_mac_address(target=1, timeout=timeout)
        self._register_handler(handler, **command_dict)
        self._dal.send_command(**command_dict)

    def get_stats_id(self, handler, timeout=None):
        """Gets the id number assigned by the company for activation tracking.

        Args:
            handler (function): called when response is received, takes form handler(statsId).
            timeout (float): maximum time to await a response.

        Returns:
            stats_id (uint16_t): The ID number assigned by the company (for activation tracking).
        """
        command_dict = system_info.get_stats_id(target=1, timeout=timeout)
        self._register_handler(handler, **command_dict)
        self._dal.send_command(**command_dict)

    def get_processor_name(self, handler, target, timeout=None):
        """Returns the processor name string (as specified to the System Info module). If no name is specified, returns an empty string or no string.

        Args:
            handler (function): called when response is received, takes form handler(name).
            target (unit8_t): 1 or 2.
            timeout (float): maximum time to await a response.

        Returns:
            name (str): The processor name (string up to 16 characters, including optional null terminator).
        """
        command_dict = system_info.get_processor_name(target=target, timeout=timeout)
        self._register_handler(handler, **command_dict)
        self._dal.send_command(**command_dict)

    def get_sku(self, handler, timeout=None):
        """Returns the SKU of the bot.

        Args:
            handler (function): called when response is received, takes form handler(sku).
            timeout (float): maximum time to await a response.

        Returns:
            sku (str): SKU (null-terminated string).
        """
        command_dict = system_info.get_sku(target=1, timeout=timeout)
        self._register_handler(handler, **command_dict)
        self._dal.send_command(**command_dict)

    def get_core_up_time_in_milliseconds(self, handler, timeout=None):
        """Returns the time (in milliseconds) that has passed since the latest power cycle started.

        Args:
            handler (function): called when response is received, takes form handler(upTime).
            timeout (float): maximum time to await a response.

        Returns:
            up_time (uint64_t): Time (in milliseconds) since last application start up.
        """
        command_dict = system_info.get_core_up_time_in_milliseconds(target=1, timeout=timeout)
        self._register_handler(handler, **command_dict)
        self._dal.send_command(**command_dict)

    def sleep(self, timeout=None):
        """Put robot into a soft sleep state. Driving, LEDS, and sensors are disabled.

        Args:
            timeout (float): maximum time to await a response.
        """
        command_dict = power.sleep(target=1, timeout=timeout)
        self._dal.send_command(**command_dict)

    def wake(self, timeout=None):
        """Wake up the system from soft sleep. Nothing to do if awake.

        Args:
            timeout (float): maximum time to await a response.
        """
        command_dict = power.wake(target=1, timeout=timeout)
        self._dal.send_command(**command_dict)

    def get_battery_percentage(self, handler, timeout=None):
        """Get usable battery percentage remaining.

        Args:
            handler (function): called when response is received, takes form handler(percentage).
            timeout (float): maximum time to await a response.

        Returns:
            percentage (uint8_t): Percent of battery that is remaining.
        """
        command_dict = power.get_battery_percentage(target=1, timeout=timeout)
        self._register_handler(handler, **command_dict)
        self._dal.send_command(**command_dict)

    def get_battery_voltage_state(self, handler, timeout=None):
        """Returns the current battery state

        Args:
            handler (function): called when response is received, takes form handler(state).
            timeout (float): maximum time to await a response.

        Returns:
            state (uint8_t): The current battery state.
        """
        command_dict = power.get_battery_voltage_state(target=1, timeout=timeout)
        self._register_handler(handler, **command_dict)
        self._dal.send_command(**command_dict)

    def on_will_sleep_notify(self, handler, timeout=None):
        """Notification triggered 10 seconds before soft/deep sleep.

        Args:
            timeout (float): maximum time to await a response.
        """
        command_dict = power.on_will_sleep_notify(target=1, timeout=timeout)
        self._register_handler(handler, **command_dict)

    def on_did_sleep_notify(self, handler, timeout=None):
        """Notification triggered when robot has entered soft/deep sleep.

        Args:
            timeout (float): maximum time to await a response.
        """
        command_dict = power.on_did_sleep_notify(target=1, timeout=timeout)
        self._register_handler(handler, **command_dict)

    def enable_battery_voltage_state_change_notify(self, is_enabled, timeout=None):
        """Enables or disables notifications for changes to battery voltage state.

        Args:
            is_enabled (bool): Indicates whether battery voltage state notifications should be enabled. True is enabled. False is disabled.
            timeout (float): maximum time to await a response.
        """
        command_dict = power.enable_battery_voltage_state_change_notify(is_enabled, target=1, timeout=timeout)
        self._dal.send_command(**command_dict)

    def on_battery_voltage_state_change_notify(self, handler, timeout=None):
        """Notification for battery voltage state change.

        Args:
            handler (function): called when response is received, takes form handler(state).
            timeout (float): maximum time to await a response.
        """
        command_dict = power.on_battery_voltage_state_change_notify(target=1, timeout=timeout)
        self._register_handler(handler, **command_dict)

    def get_battery_voltage_in_volts(self, reading_type, handler, timeout=None):
        """Returns the most recent battery voltage reading in volts. This results in a 'Command Failed' API error if the platform does not support calibration. Note that this command does not get a new voltage reading; it returns the most recently read value, which is updated once per second on most robots. To force the battery system to read a new value, use the 'Force Battery Refresh' command.

        Args:
            reading_type (uint8_t): Integer value indicating the type of reading you are seeking.
            handler (function): called when response is received, takes form handler(voltage).
            timeout (float): maximum time to await a response.

        Returns:
            voltage (float): Most recently read voltage of the battery.
        """
        command_dict = power.get_battery_voltage_in_volts(reading_type, target=1, timeout=timeout)
        self._register_handler(handler, **command_dict)
        self._dal.send_command(**command_dict)

    def get_battery_voltage_state_thresholds(self, handler, timeout=None):
        """Returns the battery voltage state thresholds and hysteresis value. The hysteresis value is added to the thresholds for rising voltages -- e.g., the voltage must be less than the low threshold to change the state to 'low battery' but it must be greater than (low threshold + hysteresis) to go back to the 'ok battery' state.

        Args:
            handler (function): called when response is received, takes form handler(criticalThreshold, lowThreshold, hysteresis).
            timeout (float): maximum time to await a response.

        Returns:
            critical_threshold (float): Float value indicating the voltage under which the battery should be read as 'critical'.
            low_threshold (float): Float value indicating the voltage under which the battery should be read as 'low'.
            hysteresis (float): Float value containing the amount by which the voltage must be above the critical or low thresholds in order for the battery to not be considered 'critical' or 'low'.
        """
        command_dict = power.get_battery_voltage_state_thresholds(target=1, timeout=timeout)
        self._register_handler(handler, **command_dict)
        self._dal.send_command(**command_dict)

    def get_current_sense_amplifier_current(self, amplifier_id, handler, timeout=None):
        """Get the current draw, in AMPS, from a current sense amplifier

        Args:
            amplifier_id (uint8_t): Motor amplifier id
            handler (function): called when response is received, takes form handler(amplifierCurrent).
            timeout (float): maximum time to await a response.

        Returns:
            amplifier_current (float): The value of the current coming from the amplifier specified in the input.
        """
        command_dict = power.get_current_sense_amplifier_current(amplifier_id, target=1, timeout=timeout)
        self._register_handler(handler, **command_dict)
        self._dal.send_command(**command_dict)

    def raw_motors(self, left_mode, left_speed, right_mode, right_speed, timeout=None):
        """Run left and right motors at a speed between 0 and 255. Set driving mode using flags.

        Args:
            left_mode (uint8_t): Drive mode: 0x0-off, 0x1-forward, 0x2-reverse
            left_speed (uint8_t): Proportional to 0-255 input
            right_mode (uint8_t): Drive mode: 0x0-off, 0x1-forward, 0x2-reverse
            right_speed (uint8_t): Proportional to 0-255 input
            timeout (float): maximum time to await a response.
        """
        command_dict = drive.raw_motors(left_mode, left_speed, right_mode, right_speed, target=2, timeout=timeout)
        self._dal.send_command(**command_dict)

    def reset_yaw(self, timeout=None):
        """Sets current yaw angle to zero. (ie current direction is now considered 'forward'.)

        Args:
            timeout (float): maximum time to await a response.
        """
        command_dict = drive.reset_yaw(target=2, timeout=timeout)
        self._dal.send_command(**command_dict)

    def drive_with_heading(self, speed, heading, flags, timeout=None):
        """Drive towards a heading at a particular speed. Flags can be set to modify driving mode.

        Args:
            speed (uint8_t): 0 to 255 value
            heading (uint16_t): 0 to 359 degrees (0 degrees is forward, 90 degrees is to the right, 180 degrees is back, and 270 is to the left)
            flags (uint8_t): Relevant flags: Drive Reverse, Boost, Fast Turn Mode
            timeout (float): maximum time to await a response.
        """
        command_dict = drive.drive_with_heading(speed, heading, flags, target=2, timeout=timeout)
        self._dal.send_command(**command_dict)

    def enable_motor_stall_notify(self, is_enabled, timeout=None):
        """Enables motor stall notifications.

        Args:
            is_enabled (bool): True for enable.  False for disable
            timeout (float): maximum time to await a response.
        """
        command_dict = drive.enable_motor_stall_notify(is_enabled, target=2, timeout=timeout)
        self._dal.send_command(**command_dict)

    def on_motor_stall_notify(self, handler, timeout=None):
        """Motor stall protection change notification.

        Args:
            handler (function): called when response is received, takes form handler(motorIndex, isTriggered).
            timeout (float): maximum time to await a response.
        """
        command_dict = drive.on_motor_stall_notify(target=2, timeout=timeout)
        self._register_handler(handler, **command_dict)

    def enable_motor_fault_notify(self, is_enabled, timeout=None):
        """Enables notification for when there is a motor fault.

        Args:
            is_enabled (bool): True for enable.  False for disable
            timeout (float): maximum time to await a response.
        """
        command_dict = drive.enable_motor_fault_notify(is_enabled, target=2, timeout=timeout)
        self._dal.send_command(**command_dict)

    def on_motor_fault_notify(self, handler, timeout=None):
        """Notification that a motor fault has occurred.

        Args:
            handler (function): called when response is received, takes form handler(isFault).
            timeout (float): maximum time to await a response.
        """
        command_dict = drive.on_motor_fault_notify(target=2, timeout=timeout)
        self._register_handler(handler, **command_dict)

    def get_motor_fault_state(self, handler, timeout=None):
        """Get the motor fault state.

        Args:
            handler (function): called when response is received, takes form handler(isFault).
            timeout (float): maximum time to await a response.

        Returns:
            is_fault (bool): True for fault.  False for no fault
        """
        command_dict = drive.get_motor_fault_state(target=2, timeout=timeout)
        self._register_handler(handler, **command_dict)
        self._dal.send_command(**command_dict)

    def enable_gyro_max_notify(self, is_enabled, timeout=None):
        """Enables the Async messages for when the Gyro max is hit.

        Args:
            is_enabled (bool): Boolean set for if you would like a notification when the Gyro max is hit. True for enabled. False for disabled.
            timeout (float): maximum time to await a response.
        """
        command_dict = sensor.enable_gyro_max_notify(is_enabled, target=2, timeout=timeout)
        self._dal.send_command(**command_dict)

    def on_gyro_max_notify(self, handler, timeout=None):
        """Occurs when the robot spins faster than the sensor can see in any axis.

        Args:
            handler (function): called when response is received, takes form handler(flags).
            timeout (float): maximum time to await a response.
        """
        command_dict = sensor.on_gyro_max_notify(target=2, timeout=timeout)
        self._register_handler(handler, **command_dict)

    def reset_locator_x_and_y(self, timeout=None):
        """Resets the locator module's current X and Y values to 0.

        Args:
            timeout (float): maximum time to await a response.
        """
        command_dict = sensor.reset_locator_x_and_y(target=2, timeout=timeout)
        self._dal.send_command(**command_dict)

    def set_locator_flags(self, flags, timeout=None):
        """Sets flags for the locator module.

        Args:
            flags (uint8_t): Auto calibrate: When set, the robot will maintain the same X - Y axis from initial startup. When cleared, the robot will reset the X - Y axis orientation when a driving yaw reset command is sent.
            timeout (float): maximum time to await a response.
        """
        command_dict = sensor.set_locator_flags(flags, target=2, timeout=timeout)
        self._dal.send_command(**command_dict)

    def get_bot_to_bot_infrared_readings(self, handler, timeout=None):
        """An 8-bit value is returned for each infrared sensor, assigned by mask.
Mask description on BOLT: 32'h0000_00ff: front left sensor 32'h0000_ff00: front right sensor 32'h00ff_0000: back right sensor 32'hff00_0000: back left sensor

        Args:
            handler (function): called when response is received, takes form handler(sensorData).
            timeout (float): maximum time to await a response.

        Returns:
            sensor_data (uint32_t): If the register reads a value between 0 - 15, then a message of that ID has been received. If the data returned is 255, the register is empty. For RVR, the message is only kept for 1second before it's reset back to 255.
        """
        command_dict = sensor.get_bot_to_bot_infrared_readings(target=2, timeout=timeout)
        self._register_handler(handler, **command_dict)
        self._dal.send_command(**command_dict)

    def get_rgbc_sensor_values(self, handler, timeout=None):
        """Return raw data being read by RGBC sensor on each sensor channel

        Args:
            handler (function): called when response is received, takes form handler(redChannelValue, greenChannelValue, blueChannelValue, clearChannelValue).
            timeout (float): maximum time to await a response.

        Returns:
            red_channel_value (uint16_t): None
            green_channel_value (uint16_t): None
            blue_channel_value (uint16_t): None
            clear_channel_value (uint16_t): None
        """
        command_dict = sensor.get_rgbc_sensor_values(target=1, timeout=timeout)
        self._register_handler(handler, **command_dict)
        self._dal.send_command(**command_dict)

    def start_robot_to_robot_infrared_broadcasting(self, far_code, near_code, timeout=None):
        """For robot following, broadcasting robots emit two codes: one for long distance (3 meters +), and one for short distance (< 1 meter). Following robots use both of these codes to determine direction and distance from the broadcasting robot.

        Args:
            far_code (uint8_t): Code between 0 and 7 that the robot emits for long distance (3+ meters) communication so that bots receiving it will know that it is further away.
            near_code (uint8_t): Code between 0 and 7 that the robot emits for short distance (<1 meters) communication so that bots receiving it will know that it is closer.
            timeout (float): maximum time to await a response.
        """
        command_dict = sensor.start_robot_to_robot_infrared_broadcasting(far_code, near_code, target=2, timeout=timeout)
        self._dal.send_command(**command_dict)

    def start_robot_to_robot_infrared_following(self, far_code, near_code, timeout=None):
        """Registers a far code and near code for a following robot to follow. Following robots use the far code and near code emitted by a broadcaster bot to determine direction and distance to travel.

        Args:
            far_code (uint8_t): Code between 0 and 7 that the robot emits for long distance (3+ meters) communication so that bots receiving it will know that it is further away.
            near_code (uint8_t): Code between 0 and 7 that the robot emits for short distance (<1 meters) communication so that bots receiving it will know that it is closer.
            timeout (float): maximum time to await a response.
        """
        command_dict = sensor.start_robot_to_robot_infrared_following(far_code, near_code, target=2, timeout=timeout)
        self._dal.send_command(**command_dict)

    def stop_robot_to_robot_infrared_broadcasting(self, timeout=None):
        """Halts current broadcasting or following. De-registers far code and near code on broadcasting or following robot.

        Args:
            timeout (float): maximum time to await a response.
        """
        command_dict = sensor.stop_robot_to_robot_infrared_broadcasting(target=2, timeout=timeout)
        self._dal.send_command(**command_dict)

    def on_robot_to_robot_infrared_message_received_notify(self, handler, timeout=None):
        """Async sent when a registered robot to robot infrared message is received. In response returns the infrared code listened for.

        Args:
            handler (function): called when response is received, takes form handler(infraredCode).
            timeout (float): maximum time to await a response.
        """
        command_dict = sensor.on_robot_to_robot_infrared_message_received_notify(target=2, timeout=timeout)
        self._register_handler(handler, **command_dict)

    def get_ambient_light_sensor_value(self, handler, timeout=None):
        """Ambient light value is returned; higher = more light!

        Args:
            handler (function): called when response is received, takes form handler(ambientLightValue).
            timeout (float): maximum time to await a response.

        Returns:
            ambient_light_value (float): higher = more light
        """
        command_dict = sensor.get_ambient_light_sensor_value(target=1, timeout=timeout)
        self._register_handler(handler, **command_dict)
        self._dal.send_command(**command_dict)

    def stop_robot_to_robot_infrared_following(self, timeout=None):
        """Halts current following. De-registers far code and near code on following robot.

        Args:
            timeout (float): maximum time to await a response.
        """
        command_dict = sensor.stop_robot_to_robot_infrared_following(target=2, timeout=timeout)
        self._dal.send_command(**command_dict)

    def start_robot_to_robot_infrared_evading(self, far_code, near_code, timeout=None):
        """Registers a far code and near code for a evading robot to evade. Evading robots use the far code and near code emitted by a broadcaster bot to determine direction and distance to travel.

        Args:
            far_code (uint8_t): Code between 0 and 7 that the robot emits for long distance (3+ meters) communication so that bots receiving it will know that it is further away.
            near_code (uint8_t): Code between 0 and 7 that the robot emits for short distance (<1 meters) communication so that bots receiving it will know that it is closer.
            timeout (float): maximum time to await a response.
        """
        command_dict = sensor.start_robot_to_robot_infrared_evading(far_code, near_code, target=2, timeout=timeout)
        self._dal.send_command(**command_dict)

    def stop_robot_to_robot_infrared_evading(self, timeout=None):
        """Halts current evading. De-registers far code and near code on evading robot.

        Args:
            timeout (float): maximum time to await a response.
        """
        command_dict = sensor.stop_robot_to_robot_infrared_evading(target=2, timeout=timeout)
        self._dal.send_command(**command_dict)

    def enable_color_detection_notify(self, is_enabled, interval, minimum_confidence_threshold, timeout=None):
        """Enable or disable asynchronous color detection notifications. The user must provide an interval and a confidence threshold

        Args:
            is_enabled (bool): True for enable.  False for disable
            interval (uint16_t): Interval, in milliseconds, that color detection asyncs will be sent.
            minimum_confidence_threshold (uint8_t): The minimum confidence level, from 0 to 255, that must be met before an async is sent.
            timeout (float): maximum time to await a response.
        """
        command_dict = sensor.enable_color_detection_notify(is_enabled, interval, minimum_confidence_threshold, target=1, timeout=timeout)
        self._dal.send_command(**command_dict)

    def on_color_detection_notify(self, handler, timeout=None):
        """Notification sent on the interval set by the user in enable_color_detection_notification with information about the color detected.  The color classification ID 0xFF is a special value indicating that the color could not be identified (e.g., because the reading was too dark).  This is expected behavior when the ring is tapped in the air with the sensor facing out.

        Args:
            handler (function): called when response is received, takes form handler(red, green, blue, confidence, colorClassificationId).
            timeout (float): maximum time to await a response.
        """
        command_dict = sensor.on_color_detection_notify(target=1, timeout=timeout)
        self._register_handler(handler, **command_dict)

    def get_current_detected_color_reading(self, timeout=None):
        """Note: this does not return anything.  Instead, a color_detection_notify async will be sent after measurement with the answer.

        Args:
            timeout (float): maximum time to await a response.
        """
        command_dict = sensor.get_current_detected_color_reading(target=1, timeout=timeout)
        self._dal.send_command(**command_dict)

    def enable_color_detection(self, is_enabled, timeout=None):
        """Enables the color detection module.

        Args:
            is_enabled (bool): True for enable.  False for disable
            timeout (float): maximum time to await a response.
        """
        command_dict = sensor.enable_color_detection(is_enabled, target=1, timeout=timeout)
        self._dal.send_command(**command_dict)

    def configure_streaming_service(self, token, configuration, target, timeout=None):
        """Configure streaming services.

        Args:
            token (uint8_t): None
            configuration (list(uint8_t)): Array containing the configuration of the client, like the service ID and size.
            target (unit8_t): 1 or 2.
            timeout (float): maximum time to await a response.
        """
        command_dict = sensor.configure_streaming_service(token, configuration, target=target, timeout=timeout)
        self._dal.send_command(**command_dict)

    def start_streaming_service(self, period, target, timeout=None):
        """Start all streaming services for a client

        Args:
            period (uint16_t): Interval between sensor streaming packets in milliseconds.
            target (unit8_t): 1 or 2.
            timeout (float): maximum time to await a response.
        """
        command_dict = sensor.start_streaming_service(period, target=target, timeout=timeout)
        self._dal.send_command(**command_dict)

    def stop_streaming_service(self, target, timeout=None):
        """Stops all streaming services for a client

        Args:
            target (unit8_t): 1 or 2.
            timeout (float): maximum time to await a response.
        """
        command_dict = sensor.stop_streaming_service(target=target, timeout=timeout)
        self._dal.send_command(**command_dict)

    def clear_streaming_service(self, target, timeout=None):
        """Clears all streaming services for a client

        Args:
            target (unit8_t): 1 or 2.
            timeout (float): maximum time to await a response.
        """
        command_dict = sensor.clear_streaming_service(target=target, timeout=timeout)
        self._dal.send_command(**command_dict)

    def on_streaming_service_data_notify(self, handler, target, timeout=None):
        """Streaming data notification for a client configuration

        Args:
            handler (function): called when response is received, takes form handler(token, sensorData).
            target (unit8_t): 1 or 2.
            timeout (float): maximum time to await a response.
        """
        command_dict = sensor.on_streaming_service_data_notify(target=target, timeout=timeout)
        self._register_handler(handler, **command_dict)

    def enable_robot_infrared_message_notify(self, is_enabled, timeout=None):
        """Starts listening for infrared messages sent to the robot and will send an async message when received.

        Args:
            is_enabled (bool): True for enable.  False for disable
            timeout (float): maximum time to await a response.
        """
        command_dict = sensor.enable_robot_infrared_message_notify(is_enabled, target=2, timeout=timeout)
        self._dal.send_command(**command_dict)

    def send_infrared_message(self, infrared_code, front_strength, left_strength, right_strength, rear_strength, timeout=None):
        """Send specified code to any robot in the vicinity. The on/off for each sensor is controlled individually but there can only be one range for all sensors. Therefore, the acceptable combination of emitters strength would be: 5, 5, 0, 0 or 5, 5, 5, 5 or 0, 0, 0, 5, etc.

        Args:
            infrared_code (uint8_t): The only valid messages to send this way have an ID between 0 and 7.
            front_strength (uint8_t): The range goes from 0-64, where 0 is no message sent, and 64 is the longest achievable range.
            left_strength (uint8_t): The range goes from 0-64, where 0 is no message sent, and 64 is the longest achievable range.
            right_strength (uint8_t): The range goes from 0-64, where 0 is no message sent, and 64 is the longest achievable range.
            rear_strength (uint8_t): The range goes from 0-64, where 0 is no message sent, and 64 is the longest achievable range.
            timeout (float): maximum time to await a response.
        """
        command_dict = sensor.send_infrared_message(infrared_code, front_strength, left_strength, right_strength, rear_strength, target=2, timeout=timeout)
        self._dal.send_command(**command_dict)

    def get_motor_temperature(self, motor_index, handler, timeout=None):
        """Get the motor temperature (calculated from motor current) for given a motor index.

        Args:
            motor_index (uint8_t): Indicates which motor we would like the metrics.
            handler (function): called when response is received, takes form handler(windingCoilTemperature, caseTemperature).
            timeout (float): maximum time to await a response.

        Returns:
            winding_coil_temperature (float): Temperature of the winding coil. Reported in Celsius
            case_temperature (float): Temperature of the case. Reported in Celsius
        """
        command_dict = sensor.get_motor_temperature(motor_index, target=2, timeout=timeout)
        self._register_handler(handler, **command_dict)
        self._dal.send_command(**command_dict)

    def get_motor_thermal_protection_status(self, handler, timeout=None):
        """Get motor thermal protection status.

        Args:
            handler (function): called when response is received, takes form handler(leftMotorTemperature, leftMotorStatus, rightMotorTemperature, rightMotorStatus).
            timeout (float): maximum time to await a response.

        Returns:
            left_motor_temperature (float): Temperature of the left motor in degrees Celsius
            left_motor_status (uint8_t): Thermal protection status.
            right_motor_temperature (float): Temperature of the right motor in degrees Celsius
            right_motor_status (uint8_t): Thermal protection status.
        """
        command_dict = sensor.get_motor_thermal_protection_status(target=2, timeout=timeout)
        self._register_handler(handler, **command_dict)
        self._dal.send_command(**command_dict)

    def enable_motor_thermal_protection_status_notify(self, is_enabled, timeout=None):
        """Enable motor thermal protection status notifications.

        Args:
            is_enabled (bool): True for enable.  False for disable
            timeout (float): maximum time to await a response.
        """
        command_dict = sensor.enable_motor_thermal_protection_status_notify(is_enabled, target=2, timeout=timeout)
        self._dal.send_command(**command_dict)

    def on_motor_thermal_protection_status_notify(self, handler, timeout=None):
        """Motor thermal protection status notification.

        Args:
            handler (function): called when response is received, takes form handler(leftMotorTemperature, leftMotorStatus, rightMotorTemperature, rightMotorStatus).
            timeout (float): maximum time to await a response.
        """
        command_dict = sensor.on_motor_thermal_protection_status_notify(target=2, timeout=timeout)
        self._register_handler(handler, **command_dict)

    def get_bluetooth_advertising_name(self, handler, timeout=None):
        """Returns null-terminated string with the BLE advertising name (e.g., "BL-ABCD").

        Args:
            handler (function): called when response is received, takes form handler(name).
            timeout (float): maximum time to await a response.

        Returns:
            name (str): BLE advertising name
        """
        command_dict = connection.get_bluetooth_advertising_name(target=1, timeout=timeout)
        self._register_handler(handler, **command_dict)
        self._dal.send_command(**command_dict)

    def set_all_leds(self, led_group, led_brightness_values, timeout=None):
        """LED affected mask can affect up to 32 LEDs simultaneously. 0 = not affected. 1 = affected (update this LED). If mask value is set to 1, you must provide a value in the LED data array.

        Args:
            led_group (uint32_t): Bitmask selecting which LEDs to change (32-bit).
            led_brightness_values (list(uint8_t)): Array of RGB values for each of the selected LEDs (1 to 32 bytes; length depends on robot).
            timeout (float): maximum time to await a response.
        """
        command_dict = io.set_all_leds(led_group, led_brightness_values, target=1, timeout=timeout)
        self._dal.send_command(**command_dict)

    def get_active_color_palette(self, handler, timeout=None):
        """The response data will list all assigned color palette slots in the system.

        Args:
            handler (function): called when response is received, takes form handler(rgbIndexBytes).
            timeout (float): maximum time to await a response.

        Returns:
            rgb_index_bytes (list(uint8_t)): struct array -- index, red, green, blue -- that stores the contents of the active color palette.
        """
        command_dict = io.get_active_color_palette(target=1, timeout=timeout)
        self._register_handler(handler, **command_dict)
        self._dal.send_command(**command_dict)

    def set_active_color_palette(self, rgb_index_bytes, timeout=None):
        """Each entry in the array corresponds to one color slot in the system.  Any unmentioned slot indices will be marked unassigned.

        Args:
            rgb_index_bytes (list(uint8_t)): struct array -- index, red, green, blue -- that stores the contents of the color palette to be set as the active color palette.
            timeout (float): maximum time to await a response.
        """
        command_dict = io.set_active_color_palette(rgb_index_bytes, target=1, timeout=timeout)
        self._dal.send_command(**command_dict)

    def get_color_identification_report(self, red, green, blue, confidence_threshold, handler, timeout=None):
        """The response to this command will provide an array of color palette entries that would match on the provided color with higher confidence than the given threshold.

        Args:
            red (uint8_t): Red ('R') value of the color to be matched.
            green (uint8_t): Green ('G') value of the color to be matched.
            blue (uint8_t): Blue ('B') value of the color to be matched.
            confidence_threshold (uint8_t): How closely the palette should match the provided color. The confidence threshold is in [0, 255].
            handler (function): called when response is received, takes form handler(indexConfidenceByte).
            timeout (float): maximum time to await a response.

        Returns:
            index_confidence_byte (list(uint8_t)): struct array -- index, confidence -- that contains the index of the palette that best matches the provided color and a confidence level for how closely the palette matches the provided color.
        """
        command_dict = io.get_color_identification_report(red, green, blue, confidence_threshold, target=1, timeout=timeout)
        self._register_handler(handler, **command_dict)
        self._dal.send_command(**command_dict)

    def load_color_palette(self, palette_index, timeout=None):
        """Loads the specified color palette into the active palette.

        Args:
            palette_index (uint8_t): The index of (number that identifies) the color palette to be loaded.
            timeout (float): maximum time to await a response.
        """
        command_dict = io.load_color_palette(palette_index, target=1, timeout=timeout)
        self._dal.send_command(**command_dict)

    def save_color_palette(self, palette_index, timeout=None):
        """Stores the active palette into the palette at palette index (see table above).

        Args:
            palette_index (uint8_t): The index of (number that identifies) the color palette to be stored.
            timeout (float): maximum time to await a response.
        """
        command_dict = io.save_color_palette(palette_index, target=1, timeout=timeout)
        self._dal.send_command(**command_dict)

    def release_led_requests(self, timeout=None):
        """Releases LED requests to show the idle indication.

        Args:
            timeout (float): maximum time to await a response.
        """
        command_dict = io.release_led_requests(target=1, timeout=timeout)
        self._dal.send_command(**command_dict)
