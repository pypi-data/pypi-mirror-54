#!/usr/bin/env python3
# This file is automatically generated!
# Toy Name:           Sphero RVR
# Prefix:             RV
# Command Count:      65
# Timestamp:          10/12/2019 @ 01:43:14.091962 (UTC)

import asyncio
import logging.config
from sphero_sdk.asyncio.config import logging_config
from sphero_sdk.common.log_level import LogLevel
from sphero_sdk.common.commands import api_and_shell
from sphero_sdk.common.commands import system_info
from sphero_sdk.common.commands import power
from sphero_sdk.common.commands import drive
from sphero_sdk.common.commands import sensor
from sphero_sdk.common.commands import connection
from sphero_sdk.common.commands import io
from sphero_sdk import LedControlAsync
from sphero_sdk import DriveControlAsync
from sphero_sdk import InfraredControlAsync
from sphero_sdk import SensorControlAsync
from sphero_sdk import RvrFwCheckAsync


class SpheroRvrAsync(RvrFwCheckAsync):
    def __init__(self, dal, log_level=LogLevel.Silent):
        logging.config.dictConfig(logging_config.get_dict(log_level))
        RvrFwCheckAsync.__init__(self)
        self._dal = dal
        self._led_control = LedControlAsync(self)
        self._drive_control = DriveControlAsync(self)
        self._infrared_control = InfraredControlAsync(self)
        self._sensor_control = SensorControlAsync(self)
        asyncio.get_event_loop().run_until_complete(
            self._check_rvr_fw()
        )

    @property
    def led_control(self):
        return self._led_control

    @property
    def drive_control(self):
        return self._drive_control

    @property
    def infrared_control(self):
        return self._infrared_control

    @property
    def sensor_control(self):
        return self._sensor_control

    async def close(self):
        if len(self._sensor_control.enabled_sensors) > 0:
            await self._sensor_control.clear()
            await asyncio.sleep(.2)

        await self._dal.close()

    async def echo(self, data, target, timeout=None):
        """Echo back the payload data (zero data is equivalent to a ping).

        Args:
            data (list(uint8_t)): Payload data to be echoed as an integer between 0 and 255.
            target (unit8_t): 1 or 2.
            timeout (float): maximum time to await a response.

        Returns:
            dict: data (list(uint8_t))
        """
        command_dict = api_and_shell.echo(data, target=target, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def get_main_application_version(self, target, timeout=None):
        """Gets the version of the main application.

        Args:
            target (unit8_t): 1 or 2.
            timeout (float): maximum time to await a response.

        Returns:
            dict: major (uint16_t), minor (uint16_t), revision (uint16_t)
        """
        command_dict = system_info.get_main_application_version(target=target, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def get_bootloader_version(self, target, timeout=None):
        """Gets the version of the bootloader.

        Args:
            target (unit8_t): 1 or 2.
            timeout (float): maximum time to await a response.

        Returns:
            dict: major (uint16_t), minor (uint16_t), revision (uint16_t)
        """
        command_dict = system_info.get_bootloader_version(target=target, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def get_board_revision(self, timeout=None):
        """Gets the board revision number.

        Args:
            timeout (float): maximum time to await a response.

        Returns:
            dict: revision (uint8_t)
        """
        command_dict = system_info.get_board_revision(target=1, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def get_mac_address(self, timeout=None):
        """Gets the robot's MAC address.

        Args:
            timeout (float): maximum time to await a response.

        Returns:
            dict: mac_address (str)
        """
        command_dict = system_info.get_mac_address(target=1, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def get_stats_id(self, timeout=None):
        """Gets the id number assigned by the company for activation tracking.

        Args:
            timeout (float): maximum time to await a response.

        Returns:
            dict: stats_id (uint16_t)
        """
        command_dict = system_info.get_stats_id(target=1, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def get_processor_name(self, target, timeout=None):
        """Returns the processor name string (as specified to the System Info module). If no name is specified, returns an empty string or no string.

        Args:
            target (unit8_t): 1 or 2.
            timeout (float): maximum time to await a response.

        Returns:
            dict: name (str)
        """
        command_dict = system_info.get_processor_name(target=target, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def get_sku(self, timeout=None):
        """Returns the SKU of the bot.

        Args:
            timeout (float): maximum time to await a response.

        Returns:
            dict: sku (str)
        """
        command_dict = system_info.get_sku(target=1, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def get_core_up_time_in_milliseconds(self, timeout=None):
        """Returns the time (in milliseconds) that has passed since the latest power cycle started.

        Args:
            timeout (float): maximum time to await a response.

        Returns:
            dict: up_time (uint64_t)
        """
        command_dict = system_info.get_core_up_time_in_milliseconds(target=1, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def sleep(self, timeout=None):
        """Put robot into a soft sleep state. Driving, LEDS, and sensors are disabled.

        Args:
            timeout (float): maximum time to await a response.
        """
        command_dict = power.sleep(target=1, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def wake(self, timeout=None):
        """Wake up the system from soft sleep. Nothing to do if awake.

        Args:
            timeout (float): maximum time to await a response.
        """
        command_dict = power.wake(target=1, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def get_battery_percentage(self, timeout=None):
        """Get usable battery percentage remaining.

        Args:
            timeout (float): maximum time to await a response.

        Returns:
            dict: percentage (uint8_t)
        """
        command_dict = power.get_battery_percentage(target=1, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def get_battery_voltage_state(self, timeout=None):
        """Returns the current battery state

        Args:
            timeout (float): maximum time to await a response.

        Returns:
            dict: state (uint8_t)
        """
        command_dict = power.get_battery_voltage_state(target=1, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def on_will_sleep_notify(self, handler=None, timeout=None):
        """Notification triggered 10 seconds before soft/deep sleep.

        Args:
            handler (function): called asynchronously, takes form handler().
            timeout (float): maximum time to await a response.
        Returns:
            Task (Future) from which `handler` will be called
        """
        command_dict = power.on_will_sleep_notify(target=1, timeout=timeout)
        command_dict['handler'] = handler
        return asyncio.ensure_future(
            self._dal.on_command(**command_dict)
        )

    async def on_did_sleep_notify(self, handler=None, timeout=None):
        """Notification triggered when robot has entered soft/deep sleep.

        Args:
            handler (function): called asynchronously, takes form handler().
            timeout (float): maximum time to await a response.
        Returns:
            Task (Future) from which `handler` will be called
        """
        command_dict = power.on_did_sleep_notify(target=1, timeout=timeout)
        command_dict['handler'] = handler
        return asyncio.ensure_future(
            self._dal.on_command(**command_dict)
        )

    async def enable_battery_voltage_state_change_notify(self, is_enabled, timeout=None):
        """Enables or disables notifications for changes to battery voltage state.

        Args:
            is_enabled (bool): Indicates whether battery voltage state notifications should be enabled. True is enabled. False is disabled.
            timeout (float): maximum time to await a response.
        """
        command_dict = power.enable_battery_voltage_state_change_notify(is_enabled, target=1, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def on_battery_voltage_state_change_notify(self, handler=None, timeout=None):
        """Notification for battery voltage state change.

        Args:
            handler (function): called asynchronously, takes form handler(state).
            timeout (float): maximum time to await a response.
        Returns:
            Task (Future) from which `handler` will be called
        """
        command_dict = power.on_battery_voltage_state_change_notify(target=1, timeout=timeout)
        command_dict['handler'] = handler
        return asyncio.ensure_future(
            self._dal.on_command(**command_dict)
        )

    async def get_battery_voltage_in_volts(self, reading_type, timeout=None):
        """Returns the most recent battery voltage reading in volts. This results in a 'Command Failed' API error if the platform does not support calibration. Note that this command does not get a new voltage reading; it returns the most recently read value, which is updated once per second on most robots. To force the battery system to read a new value, use the 'Force Battery Refresh' command.

        Args:
            reading_type (uint8_t): Integer value indicating the type of reading you are seeking.
            timeout (float): maximum time to await a response.

        Returns:
            dict: voltage (float)
        """
        command_dict = power.get_battery_voltage_in_volts(reading_type, target=1, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def get_battery_voltage_state_thresholds(self, timeout=None):
        """Returns the battery voltage state thresholds and hysteresis value. The hysteresis value is added to the thresholds for rising voltages -- e.g., the voltage must be less than the low threshold to change the state to 'low battery' but it must be greater than (low threshold + hysteresis) to go back to the 'ok battery' state.

        Args:
            timeout (float): maximum time to await a response.

        Returns:
            dict: critical_threshold (float), low_threshold (float), hysteresis (float)
        """
        command_dict = power.get_battery_voltage_state_thresholds(target=1, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def get_current_sense_amplifier_current(self, amplifier_id, timeout=None):
        """Get the current draw, in AMPS, from a current sense amplifier

        Args:
            amplifier_id (uint8_t): Motor amplifier id
            timeout (float): maximum time to await a response.

        Returns:
            dict: amplifier_current (float)
        """
        command_dict = power.get_current_sense_amplifier_current(amplifier_id, target=1, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def raw_motors(self, left_mode, left_speed, right_mode, right_speed, timeout=None):
        """Run left and right motors at a speed between 0 and 255. Set driving mode using flags.

        Args:
            left_mode (uint8_t): Drive mode: 0x0-off, 0x1-forward, 0x2-reverse
            left_speed (uint8_t): Proportional to 0-255 input
            right_mode (uint8_t): Drive mode: 0x0-off, 0x1-forward, 0x2-reverse
            right_speed (uint8_t): Proportional to 0-255 input
            timeout (float): maximum time to await a response.
        """
        command_dict = drive.raw_motors(left_mode, left_speed, right_mode, right_speed, target=2, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def reset_yaw(self, timeout=None):
        """Sets current yaw angle to zero. (ie current direction is now considered 'forward'.)

        Args:
            timeout (float): maximum time to await a response.
        """
        command_dict = drive.reset_yaw(target=2, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def drive_with_heading(self, speed, heading, flags, timeout=None):
        """Drive towards a heading at a particular speed. Flags can be set to modify driving mode.

        Args:
            speed (uint8_t): 0 to 255 value
            heading (uint16_t): 0 to 359 degrees (0 degrees is forward, 90 degrees is to the right, 180 degrees is back, and 270 is to the left)
            flags (uint8_t): Relevant flags: Drive Reverse, Boost, Fast Turn Mode
            timeout (float): maximum time to await a response.
        """
        command_dict = drive.drive_with_heading(speed, heading, flags, target=2, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def enable_motor_stall_notify(self, is_enabled, timeout=None):
        """Enables motor stall notifications.

        Args:
            is_enabled (bool): True for enable.  False for disable
            timeout (float): maximum time to await a response.
        """
        command_dict = drive.enable_motor_stall_notify(is_enabled, target=2, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def on_motor_stall_notify(self, handler=None, timeout=None):
        """Motor stall protection change notification.

        Args:
            handler (function): called asynchronously, takes form handler(motorIndex, isTriggered).
            timeout (float): maximum time to await a response.
        Returns:
            Task (Future) from which `handler` will be called
        """
        command_dict = drive.on_motor_stall_notify(target=2, timeout=timeout)
        command_dict['handler'] = handler
        return asyncio.ensure_future(
            self._dal.on_command(**command_dict)
        )

    async def enable_motor_fault_notify(self, is_enabled, timeout=None):
        """Enables notification for when there is a motor fault.

        Args:
            is_enabled (bool): True for enable.  False for disable
            timeout (float): maximum time to await a response.
        """
        command_dict = drive.enable_motor_fault_notify(is_enabled, target=2, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def on_motor_fault_notify(self, handler=None, timeout=None):
        """Notification that a motor fault has occurred.

        Args:
            handler (function): called asynchronously, takes form handler(isFault).
            timeout (float): maximum time to await a response.
        Returns:
            Task (Future) from which `handler` will be called
        """
        command_dict = drive.on_motor_fault_notify(target=2, timeout=timeout)
        command_dict['handler'] = handler
        return asyncio.ensure_future(
            self._dal.on_command(**command_dict)
        )

    async def get_motor_fault_state(self, timeout=None):
        """Get the motor fault state.

        Args:
            timeout (float): maximum time to await a response.

        Returns:
            dict: is_fault (bool)
        """
        command_dict = drive.get_motor_fault_state(target=2, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def enable_gyro_max_notify(self, is_enabled, timeout=None):
        """Enables the Async messages for when the Gyro max is hit.

        Args:
            is_enabled (bool): Boolean set for if you would like a notification when the Gyro max is hit. True for enabled. False for disabled.
            timeout (float): maximum time to await a response.
        """
        command_dict = sensor.enable_gyro_max_notify(is_enabled, target=2, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def on_gyro_max_notify(self, handler=None, timeout=None):
        """Occurs when the robot spins faster than the sensor can see in any axis.

        Args:
            handler (function): called asynchronously, takes form handler(flags).
            timeout (float): maximum time to await a response.
        Returns:
            Task (Future) from which `handler` will be called
        """
        command_dict = sensor.on_gyro_max_notify(target=2, timeout=timeout)
        command_dict['handler'] = handler
        return asyncio.ensure_future(
            self._dal.on_command(**command_dict)
        )

    async def reset_locator_x_and_y(self, timeout=None):
        """Resets the locator module's current X and Y values to 0.

        Args:
            timeout (float): maximum time to await a response.
        """
        command_dict = sensor.reset_locator_x_and_y(target=2, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def set_locator_flags(self, flags, timeout=None):
        """Sets flags for the locator module.

        Args:
            flags (uint8_t): Auto calibrate: When set, the robot will maintain the same X - Y axis from initial startup. When cleared, the robot will reset the X - Y axis orientation when a driving yaw reset command is sent.
            timeout (float): maximum time to await a response.
        """
        command_dict = sensor.set_locator_flags(flags, target=2, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def get_bot_to_bot_infrared_readings(self, timeout=None):
        """An 8-bit value is returned for each infrared sensor, assigned by mask.
Mask description on BOLT: 32'h0000_00ff: front left sensor 32'h0000_ff00: front right sensor 32'h00ff_0000: back right sensor 32'hff00_0000: back left sensor

        Args:
            timeout (float): maximum time to await a response.

        Returns:
            dict: sensor_data (uint32_t)
        """
        command_dict = sensor.get_bot_to_bot_infrared_readings(target=2, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def get_rgbc_sensor_values(self, timeout=None):
        """Return raw data being read by RGBC sensor on each sensor channel

        Args:
            timeout (float): maximum time to await a response.

        Returns:
            dict: red_channel_value (uint16_t), green_channel_value (uint16_t), blue_channel_value (uint16_t), clear_channel_value (uint16_t)
        """
        command_dict = sensor.get_rgbc_sensor_values(target=1, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def start_robot_to_robot_infrared_broadcasting(self, far_code, near_code, timeout=None):
        """For robot following, broadcasting robots emit two codes: one for long distance (3 meters +), and one for short distance (< 1 meter). Following robots use both of these codes to determine direction and distance from the broadcasting robot.

        Args:
            far_code (uint8_t): Code between 0 and 7 that the robot emits for long distance (3+ meters) communication so that bots receiving it will know that it is further away.
            near_code (uint8_t): Code between 0 and 7 that the robot emits for short distance (<1 meters) communication so that bots receiving it will know that it is closer.
            timeout (float): maximum time to await a response.
        """
        command_dict = sensor.start_robot_to_robot_infrared_broadcasting(far_code, near_code, target=2, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def start_robot_to_robot_infrared_following(self, far_code, near_code, timeout=None):
        """Registers a far code and near code for a following robot to follow. Following robots use the far code and near code emitted by a broadcaster bot to determine direction and distance to travel.

        Args:
            far_code (uint8_t): Code between 0 and 7 that the robot emits for long distance (3+ meters) communication so that bots receiving it will know that it is further away.
            near_code (uint8_t): Code between 0 and 7 that the robot emits for short distance (<1 meters) communication so that bots receiving it will know that it is closer.
            timeout (float): maximum time to await a response.
        """
        command_dict = sensor.start_robot_to_robot_infrared_following(far_code, near_code, target=2, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def stop_robot_to_robot_infrared_broadcasting(self, timeout=None):
        """Halts current broadcasting or following. De-registers far code and near code on broadcasting or following robot.

        Args:
            timeout (float): maximum time to await a response.
        """
        command_dict = sensor.stop_robot_to_robot_infrared_broadcasting(target=2, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def on_robot_to_robot_infrared_message_received_notify(self, handler=None, timeout=None):
        """Async sent when a registered robot to robot infrared message is received. In response returns the infrared code listened for.

        Args:
            handler (function): called asynchronously, takes form handler(infraredCode).
            timeout (float): maximum time to await a response.
        Returns:
            Task (Future) from which `handler` will be called
        """
        command_dict = sensor.on_robot_to_robot_infrared_message_received_notify(target=2, timeout=timeout)
        command_dict['handler'] = handler
        return asyncio.ensure_future(
            self._dal.on_command(**command_dict)
        )

    async def get_ambient_light_sensor_value(self, timeout=None):
        """Ambient light value is returned; higher = more light!

        Args:
            timeout (float): maximum time to await a response.

        Returns:
            dict: ambient_light_value (float)
        """
        command_dict = sensor.get_ambient_light_sensor_value(target=1, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def stop_robot_to_robot_infrared_following(self, timeout=None):
        """Halts current following. De-registers far code and near code on following robot.

        Args:
            timeout (float): maximum time to await a response.
        """
        command_dict = sensor.stop_robot_to_robot_infrared_following(target=2, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def start_robot_to_robot_infrared_evading(self, far_code, near_code, timeout=None):
        """Registers a far code and near code for a evading robot to evade. Evading robots use the far code and near code emitted by a broadcaster bot to determine direction and distance to travel.

        Args:
            far_code (uint8_t): Code between 0 and 7 that the robot emits for long distance (3+ meters) communication so that bots receiving it will know that it is further away.
            near_code (uint8_t): Code between 0 and 7 that the robot emits for short distance (<1 meters) communication so that bots receiving it will know that it is closer.
            timeout (float): maximum time to await a response.
        """
        command_dict = sensor.start_robot_to_robot_infrared_evading(far_code, near_code, target=2, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def stop_robot_to_robot_infrared_evading(self, timeout=None):
        """Halts current evading. De-registers far code and near code on evading robot.

        Args:
            timeout (float): maximum time to await a response.
        """
        command_dict = sensor.stop_robot_to_robot_infrared_evading(target=2, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def enable_color_detection_notify(self, is_enabled, interval, minimum_confidence_threshold, timeout=None):
        """Enable or disable asynchronous color detection notifications. The user must provide an interval and a confidence threshold

        Args:
            is_enabled (bool): True for enable.  False for disable
            interval (uint16_t): Interval, in milliseconds, that color detection asyncs will be sent.
            minimum_confidence_threshold (uint8_t): The minimum confidence level, from 0 to 255, that must be met before an async is sent.
            timeout (float): maximum time to await a response.
        """
        command_dict = sensor.enable_color_detection_notify(is_enabled, interval, minimum_confidence_threshold, target=1, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def on_color_detection_notify(self, handler=None, timeout=None):
        """Notification sent on the interval set by the user in enable_color_detection_notification with information about the color detected.  The color classification ID 0xFF is a special value indicating that the color could not be identified (e.g., because the reading was too dark).  This is expected behavior when the ring is tapped in the air with the sensor facing out.

        Args:
            handler (function): called asynchronously, takes form handler(red, green, blue, confidence, colorClassificationId).
            timeout (float): maximum time to await a response.
        Returns:
            Task (Future) from which `handler` will be called
        """
        command_dict = sensor.on_color_detection_notify(target=1, timeout=timeout)
        command_dict['handler'] = handler
        return asyncio.ensure_future(
            self._dal.on_command(**command_dict)
        )

    async def get_current_detected_color_reading(self, timeout=None):
        """Note: this does not return anything.  Instead, a color_detection_notify async will be sent after measurement with the answer.

        Args:
            timeout (float): maximum time to await a response.
        """
        command_dict = sensor.get_current_detected_color_reading(target=1, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def enable_color_detection(self, is_enabled, timeout=None):
        """Enables the color detection module.

        Args:
            is_enabled (bool): True for enable.  False for disable
            timeout (float): maximum time to await a response.
        """
        command_dict = sensor.enable_color_detection(is_enabled, target=1, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def configure_streaming_service(self, token, configuration, target, timeout=None):
        """Configure streaming services.

        Args:
            token (uint8_t): None
            configuration (list(uint8_t)): Array containing the configuration of the client, like the service ID and size.
            target (unit8_t): 1 or 2.
            timeout (float): maximum time to await a response.
        """
        command_dict = sensor.configure_streaming_service(token, configuration, target=target, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def start_streaming_service(self, period, target, timeout=None):
        """Start all streaming services for a client

        Args:
            period (uint16_t): Interval between sensor streaming packets in milliseconds.
            target (unit8_t): 1 or 2.
            timeout (float): maximum time to await a response.
        """
        command_dict = sensor.start_streaming_service(period, target=target, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def stop_streaming_service(self, target, timeout=None):
        """Stops all streaming services for a client

        Args:
            target (unit8_t): 1 or 2.
            timeout (float): maximum time to await a response.
        """
        command_dict = sensor.stop_streaming_service(target=target, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def clear_streaming_service(self, target, timeout=None):
        """Clears all streaming services for a client

        Args:
            target (unit8_t): 1 or 2.
            timeout (float): maximum time to await a response.
        """
        command_dict = sensor.clear_streaming_service(target=target, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def on_streaming_service_data_notify(self, target, handler=None, timeout=None):
        """Streaming data notification for a client configuration

        Args:
            handler (function): called asynchronously, takes form handler(token, sensorData).
            target (unit8_t): 1 or 2.
            timeout (float): maximum time to await a response.
        Returns:
            Task (Future) from which `handler` will be called
        """
        command_dict = sensor.on_streaming_service_data_notify(target=target, timeout=timeout)
        command_dict['handler'] = handler
        return asyncio.ensure_future(
            self._dal.on_command(**command_dict)
        )

    async def enable_robot_infrared_message_notify(self, is_enabled, timeout=None):
        """Starts listening for infrared messages sent to the robot and will send an async message when received.

        Args:
            is_enabled (bool): True for enable.  False for disable
            timeout (float): maximum time to await a response.
        """
        command_dict = sensor.enable_robot_infrared_message_notify(is_enabled, target=2, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def send_infrared_message(self, infrared_code, front_strength, left_strength, right_strength, rear_strength, timeout=None):
        """Send specified code to any robot in the vicinity. The on/off for each sensor is controlled individually but there can only be one range for all sensors. Therefore, the acceptable combination of emitters strength would be: 5, 5, 0, 0 or 5, 5, 5, 5 or 0, 0, 0, 5, etc.

        Args:
            infrared_code (uint8_t): The only valid messages to send this way have an ID between 0 and 7.
            front_strength (uint8_t): The range goes from 0-64, where 0 is no message sent, and 64 is the longest achievable range.
            left_strength (uint8_t): The range goes from 0-64, where 0 is no message sent, and 64 is the longest achievable range.
            right_strength (uint8_t): The range goes from 0-64, where 0 is no message sent, and 64 is the longest achievable range.
            rear_strength (uint8_t): The range goes from 0-64, where 0 is no message sent, and 64 is the longest achievable range.
            timeout (float): maximum time to await a response.
        """
        command_dict = sensor.send_infrared_message(infrared_code, front_strength, left_strength, right_strength, rear_strength, target=2, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def get_motor_temperature(self, motor_index, timeout=None):
        """Get the motor temperature (calculated from motor current) for given a motor index.

        Args:
            motor_index (uint8_t): Indicates which motor we would like the metrics.
            timeout (float): maximum time to await a response.

        Returns:
            dict: winding_coil_temperature (float), case_temperature (float)
        """
        command_dict = sensor.get_motor_temperature(motor_index, target=2, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def get_motor_thermal_protection_status(self, timeout=None):
        """Get motor thermal protection status.

        Args:
            timeout (float): maximum time to await a response.

        Returns:
            dict: left_motor_temperature (float), left_motor_status (uint8_t), right_motor_temperature (float), right_motor_status (uint8_t)
        """
        command_dict = sensor.get_motor_thermal_protection_status(target=2, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def enable_motor_thermal_protection_status_notify(self, is_enabled, timeout=None):
        """Enable motor thermal protection status notifications.

        Args:
            is_enabled (bool): True for enable.  False for disable
            timeout (float): maximum time to await a response.
        """
        command_dict = sensor.enable_motor_thermal_protection_status_notify(is_enabled, target=2, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def on_motor_thermal_protection_status_notify(self, handler=None, timeout=None):
        """Motor thermal protection status notification.

        Args:
            handler (function): called asynchronously, takes form handler(leftMotorTemperature, leftMotorStatus, rightMotorTemperature, rightMotorStatus).
            timeout (float): maximum time to await a response.
        Returns:
            Task (Future) from which `handler` will be called
        """
        command_dict = sensor.on_motor_thermal_protection_status_notify(target=2, timeout=timeout)
        command_dict['handler'] = handler
        return asyncio.ensure_future(
            self._dal.on_command(**command_dict)
        )

    async def get_bluetooth_advertising_name(self, timeout=None):
        """Returns null-terminated string with the BLE advertising name (e.g., "BL-ABCD").

        Args:
            timeout (float): maximum time to await a response.

        Returns:
            dict: name (str)
        """
        command_dict = connection.get_bluetooth_advertising_name(target=1, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def set_all_leds(self, led_group, led_brightness_values, timeout=None):
        """LED affected mask can affect up to 32 LEDs simultaneously. 0 = not affected. 1 = affected (update this LED). If mask value is set to 1, you must provide a value in the LED data array.

        Args:
            led_group (uint32_t): Bitmask selecting which LEDs to change (32-bit).
            led_brightness_values (list(uint8_t)): Array of RGB values for each of the selected LEDs (1 to 32 bytes; length depends on robot).
            timeout (float): maximum time to await a response.
        """
        command_dict = io.set_all_leds(led_group, led_brightness_values, target=1, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def get_active_color_palette(self, timeout=None):
        """The response data will list all assigned color palette slots in the system.

        Args:
            timeout (float): maximum time to await a response.

        Returns:
            dict: rgb_index_bytes (list(uint8_t))
        """
        command_dict = io.get_active_color_palette(target=1, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def set_active_color_palette(self, rgb_index_bytes, timeout=None):
        """Each entry in the array corresponds to one color slot in the system.  Any unmentioned slot indices will be marked unassigned.

        Args:
            rgb_index_bytes (list(uint8_t)): struct array -- index, red, green, blue -- that stores the contents of the color palette to be set as the active color palette.
            timeout (float): maximum time to await a response.
        """
        command_dict = io.set_active_color_palette(rgb_index_bytes, target=1, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def get_color_identification_report(self, red, green, blue, confidence_threshold, timeout=None):
        """The response to this command will provide an array of color palette entries that would match on the provided color with higher confidence than the given threshold.

        Args:
            red (uint8_t): Red ('R') value of the color to be matched.
            green (uint8_t): Green ('G') value of the color to be matched.
            blue (uint8_t): Blue ('B') value of the color to be matched.
            confidence_threshold (uint8_t): How closely the palette should match the provided color. The confidence threshold is in [0, 255].
            timeout (float): maximum time to await a response.

        Returns:
            dict: index_confidence_byte (list(uint8_t))
        """
        command_dict = io.get_color_identification_report(red, green, blue, confidence_threshold, target=1, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def load_color_palette(self, palette_index, timeout=None):
        """Loads the specified color palette into the active palette.

        Args:
            palette_index (uint8_t): The index of (number that identifies) the color palette to be loaded.
            timeout (float): maximum time to await a response.
        """
        command_dict = io.load_color_palette(palette_index, target=1, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def save_color_palette(self, palette_index, timeout=None):
        """Stores the active palette into the palette at palette index (see table above).

        Args:
            palette_index (uint8_t): The index of (number that identifies) the color palette to be stored.
            timeout (float): maximum time to await a response.
        """
        command_dict = io.save_color_palette(palette_index, target=1, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def release_led_requests(self, timeout=None):
        """Releases LED requests to show the idle indication.

        Args:
            timeout (float): maximum time to await a response.
        """
        command_dict = io.release_led_requests(target=1, timeout=timeout)
        return await self._dal.send_command(**command_dict)
