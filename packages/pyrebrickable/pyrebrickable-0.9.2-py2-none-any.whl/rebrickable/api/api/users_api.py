# coding: utf-8

"""
    

        # noqa: E501

    The version of the OpenAPI document: 
    Generated by: https://openapi-generator.tech
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from rebrickable.api.api_client import ApiClient
from rebrickable.api.exceptions import (
    ApiTypeError,
    ApiValueError
)


class UsersApi(object):
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def users_allparts_list(self, user_token, **kwargs):  # noqa: E501
        """Get a list of all the Parts in all the user's Part Lists as well as the Parts inside Sets in the user's Set Lists.  # noqa: E501

        Get a list of all the Parts in all the user's Part Lists as well as the Parts inside Sets in the user's Set Lists.  ###WARNING this call is very resource intensive, do not overuse it!  Optionally, filter by one or more of the below query parameters.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_allparts_list(user_token, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str user_token: user_token (required)
        :param str page: page
        :param str page_size: page_size
        :param str part_num: part_num
        :param str part_cat_id: part_cat_id
        :param str color_id: color_id
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ArrayOfAllParts
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.users_allparts_list_with_http_info(user_token, **kwargs)  # noqa: E501

    def users_allparts_list_with_http_info(self, user_token, **kwargs):  # noqa: E501
        """Get a list of all the Parts in all the user's Part Lists as well as the Parts inside Sets in the user's Set Lists.  # noqa: E501

        Get a list of all the Parts in all the user's Part Lists as well as the Parts inside Sets in the user's Set Lists.  ###WARNING this call is very resource intensive, do not overuse it!  Optionally, filter by one or more of the below query parameters.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_allparts_list_with_http_info(user_token, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str user_token: user_token (required)
        :param str page: page
        :param str page_size: page_size
        :param str part_num: part_num
        :param str part_cat_id: part_cat_id
        :param str color_id: color_id
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ArrayOfAllParts, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['user_token', 'page', 'page_size', 'part_num', 'part_cat_id', 'color_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_allparts_list" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'user_token' is set
        if ('user_token' not in local_var_params or
                local_var_params['user_token'] is None):
            raise ApiValueError("Missing the required parameter `user_token` when calling `users_allparts_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_token' in local_var_params:
            path_params['user_token'] = local_var_params['user_token']  # noqa: E501

        query_params = []
        if 'page' in local_var_params:
            query_params.append(('page', local_var_params['page']))  # noqa: E501
        if 'page_size' in local_var_params:
            query_params.append(('page_size', local_var_params['page_size']))  # noqa: E501
        if 'part_num' in local_var_params:
            query_params.append(('part_num', local_var_params['part_num']))  # noqa: E501
        if 'part_cat_id' in local_var_params:
            query_params.append(('part_cat_id', local_var_params['part_cat_id']))  # noqa: E501
        if 'color_id' in local_var_params:
            query_params.append(('color_id', local_var_params['color_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/users/{user_token}/allparts/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ArrayOfAllParts',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_badges_list(self, **kwargs):  # noqa: E501
        """Get a list of all the available Badges  # noqa: E501

        Get a list of all the available Badges  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_badges_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str page: page
        :param str page_size: page_size
        :param str ordering: ordering
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ArrayOfBadges
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.users_badges_list_with_http_info(**kwargs)  # noqa: E501

    def users_badges_list_with_http_info(self, **kwargs):  # noqa: E501
        """Get a list of all the available Badges  # noqa: E501

        Get a list of all the available Badges  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_badges_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str page: page
        :param str page_size: page_size
        :param str ordering: ordering
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ArrayOfBadges, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['page', 'page_size', 'ordering']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_badges_list" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'page' in local_var_params:
            query_params.append(('page', local_var_params['page']))  # noqa: E501
        if 'page_size' in local_var_params:
            query_params.append(('page_size', local_var_params['page_size']))  # noqa: E501
        if 'ordering' in local_var_params:
            query_params.append(('ordering', local_var_params['ordering']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/users/badges/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ArrayOfBadges',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_badges_read(self, id, **kwargs):  # noqa: E501
        """Get details about a specific Badge  # noqa: E501

        Get details about a specific Badge  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_badges_read(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str id: id (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Badge
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.users_badges_read_with_http_info(id, **kwargs)  # noqa: E501

    def users_badges_read_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get details about a specific Badge  # noqa: E501

        Get details about a specific Badge  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_badges_read_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str id: id (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Badge, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_badges_read" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in local_var_params or
                local_var_params['id'] is None):
            raise ApiValueError("Missing the required parameter `id` when calling `users_badges_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/users/badges/{id}/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Badge',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_build_read(self, user_token, set_num, **kwargs):  # noqa: E501
        """Find out how many parts the user needs to build the specified Set.  # noqa: E501

        Find out how many parts the user needs to build the specified Set.  The user's default Build Settings will be used to calculate a Build Match % using their LEGO Collection of Sets and Parts.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_build_read(user_token, set_num, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str user_token: user_token (required)
        :param str set_num: set_num (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Build
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.users_build_read_with_http_info(user_token, set_num, **kwargs)  # noqa: E501

    def users_build_read_with_http_info(self, user_token, set_num, **kwargs):  # noqa: E501
        """Find out how many parts the user needs to build the specified Set.  # noqa: E501

        Find out how many parts the user needs to build the specified Set.  The user's default Build Settings will be used to calculate a Build Match % using their LEGO Collection of Sets and Parts.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_build_read_with_http_info(user_token, set_num, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str user_token: user_token (required)
        :param str set_num: set_num (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Build, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['user_token', 'set_num']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_build_read" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'user_token' is set
        if ('user_token' not in local_var_params or
                local_var_params['user_token'] is None):
            raise ApiValueError("Missing the required parameter `user_token` when calling `users_build_read`")  # noqa: E501
        # verify the required parameter 'set_num' is set
        if ('set_num' not in local_var_params or
                local_var_params['set_num'] is None):
            raise ApiValueError("Missing the required parameter `set_num` when calling `users_build_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_token' in local_var_params:
            path_params['user_token'] = local_var_params['user_token']  # noqa: E501
        if 'set_num' in local_var_params:
            path_params['set_num'] = local_var_params['set_num']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/users/{user_token}/build/{set_num}/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Build',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_lost_parts_create(self, user_token, inv_part_id, **kwargs):  # noqa: E501
        """Add one or more Lost Parts to the user.  # noqa: E501

        Add one or more Lost Parts to the user.  ### Single Part When adding a single Part, returns the successfully created Part (status 201) or details for why the Part could not be added. ### Multiple Parts To add multiple Parts, POST a JSON list of them (using a Content-Type header of 'application/json'). The inv_part_id field can be retrieved from the Set's inventory. e.g: `[{\"inv_part_id\": 806698, \"lost_quantity\": 3}, {\"inv_part_id\": 256007, \"lost_quantity\": 2}]` Returns a list of successfully added Parts. If the Part already exists or is unrecognised, it will be skipped.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_lost_parts_create(user_token, inv_part_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str user_token: user_token (required)
        :param str inv_part_id: inv_part_id (required)
        :param str lost_quantity: lost_quantity
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.users_lost_parts_create_with_http_info(user_token, inv_part_id, **kwargs)  # noqa: E501

    def users_lost_parts_create_with_http_info(self, user_token, inv_part_id, **kwargs):  # noqa: E501
        """Add one or more Lost Parts to the user.  # noqa: E501

        Add one or more Lost Parts to the user.  ### Single Part When adding a single Part, returns the successfully created Part (status 201) or details for why the Part could not be added. ### Multiple Parts To add multiple Parts, POST a JSON list of them (using a Content-Type header of 'application/json'). The inv_part_id field can be retrieved from the Set's inventory. e.g: `[{\"inv_part_id\": 806698, \"lost_quantity\": 3}, {\"inv_part_id\": 256007, \"lost_quantity\": 2}]` Returns a list of successfully added Parts. If the Part already exists or is unrecognised, it will be skipped.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_lost_parts_create_with_http_info(user_token, inv_part_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str user_token: user_token (required)
        :param str inv_part_id: inv_part_id (required)
        :param str lost_quantity: lost_quantity
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['user_token', 'inv_part_id', 'lost_quantity']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_lost_parts_create" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'user_token' is set
        if ('user_token' not in local_var_params or
                local_var_params['user_token'] is None):
            raise ApiValueError("Missing the required parameter `user_token` when calling `users_lost_parts_create`")  # noqa: E501
        # verify the required parameter 'inv_part_id' is set
        if ('inv_part_id' not in local_var_params or
                local_var_params['inv_part_id'] is None):
            raise ApiValueError("Missing the required parameter `inv_part_id` when calling `users_lost_parts_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_token' in local_var_params:
            path_params['user_token'] = local_var_params['user_token']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'lost_quantity' in local_var_params:
            form_params.append(('lost_quantity', local_var_params['lost_quantity']))  # noqa: E501
        if 'inv_part_id' in local_var_params:
            form_params.append(('inv_part_id', local_var_params['inv_part_id']))  # noqa: E501

        body_params = None
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/x-www-form-urlencoded'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/users/{user_token}/lost_parts/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_lost_parts_delete(self, user_token, id, **kwargs):  # noqa: E501
        """Remove the Lost Part from the user.  # noqa: E501

        Remove the Lost Part from the user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_lost_parts_delete(user_token, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str user_token: user_token (required)
        :param str id: id (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.users_lost_parts_delete_with_http_info(user_token, id, **kwargs)  # noqa: E501

    def users_lost_parts_delete_with_http_info(self, user_token, id, **kwargs):  # noqa: E501
        """Remove the Lost Part from the user.  # noqa: E501

        Remove the Lost Part from the user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_lost_parts_delete_with_http_info(user_token, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str user_token: user_token (required)
        :param str id: id (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['user_token', 'id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_lost_parts_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'user_token' is set
        if ('user_token' not in local_var_params or
                local_var_params['user_token'] is None):
            raise ApiValueError("Missing the required parameter `user_token` when calling `users_lost_parts_delete`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in local_var_params or
                local_var_params['id'] is None):
            raise ApiValueError("Missing the required parameter `id` when calling `users_lost_parts_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_token' in local_var_params:
            path_params['user_token'] = local_var_params['user_token']  # noqa: E501
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/users/{user_token}/lost_parts/{id}/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_lost_parts_list(self, user_token, **kwargs):  # noqa: E501
        """Get a list of all the Lost Parts from the user's LEGO collection.  # noqa: E501

        Get a list of all the Lost Parts from the user's LEGO collection.  Optionally, filter by one or more of the below query parameters.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_lost_parts_list(user_token, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str user_token: user_token (required)
        :param str page: page
        :param str page_size: page_size
        :param str ordering: ordering
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ArrayOfLostParts
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.users_lost_parts_list_with_http_info(user_token, **kwargs)  # noqa: E501

    def users_lost_parts_list_with_http_info(self, user_token, **kwargs):  # noqa: E501
        """Get a list of all the Lost Parts from the user's LEGO collection.  # noqa: E501

        Get a list of all the Lost Parts from the user's LEGO collection.  Optionally, filter by one or more of the below query parameters.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_lost_parts_list_with_http_info(user_token, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str user_token: user_token (required)
        :param str page: page
        :param str page_size: page_size
        :param str ordering: ordering
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ArrayOfLostParts, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['user_token', 'page', 'page_size', 'ordering']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_lost_parts_list" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'user_token' is set
        if ('user_token' not in local_var_params or
                local_var_params['user_token'] is None):
            raise ApiValueError("Missing the required parameter `user_token` when calling `users_lost_parts_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_token' in local_var_params:
            path_params['user_token'] = local_var_params['user_token']  # noqa: E501

        query_params = []
        if 'page' in local_var_params:
            query_params.append(('page', local_var_params['page']))  # noqa: E501
        if 'page_size' in local_var_params:
            query_params.append(('page_size', local_var_params['page_size']))  # noqa: E501
        if 'ordering' in local_var_params:
            query_params.append(('ordering', local_var_params['ordering']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/users/{user_token}/lost_parts/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ArrayOfLostParts',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_partlists_create(self, user_token, name, **kwargs):  # noqa: E501
        """Add a new Part List.  # noqa: E501

        Add a new Part List.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_partlists_create(user_token, name, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str user_token: user_token (required)
        :param str name: name (required)
        :param str is_buildable: is_buildable
        :param str num_parts: num_parts
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: PartList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.users_partlists_create_with_http_info(user_token, name, **kwargs)  # noqa: E501

    def users_partlists_create_with_http_info(self, user_token, name, **kwargs):  # noqa: E501
        """Add a new Part List.  # noqa: E501

        Add a new Part List.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_partlists_create_with_http_info(user_token, name, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str user_token: user_token (required)
        :param str name: name (required)
        :param str is_buildable: is_buildable
        :param str num_parts: num_parts
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(PartList, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['user_token', 'name', 'is_buildable', 'num_parts']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_partlists_create" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'user_token' is set
        if ('user_token' not in local_var_params or
                local_var_params['user_token'] is None):
            raise ApiValueError("Missing the required parameter `user_token` when calling `users_partlists_create`")  # noqa: E501
        # verify the required parameter 'name' is set
        if ('name' not in local_var_params or
                local_var_params['name'] is None):
            raise ApiValueError("Missing the required parameter `name` when calling `users_partlists_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_token' in local_var_params:
            path_params['user_token'] = local_var_params['user_token']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'is_buildable' in local_var_params:
            form_params.append(('is_buildable', local_var_params['is_buildable']))  # noqa: E501
        if 'name' in local_var_params:
            form_params.append(('name', local_var_params['name']))  # noqa: E501
        if 'num_parts' in local_var_params:
            form_params.append(('num_parts', local_var_params['num_parts']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/x-www-form-urlencoded'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/users/{user_token}/partlists/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PartList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_partlists_delete(self, user_token, list_id, **kwargs):  # noqa: E501
        """Delete a Part List and all it's Parts.  # noqa: E501

        Delete a Part List and all it's Parts.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_partlists_delete(user_token, list_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str user_token: user_token (required)
        :param str list_id: list_id (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.users_partlists_delete_with_http_info(user_token, list_id, **kwargs)  # noqa: E501

    def users_partlists_delete_with_http_info(self, user_token, list_id, **kwargs):  # noqa: E501
        """Delete a Part List and all it's Parts.  # noqa: E501

        Delete a Part List and all it's Parts.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_partlists_delete_with_http_info(user_token, list_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str user_token: user_token (required)
        :param str list_id: list_id (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['user_token', 'list_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_partlists_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'user_token' is set
        if ('user_token' not in local_var_params or
                local_var_params['user_token'] is None):
            raise ApiValueError("Missing the required parameter `user_token` when calling `users_partlists_delete`")  # noqa: E501
        # verify the required parameter 'list_id' is set
        if ('list_id' not in local_var_params or
                local_var_params['list_id'] is None):
            raise ApiValueError("Missing the required parameter `list_id` when calling `users_partlists_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_token' in local_var_params:
            path_params['user_token'] = local_var_params['user_token']  # noqa: E501
        if 'list_id' in local_var_params:
            path_params['list_id'] = local_var_params['list_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/users/{user_token}/partlists/{list_id}/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_partlists_list(self, user_token, **kwargs):  # noqa: E501
        """Get a list of all the user's Part Lists.  # noqa: E501

        Get a list of all the user's Part Lists.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_partlists_list(user_token, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str user_token: user_token (required)
        :param str page: page
        :param str page_size: page_size
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ArrayOfPartLists
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.users_partlists_list_with_http_info(user_token, **kwargs)  # noqa: E501

    def users_partlists_list_with_http_info(self, user_token, **kwargs):  # noqa: E501
        """Get a list of all the user's Part Lists.  # noqa: E501

        Get a list of all the user's Part Lists.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_partlists_list_with_http_info(user_token, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str user_token: user_token (required)
        :param str page: page
        :param str page_size: page_size
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ArrayOfPartLists, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['user_token', 'page', 'page_size']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_partlists_list" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'user_token' is set
        if ('user_token' not in local_var_params or
                local_var_params['user_token'] is None):
            raise ApiValueError("Missing the required parameter `user_token` when calling `users_partlists_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_token' in local_var_params:
            path_params['user_token'] = local_var_params['user_token']  # noqa: E501

        query_params = []
        if 'page' in local_var_params:
            query_params.append(('page', local_var_params['page']))  # noqa: E501
        if 'page_size' in local_var_params:
            query_params.append(('page_size', local_var_params['page_size']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/users/{user_token}/partlists/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ArrayOfPartLists',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_partlists_partial_update(self, user_token, list_id, **kwargs):  # noqa: E501
        """Update an existing Part List's details.  # noqa: E501

        Update an existing Part List's details.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_partlists_partial_update(user_token, list_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str user_token: user_token (required)
        :param str list_id: list_id (required)
        :param str is_buildable: is_buildable
        :param str name: name
        :param str num_parts: num_parts
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.users_partlists_partial_update_with_http_info(user_token, list_id, **kwargs)  # noqa: E501

    def users_partlists_partial_update_with_http_info(self, user_token, list_id, **kwargs):  # noqa: E501
        """Update an existing Part List's details.  # noqa: E501

        Update an existing Part List's details.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_partlists_partial_update_with_http_info(user_token, list_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str user_token: user_token (required)
        :param str list_id: list_id (required)
        :param str is_buildable: is_buildable
        :param str name: name
        :param str num_parts: num_parts
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['user_token', 'list_id', 'is_buildable', 'name', 'num_parts']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_partlists_partial_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'user_token' is set
        if ('user_token' not in local_var_params or
                local_var_params['user_token'] is None):
            raise ApiValueError("Missing the required parameter `user_token` when calling `users_partlists_partial_update`")  # noqa: E501
        # verify the required parameter 'list_id' is set
        if ('list_id' not in local_var_params or
                local_var_params['list_id'] is None):
            raise ApiValueError("Missing the required parameter `list_id` when calling `users_partlists_partial_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_token' in local_var_params:
            path_params['user_token'] = local_var_params['user_token']  # noqa: E501
        if 'list_id' in local_var_params:
            path_params['list_id'] = local_var_params['list_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'is_buildable' in local_var_params:
            form_params.append(('is_buildable', local_var_params['is_buildable']))  # noqa: E501
        if 'name' in local_var_params:
            form_params.append(('name', local_var_params['name']))  # noqa: E501
        if 'num_parts' in local_var_params:
            form_params.append(('num_parts', local_var_params['num_parts']))  # noqa: E501

        body_params = None
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/x-www-form-urlencoded'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/users/{user_token}/partlists/{list_id}/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_partlists_parts_create(self, user_token, list_id, part_num, quantity, color_id, **kwargs):  # noqa: E501
        """Add one or more Parts to the Part List.  # noqa: E501

        Add one or more Parts to the Part List.  ### Single Part When adding a single Part, returns the successfully created Part (status 201) or details for why the Part could not be added. ### Multiple Parts To add multiple Parts, POST a JSON list of them (using a Content-Type header of 'application/json'). e.g: `[{\"part_num\":\"3001\", \"color_id\": 1, \"quantity\": 10}, {\"part_num\":\"3001\", \"color_id\": 2, \"quantity\": 20}, {\"part_num\":\"3002\", \"color_id\": 14, \"quantity\": 30}]` Returns a list of successfully added Parts. If the Part already exists or is unrecognised, it will be skipped.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_partlists_parts_create(user_token, list_id, part_num, quantity, color_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str user_token: user_token (required)
        :param str list_id: list_id (required)
        :param str part_num: part_num (required)
        :param str quantity: quantity (required)
        :param str color_id: color_id (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.users_partlists_parts_create_with_http_info(user_token, list_id, part_num, quantity, color_id, **kwargs)  # noqa: E501

    def users_partlists_parts_create_with_http_info(self, user_token, list_id, part_num, quantity, color_id, **kwargs):  # noqa: E501
        """Add one or more Parts to the Part List.  # noqa: E501

        Add one or more Parts to the Part List.  ### Single Part When adding a single Part, returns the successfully created Part (status 201) or details for why the Part could not be added. ### Multiple Parts To add multiple Parts, POST a JSON list of them (using a Content-Type header of 'application/json'). e.g: `[{\"part_num\":\"3001\", \"color_id\": 1, \"quantity\": 10}, {\"part_num\":\"3001\", \"color_id\": 2, \"quantity\": 20}, {\"part_num\":\"3002\", \"color_id\": 14, \"quantity\": 30}]` Returns a list of successfully added Parts. If the Part already exists or is unrecognised, it will be skipped.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_partlists_parts_create_with_http_info(user_token, list_id, part_num, quantity, color_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str user_token: user_token (required)
        :param str list_id: list_id (required)
        :param str part_num: part_num (required)
        :param str quantity: quantity (required)
        :param str color_id: color_id (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['user_token', 'list_id', 'part_num', 'quantity', 'color_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_partlists_parts_create" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'user_token' is set
        if ('user_token' not in local_var_params or
                local_var_params['user_token'] is None):
            raise ApiValueError("Missing the required parameter `user_token` when calling `users_partlists_parts_create`")  # noqa: E501
        # verify the required parameter 'list_id' is set
        if ('list_id' not in local_var_params or
                local_var_params['list_id'] is None):
            raise ApiValueError("Missing the required parameter `list_id` when calling `users_partlists_parts_create`")  # noqa: E501
        # verify the required parameter 'part_num' is set
        if ('part_num' not in local_var_params or
                local_var_params['part_num'] is None):
            raise ApiValueError("Missing the required parameter `part_num` when calling `users_partlists_parts_create`")  # noqa: E501
        # verify the required parameter 'quantity' is set
        if ('quantity' not in local_var_params or
                local_var_params['quantity'] is None):
            raise ApiValueError("Missing the required parameter `quantity` when calling `users_partlists_parts_create`")  # noqa: E501
        # verify the required parameter 'color_id' is set
        if ('color_id' not in local_var_params or
                local_var_params['color_id'] is None):
            raise ApiValueError("Missing the required parameter `color_id` when calling `users_partlists_parts_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_token' in local_var_params:
            path_params['user_token'] = local_var_params['user_token']  # noqa: E501
        if 'list_id' in local_var_params:
            path_params['list_id'] = local_var_params['list_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'part_num' in local_var_params:
            form_params.append(('part_num', local_var_params['part_num']))  # noqa: E501
        if 'quantity' in local_var_params:
            form_params.append(('quantity', local_var_params['quantity']))  # noqa: E501
        if 'color_id' in local_var_params:
            form_params.append(('color_id', local_var_params['color_id']))  # noqa: E501

        body_params = None
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/x-www-form-urlencoded'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/users/{user_token}/partlists/{list_id}/parts/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_partlists_parts_delete(self, user_token, list_id, color_id, part_num, **kwargs):  # noqa: E501
        """Delete a Part from the Part List.  # noqa: E501

        Delete a Part from the Part List.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_partlists_parts_delete(user_token, list_id, color_id, part_num, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str user_token: user_token (required)
        :param str list_id: list_id (required)
        :param str color_id: color_id (required)
        :param str part_num: part_num (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.users_partlists_parts_delete_with_http_info(user_token, list_id, color_id, part_num, **kwargs)  # noqa: E501

    def users_partlists_parts_delete_with_http_info(self, user_token, list_id, color_id, part_num, **kwargs):  # noqa: E501
        """Delete a Part from the Part List.  # noqa: E501

        Delete a Part from the Part List.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_partlists_parts_delete_with_http_info(user_token, list_id, color_id, part_num, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str user_token: user_token (required)
        :param str list_id: list_id (required)
        :param str color_id: color_id (required)
        :param str part_num: part_num (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['user_token', 'list_id', 'color_id', 'part_num']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_partlists_parts_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'user_token' is set
        if ('user_token' not in local_var_params or
                local_var_params['user_token'] is None):
            raise ApiValueError("Missing the required parameter `user_token` when calling `users_partlists_parts_delete`")  # noqa: E501
        # verify the required parameter 'list_id' is set
        if ('list_id' not in local_var_params or
                local_var_params['list_id'] is None):
            raise ApiValueError("Missing the required parameter `list_id` when calling `users_partlists_parts_delete`")  # noqa: E501
        # verify the required parameter 'color_id' is set
        if ('color_id' not in local_var_params or
                local_var_params['color_id'] is None):
            raise ApiValueError("Missing the required parameter `color_id` when calling `users_partlists_parts_delete`")  # noqa: E501
        # verify the required parameter 'part_num' is set
        if ('part_num' not in local_var_params or
                local_var_params['part_num'] is None):
            raise ApiValueError("Missing the required parameter `part_num` when calling `users_partlists_parts_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_token' in local_var_params:
            path_params['user_token'] = local_var_params['user_token']  # noqa: E501
        if 'list_id' in local_var_params:
            path_params['list_id'] = local_var_params['list_id']  # noqa: E501
        if 'color_id' in local_var_params:
            path_params['color_id'] = local_var_params['color_id']  # noqa: E501
        if 'part_num' in local_var_params:
            path_params['part_num'] = local_var_params['part_num']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/users/{user_token}/partlists/{list_id}/parts/{part_num}/{color_id}/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_partlists_parts_list(self, user_token, list_id, **kwargs):  # noqa: E501
        """Get a list of all the Parts in a specific Part List.  # noqa: E501

        Get a list of all the Parts in a specific Part List.  Optional parameter inc_part_details=1 can be used to return additional part fields, the same as for a single part lookup.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_partlists_parts_list(user_token, list_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str user_token: user_token (required)
        :param str list_id: list_id (required)
        :param str page: page
        :param str page_size: page_size
        :param str ordering: ordering
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ArrayOfPartListParts
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.users_partlists_parts_list_with_http_info(user_token, list_id, **kwargs)  # noqa: E501

    def users_partlists_parts_list_with_http_info(self, user_token, list_id, **kwargs):  # noqa: E501
        """Get a list of all the Parts in a specific Part List.  # noqa: E501

        Get a list of all the Parts in a specific Part List.  Optional parameter inc_part_details=1 can be used to return additional part fields, the same as for a single part lookup.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_partlists_parts_list_with_http_info(user_token, list_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str user_token: user_token (required)
        :param str list_id: list_id (required)
        :param str page: page
        :param str page_size: page_size
        :param str ordering: ordering
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ArrayOfPartListParts, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['user_token', 'list_id', 'page', 'page_size', 'ordering']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_partlists_parts_list" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'user_token' is set
        if ('user_token' not in local_var_params or
                local_var_params['user_token'] is None):
            raise ApiValueError("Missing the required parameter `user_token` when calling `users_partlists_parts_list`")  # noqa: E501
        # verify the required parameter 'list_id' is set
        if ('list_id' not in local_var_params or
                local_var_params['list_id'] is None):
            raise ApiValueError("Missing the required parameter `list_id` when calling `users_partlists_parts_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_token' in local_var_params:
            path_params['user_token'] = local_var_params['user_token']  # noqa: E501
        if 'list_id' in local_var_params:
            path_params['list_id'] = local_var_params['list_id']  # noqa: E501

        query_params = []
        if 'page' in local_var_params:
            query_params.append(('page', local_var_params['page']))  # noqa: E501
        if 'page_size' in local_var_params:
            query_params.append(('page_size', local_var_params['page_size']))  # noqa: E501
        if 'ordering' in local_var_params:
            query_params.append(('ordering', local_var_params['ordering']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/users/{user_token}/partlists/{list_id}/parts/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ArrayOfPartListParts',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_partlists_parts_read(self, user_token, list_id, color_id, part_num, **kwargs):  # noqa: E501
        """Get details about a specific Part in the Part List.  # noqa: E501

        Get details about a specific Part in the Part List.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_partlists_parts_read(user_token, list_id, color_id, part_num, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str user_token: user_token (required)
        :param str list_id: list_id (required)
        :param str color_id: color_id (required)
        :param str part_num: part_num (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: PartListPart
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.users_partlists_parts_read_with_http_info(user_token, list_id, color_id, part_num, **kwargs)  # noqa: E501

    def users_partlists_parts_read_with_http_info(self, user_token, list_id, color_id, part_num, **kwargs):  # noqa: E501
        """Get details about a specific Part in the Part List.  # noqa: E501

        Get details about a specific Part in the Part List.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_partlists_parts_read_with_http_info(user_token, list_id, color_id, part_num, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str user_token: user_token (required)
        :param str list_id: list_id (required)
        :param str color_id: color_id (required)
        :param str part_num: part_num (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(PartListPart, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['user_token', 'list_id', 'color_id', 'part_num']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_partlists_parts_read" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'user_token' is set
        if ('user_token' not in local_var_params or
                local_var_params['user_token'] is None):
            raise ApiValueError("Missing the required parameter `user_token` when calling `users_partlists_parts_read`")  # noqa: E501
        # verify the required parameter 'list_id' is set
        if ('list_id' not in local_var_params or
                local_var_params['list_id'] is None):
            raise ApiValueError("Missing the required parameter `list_id` when calling `users_partlists_parts_read`")  # noqa: E501
        # verify the required parameter 'color_id' is set
        if ('color_id' not in local_var_params or
                local_var_params['color_id'] is None):
            raise ApiValueError("Missing the required parameter `color_id` when calling `users_partlists_parts_read`")  # noqa: E501
        # verify the required parameter 'part_num' is set
        if ('part_num' not in local_var_params or
                local_var_params['part_num'] is None):
            raise ApiValueError("Missing the required parameter `part_num` when calling `users_partlists_parts_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_token' in local_var_params:
            path_params['user_token'] = local_var_params['user_token']  # noqa: E501
        if 'list_id' in local_var_params:
            path_params['list_id'] = local_var_params['list_id']  # noqa: E501
        if 'color_id' in local_var_params:
            path_params['color_id'] = local_var_params['color_id']  # noqa: E501
        if 'part_num' in local_var_params:
            path_params['part_num'] = local_var_params['part_num']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/users/{user_token}/partlists/{list_id}/parts/{part_num}/{color_id}/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PartListPart',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_partlists_parts_update(self, user_token, list_id, color_id, part_num, quantity, **kwargs):  # noqa: E501
        """Replace an existing Part's details in the Part List.  # noqa: E501

        Replace an existing Part's details in the Part List.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_partlists_parts_update(user_token, list_id, color_id, part_num, quantity, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str user_token: user_token (required)
        :param str list_id: list_id (required)
        :param str color_id: color_id (required)
        :param str part_num: part_num (required)
        :param str quantity: quantity (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.users_partlists_parts_update_with_http_info(user_token, list_id, color_id, part_num, quantity, **kwargs)  # noqa: E501

    def users_partlists_parts_update_with_http_info(self, user_token, list_id, color_id, part_num, quantity, **kwargs):  # noqa: E501
        """Replace an existing Part's details in the Part List.  # noqa: E501

        Replace an existing Part's details in the Part List.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_partlists_parts_update_with_http_info(user_token, list_id, color_id, part_num, quantity, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str user_token: user_token (required)
        :param str list_id: list_id (required)
        :param str color_id: color_id (required)
        :param str part_num: part_num (required)
        :param str quantity: quantity (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['user_token', 'list_id', 'color_id', 'part_num', 'quantity']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_partlists_parts_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'user_token' is set
        if ('user_token' not in local_var_params or
                local_var_params['user_token'] is None):
            raise ApiValueError("Missing the required parameter `user_token` when calling `users_partlists_parts_update`")  # noqa: E501
        # verify the required parameter 'list_id' is set
        if ('list_id' not in local_var_params or
                local_var_params['list_id'] is None):
            raise ApiValueError("Missing the required parameter `list_id` when calling `users_partlists_parts_update`")  # noqa: E501
        # verify the required parameter 'color_id' is set
        if ('color_id' not in local_var_params or
                local_var_params['color_id'] is None):
            raise ApiValueError("Missing the required parameter `color_id` when calling `users_partlists_parts_update`")  # noqa: E501
        # verify the required parameter 'part_num' is set
        if ('part_num' not in local_var_params or
                local_var_params['part_num'] is None):
            raise ApiValueError("Missing the required parameter `part_num` when calling `users_partlists_parts_update`")  # noqa: E501
        # verify the required parameter 'quantity' is set
        if ('quantity' not in local_var_params or
                local_var_params['quantity'] is None):
            raise ApiValueError("Missing the required parameter `quantity` when calling `users_partlists_parts_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_token' in local_var_params:
            path_params['user_token'] = local_var_params['user_token']  # noqa: E501
        if 'list_id' in local_var_params:
            path_params['list_id'] = local_var_params['list_id']  # noqa: E501
        if 'color_id' in local_var_params:
            path_params['color_id'] = local_var_params['color_id']  # noqa: E501
        if 'part_num' in local_var_params:
            path_params['part_num'] = local_var_params['part_num']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'quantity' in local_var_params:
            form_params.append(('quantity', local_var_params['quantity']))  # noqa: E501

        body_params = None
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/x-www-form-urlencoded'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/users/{user_token}/partlists/{list_id}/parts/{part_num}/{color_id}/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_partlists_read(self, user_token, list_id, **kwargs):  # noqa: E501
        """Get details about a specific Part List.  # noqa: E501

        Get details about a specific Part List.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_partlists_read(user_token, list_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str user_token: user_token (required)
        :param str list_id: list_id (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: PartList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.users_partlists_read_with_http_info(user_token, list_id, **kwargs)  # noqa: E501

    def users_partlists_read_with_http_info(self, user_token, list_id, **kwargs):  # noqa: E501
        """Get details about a specific Part List.  # noqa: E501

        Get details about a specific Part List.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_partlists_read_with_http_info(user_token, list_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str user_token: user_token (required)
        :param str list_id: list_id (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(PartList, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['user_token', 'list_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_partlists_read" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'user_token' is set
        if ('user_token' not in local_var_params or
                local_var_params['user_token'] is None):
            raise ApiValueError("Missing the required parameter `user_token` when calling `users_partlists_read`")  # noqa: E501
        # verify the required parameter 'list_id' is set
        if ('list_id' not in local_var_params or
                local_var_params['list_id'] is None):
            raise ApiValueError("Missing the required parameter `list_id` when calling `users_partlists_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_token' in local_var_params:
            path_params['user_token'] = local_var_params['user_token']  # noqa: E501
        if 'list_id' in local_var_params:
            path_params['list_id'] = local_var_params['list_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/users/{user_token}/partlists/{list_id}/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PartList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_partlists_update(self, user_token, list_id, name, **kwargs):  # noqa: E501
        """Replace an existing Part List's details.  # noqa: E501

        Replace an existing Part List's details.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_partlists_update(user_token, list_id, name, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str user_token: user_token (required)
        :param str list_id: list_id (required)
        :param str name: name (required)
        :param str is_buildable: is_buildable
        :param str num_parts: num_parts
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.users_partlists_update_with_http_info(user_token, list_id, name, **kwargs)  # noqa: E501

    def users_partlists_update_with_http_info(self, user_token, list_id, name, **kwargs):  # noqa: E501
        """Replace an existing Part List's details.  # noqa: E501

        Replace an existing Part List's details.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_partlists_update_with_http_info(user_token, list_id, name, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str user_token: user_token (required)
        :param str list_id: list_id (required)
        :param str name: name (required)
        :param str is_buildable: is_buildable
        :param str num_parts: num_parts
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['user_token', 'list_id', 'name', 'is_buildable', 'num_parts']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_partlists_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'user_token' is set
        if ('user_token' not in local_var_params or
                local_var_params['user_token'] is None):
            raise ApiValueError("Missing the required parameter `user_token` when calling `users_partlists_update`")  # noqa: E501
        # verify the required parameter 'list_id' is set
        if ('list_id' not in local_var_params or
                local_var_params['list_id'] is None):
            raise ApiValueError("Missing the required parameter `list_id` when calling `users_partlists_update`")  # noqa: E501
        # verify the required parameter 'name' is set
        if ('name' not in local_var_params or
                local_var_params['name'] is None):
            raise ApiValueError("Missing the required parameter `name` when calling `users_partlists_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_token' in local_var_params:
            path_params['user_token'] = local_var_params['user_token']  # noqa: E501
        if 'list_id' in local_var_params:
            path_params['list_id'] = local_var_params['list_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'is_buildable' in local_var_params:
            form_params.append(('is_buildable', local_var_params['is_buildable']))  # noqa: E501
        if 'name' in local_var_params:
            form_params.append(('name', local_var_params['name']))  # noqa: E501
        if 'num_parts' in local_var_params:
            form_params.append(('num_parts', local_var_params['num_parts']))  # noqa: E501

        body_params = None
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/x-www-form-urlencoded'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/users/{user_token}/partlists/{list_id}/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_parts_list(self, user_token, **kwargs):  # noqa: E501
        """Get a list of all the Parts in all the user's Part Lists.  # noqa: E501

        Get a list of all the Parts in all the user's Part Lists.  Optional parameter inc_part_details=1 can be used to return additional part fields, the same as for a single part lookup.  ###Set List logic Parts appearing in multiple Part Lists will be listed multiple times.  Optionally, filter by one or more of the below query parameters.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_parts_list(user_token, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str user_token: user_token (required)
        :param str page: page
        :param str page_size: page_size
        :param str part_num: part_num
        :param str part_cat_id: part_cat_id
        :param str color_id: color_id
        :param str ordering: ordering
        :param str search: search
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ArrayOfPartListParts
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.users_parts_list_with_http_info(user_token, **kwargs)  # noqa: E501

    def users_parts_list_with_http_info(self, user_token, **kwargs):  # noqa: E501
        """Get a list of all the Parts in all the user's Part Lists.  # noqa: E501

        Get a list of all the Parts in all the user's Part Lists.  Optional parameter inc_part_details=1 can be used to return additional part fields, the same as for a single part lookup.  ###Set List logic Parts appearing in multiple Part Lists will be listed multiple times.  Optionally, filter by one or more of the below query parameters.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_parts_list_with_http_info(user_token, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str user_token: user_token (required)
        :param str page: page
        :param str page_size: page_size
        :param str part_num: part_num
        :param str part_cat_id: part_cat_id
        :param str color_id: color_id
        :param str ordering: ordering
        :param str search: search
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ArrayOfPartListParts, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['user_token', 'page', 'page_size', 'part_num', 'part_cat_id', 'color_id', 'ordering', 'search']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_parts_list" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'user_token' is set
        if ('user_token' not in local_var_params or
                local_var_params['user_token'] is None):
            raise ApiValueError("Missing the required parameter `user_token` when calling `users_parts_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_token' in local_var_params:
            path_params['user_token'] = local_var_params['user_token']  # noqa: E501

        query_params = []
        if 'page' in local_var_params:
            query_params.append(('page', local_var_params['page']))  # noqa: E501
        if 'page_size' in local_var_params:
            query_params.append(('page_size', local_var_params['page_size']))  # noqa: E501
        if 'part_num' in local_var_params:
            query_params.append(('part_num', local_var_params['part_num']))  # noqa: E501
        if 'part_cat_id' in local_var_params:
            query_params.append(('part_cat_id', local_var_params['part_cat_id']))  # noqa: E501
        if 'color_id' in local_var_params:
            query_params.append(('color_id', local_var_params['color_id']))  # noqa: E501
        if 'ordering' in local_var_params:
            query_params.append(('ordering', local_var_params['ordering']))  # noqa: E501
        if 'search' in local_var_params:
            query_params.append(('search', local_var_params['search']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/users/{user_token}/parts/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ArrayOfPartListParts',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_profile_list(self, user_token, **kwargs):  # noqa: E501
        """Get details about a specific user.  # noqa: E501

        Get details about a specific user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_profile_list(user_token, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str user_token: user_token (required)
        :param str page: page
        :param str page_size: page_size
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Profile
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.users_profile_list_with_http_info(user_token, **kwargs)  # noqa: E501

    def users_profile_list_with_http_info(self, user_token, **kwargs):  # noqa: E501
        """Get details about a specific user.  # noqa: E501

        Get details about a specific user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_profile_list_with_http_info(user_token, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str user_token: user_token (required)
        :param str page: page
        :param str page_size: page_size
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Profile, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['user_token', 'page', 'page_size']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_profile_list" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'user_token' is set
        if ('user_token' not in local_var_params or
                local_var_params['user_token'] is None):
            raise ApiValueError("Missing the required parameter `user_token` when calling `users_profile_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_token' in local_var_params:
            path_params['user_token'] = local_var_params['user_token']  # noqa: E501

        query_params = []
        if 'page' in local_var_params:
            query_params.append(('page', local_var_params['page']))  # noqa: E501
        if 'page_size' in local_var_params:
            query_params.append(('page_size', local_var_params['page_size']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/users/{user_token}/profile/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Profile',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_setlists_create(self, user_token, name, **kwargs):  # noqa: E501
        """Add a new Set List.  # noqa: E501

        Add a new Set List.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_setlists_create(user_token, name, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str user_token: user_token (required)
        :param str name: name (required)
        :param str is_buildable: is_buildable
        :param str num_sets: num_sets
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: SetList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.users_setlists_create_with_http_info(user_token, name, **kwargs)  # noqa: E501

    def users_setlists_create_with_http_info(self, user_token, name, **kwargs):  # noqa: E501
        """Add a new Set List.  # noqa: E501

        Add a new Set List.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_setlists_create_with_http_info(user_token, name, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str user_token: user_token (required)
        :param str name: name (required)
        :param str is_buildable: is_buildable
        :param str num_sets: num_sets
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(SetList, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['user_token', 'name', 'is_buildable', 'num_sets']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_setlists_create" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'user_token' is set
        if ('user_token' not in local_var_params or
                local_var_params['user_token'] is None):
            raise ApiValueError("Missing the required parameter `user_token` when calling `users_setlists_create`")  # noqa: E501
        # verify the required parameter 'name' is set
        if ('name' not in local_var_params or
                local_var_params['name'] is None):
            raise ApiValueError("Missing the required parameter `name` when calling `users_setlists_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_token' in local_var_params:
            path_params['user_token'] = local_var_params['user_token']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'is_buildable' in local_var_params:
            form_params.append(('is_buildable', local_var_params['is_buildable']))  # noqa: E501
        if 'name' in local_var_params:
            form_params.append(('name', local_var_params['name']))  # noqa: E501
        if 'num_sets' in local_var_params:
            form_params.append(('num_sets', local_var_params['num_sets']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/x-www-form-urlencoded'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/users/{user_token}/setlists/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SetList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_setlists_delete(self, user_token, list_id, **kwargs):  # noqa: E501
        """Delete a Set List and all it's Sets.  # noqa: E501

        Delete a Set List and all it's Sets.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_setlists_delete(user_token, list_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str user_token: user_token (required)
        :param str list_id: list_id (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.users_setlists_delete_with_http_info(user_token, list_id, **kwargs)  # noqa: E501

    def users_setlists_delete_with_http_info(self, user_token, list_id, **kwargs):  # noqa: E501
        """Delete a Set List and all it's Sets.  # noqa: E501

        Delete a Set List and all it's Sets.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_setlists_delete_with_http_info(user_token, list_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str user_token: user_token (required)
        :param str list_id: list_id (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['user_token', 'list_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_setlists_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'user_token' is set
        if ('user_token' not in local_var_params or
                local_var_params['user_token'] is None):
            raise ApiValueError("Missing the required parameter `user_token` when calling `users_setlists_delete`")  # noqa: E501
        # verify the required parameter 'list_id' is set
        if ('list_id' not in local_var_params or
                local_var_params['list_id'] is None):
            raise ApiValueError("Missing the required parameter `list_id` when calling `users_setlists_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_token' in local_var_params:
            path_params['user_token'] = local_var_params['user_token']  # noqa: E501
        if 'list_id' in local_var_params:
            path_params['list_id'] = local_var_params['list_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/users/{user_token}/setlists/{list_id}/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_setlists_list(self, user_token, **kwargs):  # noqa: E501
        """Get a list of all the user's Set Lists.  # noqa: E501

        Get a list of all the user's Set Lists.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_setlists_list(user_token, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str user_token: user_token (required)
        :param str page: page
        :param str page_size: page_size
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ArrayOfSetLists
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.users_setlists_list_with_http_info(user_token, **kwargs)  # noqa: E501

    def users_setlists_list_with_http_info(self, user_token, **kwargs):  # noqa: E501
        """Get a list of all the user's Set Lists.  # noqa: E501

        Get a list of all the user's Set Lists.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_setlists_list_with_http_info(user_token, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str user_token: user_token (required)
        :param str page: page
        :param str page_size: page_size
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ArrayOfSetLists, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['user_token', 'page', 'page_size']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_setlists_list" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'user_token' is set
        if ('user_token' not in local_var_params or
                local_var_params['user_token'] is None):
            raise ApiValueError("Missing the required parameter `user_token` when calling `users_setlists_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_token' in local_var_params:
            path_params['user_token'] = local_var_params['user_token']  # noqa: E501

        query_params = []
        if 'page' in local_var_params:
            query_params.append(('page', local_var_params['page']))  # noqa: E501
        if 'page_size' in local_var_params:
            query_params.append(('page_size', local_var_params['page_size']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/users/{user_token}/setlists/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ArrayOfSetLists',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_setlists_partial_update(self, user_token, list_id, **kwargs):  # noqa: E501
        """Update an existing Set List's details.  # noqa: E501

        Update an existing Set List's details.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_setlists_partial_update(user_token, list_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str user_token: user_token (required)
        :param str list_id: list_id (required)
        :param str is_buildable: is_buildable
        :param str name: name
        :param str num_sets: num_sets
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.users_setlists_partial_update_with_http_info(user_token, list_id, **kwargs)  # noqa: E501

    def users_setlists_partial_update_with_http_info(self, user_token, list_id, **kwargs):  # noqa: E501
        """Update an existing Set List's details.  # noqa: E501

        Update an existing Set List's details.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_setlists_partial_update_with_http_info(user_token, list_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str user_token: user_token (required)
        :param str list_id: list_id (required)
        :param str is_buildable: is_buildable
        :param str name: name
        :param str num_sets: num_sets
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['user_token', 'list_id', 'is_buildable', 'name', 'num_sets']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_setlists_partial_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'user_token' is set
        if ('user_token' not in local_var_params or
                local_var_params['user_token'] is None):
            raise ApiValueError("Missing the required parameter `user_token` when calling `users_setlists_partial_update`")  # noqa: E501
        # verify the required parameter 'list_id' is set
        if ('list_id' not in local_var_params or
                local_var_params['list_id'] is None):
            raise ApiValueError("Missing the required parameter `list_id` when calling `users_setlists_partial_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_token' in local_var_params:
            path_params['user_token'] = local_var_params['user_token']  # noqa: E501
        if 'list_id' in local_var_params:
            path_params['list_id'] = local_var_params['list_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'is_buildable' in local_var_params:
            form_params.append(('is_buildable', local_var_params['is_buildable']))  # noqa: E501
        if 'name' in local_var_params:
            form_params.append(('name', local_var_params['name']))  # noqa: E501
        if 'num_sets' in local_var_params:
            form_params.append(('num_sets', local_var_params['num_sets']))  # noqa: E501

        body_params = None
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/x-www-form-urlencoded'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/users/{user_token}/setlists/{list_id}/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_setlists_read(self, user_token, list_id, **kwargs):  # noqa: E501
        """Get details about a specific Set List.  # noqa: E501

        Get details about a specific Set List.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_setlists_read(user_token, list_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str user_token: user_token (required)
        :param str list_id: list_id (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: SetList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.users_setlists_read_with_http_info(user_token, list_id, **kwargs)  # noqa: E501

    def users_setlists_read_with_http_info(self, user_token, list_id, **kwargs):  # noqa: E501
        """Get details about a specific Set List.  # noqa: E501

        Get details about a specific Set List.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_setlists_read_with_http_info(user_token, list_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str user_token: user_token (required)
        :param str list_id: list_id (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(SetList, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['user_token', 'list_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_setlists_read" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'user_token' is set
        if ('user_token' not in local_var_params or
                local_var_params['user_token'] is None):
            raise ApiValueError("Missing the required parameter `user_token` when calling `users_setlists_read`")  # noqa: E501
        # verify the required parameter 'list_id' is set
        if ('list_id' not in local_var_params or
                local_var_params['list_id'] is None):
            raise ApiValueError("Missing the required parameter `list_id` when calling `users_setlists_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_token' in local_var_params:
            path_params['user_token'] = local_var_params['user_token']  # noqa: E501
        if 'list_id' in local_var_params:
            path_params['list_id'] = local_var_params['list_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/users/{user_token}/setlists/{list_id}/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SetList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_setlists_sets_create(self, user_token, list_id, set_num, **kwargs):  # noqa: E501
        """Add one or more Sets to the Set List. Existing Sets are unaffected.  # noqa: E501

        Add one or more Sets to the Set List. Existing Sets are unaffected.  ### Single Set When adding a single Set, returns the successfully created Set (status 201) or details for why the Set could not be added. ### Multiple Sets To add multiple Sets, POST a JSON list of them (using a Content-Type header of 'application/json'). e.g: `[{\"set_num\":\"8043-1\", \"quantity\": 1}, {\"set_num\":\"8110-1\", \"quantity\": 2, \"include_spares\": \"False\"}]` Returns a list of successfully added Sets. If the Set already exists or is unrecognised, it will be skipped.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_setlists_sets_create(user_token, list_id, set_num, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str user_token: user_token (required)
        :param str list_id: list_id (required)
        :param str set_num: set_num (required)
        :param str quantity: quantity
        :param str include_spares: include_spares
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.users_setlists_sets_create_with_http_info(user_token, list_id, set_num, **kwargs)  # noqa: E501

    def users_setlists_sets_create_with_http_info(self, user_token, list_id, set_num, **kwargs):  # noqa: E501
        """Add one or more Sets to the Set List. Existing Sets are unaffected.  # noqa: E501

        Add one or more Sets to the Set List. Existing Sets are unaffected.  ### Single Set When adding a single Set, returns the successfully created Set (status 201) or details for why the Set could not be added. ### Multiple Sets To add multiple Sets, POST a JSON list of them (using a Content-Type header of 'application/json'). e.g: `[{\"set_num\":\"8043-1\", \"quantity\": 1}, {\"set_num\":\"8110-1\", \"quantity\": 2, \"include_spares\": \"False\"}]` Returns a list of successfully added Sets. If the Set already exists or is unrecognised, it will be skipped.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_setlists_sets_create_with_http_info(user_token, list_id, set_num, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str user_token: user_token (required)
        :param str list_id: list_id (required)
        :param str set_num: set_num (required)
        :param str quantity: quantity
        :param str include_spares: include_spares
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['user_token', 'list_id', 'set_num', 'quantity', 'include_spares']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_setlists_sets_create" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'user_token' is set
        if ('user_token' not in local_var_params or
                local_var_params['user_token'] is None):
            raise ApiValueError("Missing the required parameter `user_token` when calling `users_setlists_sets_create`")  # noqa: E501
        # verify the required parameter 'list_id' is set
        if ('list_id' not in local_var_params or
                local_var_params['list_id'] is None):
            raise ApiValueError("Missing the required parameter `list_id` when calling `users_setlists_sets_create`")  # noqa: E501
        # verify the required parameter 'set_num' is set
        if ('set_num' not in local_var_params or
                local_var_params['set_num'] is None):
            raise ApiValueError("Missing the required parameter `set_num` when calling `users_setlists_sets_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_token' in local_var_params:
            path_params['user_token'] = local_var_params['user_token']  # noqa: E501
        if 'list_id' in local_var_params:
            path_params['list_id'] = local_var_params['list_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'set_num' in local_var_params:
            form_params.append(('set_num', local_var_params['set_num']))  # noqa: E501
        if 'quantity' in local_var_params:
            form_params.append(('quantity', local_var_params['quantity']))  # noqa: E501
        if 'include_spares' in local_var_params:
            form_params.append(('include_spares', local_var_params['include_spares']))  # noqa: E501

        body_params = None
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/x-www-form-urlencoded'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/users/{user_token}/setlists/{list_id}/sets/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_setlists_sets_delete(self, user_token, list_id, set_num, **kwargs):  # noqa: E501
        """Delete a Set from the Set List.  # noqa: E501

        Delete a Set from the Set List.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_setlists_sets_delete(user_token, list_id, set_num, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str user_token: user_token (required)
        :param str list_id: list_id (required)
        :param str set_num: set_num (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.users_setlists_sets_delete_with_http_info(user_token, list_id, set_num, **kwargs)  # noqa: E501

    def users_setlists_sets_delete_with_http_info(self, user_token, list_id, set_num, **kwargs):  # noqa: E501
        """Delete a Set from the Set List.  # noqa: E501

        Delete a Set from the Set List.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_setlists_sets_delete_with_http_info(user_token, list_id, set_num, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str user_token: user_token (required)
        :param str list_id: list_id (required)
        :param str set_num: set_num (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['user_token', 'list_id', 'set_num']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_setlists_sets_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'user_token' is set
        if ('user_token' not in local_var_params or
                local_var_params['user_token'] is None):
            raise ApiValueError("Missing the required parameter `user_token` when calling `users_setlists_sets_delete`")  # noqa: E501
        # verify the required parameter 'list_id' is set
        if ('list_id' not in local_var_params or
                local_var_params['list_id'] is None):
            raise ApiValueError("Missing the required parameter `list_id` when calling `users_setlists_sets_delete`")  # noqa: E501
        # verify the required parameter 'set_num' is set
        if ('set_num' not in local_var_params or
                local_var_params['set_num'] is None):
            raise ApiValueError("Missing the required parameter `set_num` when calling `users_setlists_sets_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_token' in local_var_params:
            path_params['user_token'] = local_var_params['user_token']  # noqa: E501
        if 'list_id' in local_var_params:
            path_params['list_id'] = local_var_params['list_id']  # noqa: E501
        if 'set_num' in local_var_params:
            path_params['set_num'] = local_var_params['set_num']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/users/{user_token}/setlists/{list_id}/sets/{set_num}/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_setlists_sets_list(self, user_token, list_id, **kwargs):  # noqa: E501
        """Get a list of all the Sets in a specific Set List.  # noqa: E501

        Get a list of all the Sets in a specific Set List.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_setlists_sets_list(user_token, list_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str user_token: user_token (required)
        :param str list_id: list_id (required)
        :param str page: page
        :param str page_size: page_size
        :param str ordering: ordering
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ArrayOfSetListSets
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.users_setlists_sets_list_with_http_info(user_token, list_id, **kwargs)  # noqa: E501

    def users_setlists_sets_list_with_http_info(self, user_token, list_id, **kwargs):  # noqa: E501
        """Get a list of all the Sets in a specific Set List.  # noqa: E501

        Get a list of all the Sets in a specific Set List.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_setlists_sets_list_with_http_info(user_token, list_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str user_token: user_token (required)
        :param str list_id: list_id (required)
        :param str page: page
        :param str page_size: page_size
        :param str ordering: ordering
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ArrayOfSetListSets, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['user_token', 'list_id', 'page', 'page_size', 'ordering']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_setlists_sets_list" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'user_token' is set
        if ('user_token' not in local_var_params or
                local_var_params['user_token'] is None):
            raise ApiValueError("Missing the required parameter `user_token` when calling `users_setlists_sets_list`")  # noqa: E501
        # verify the required parameter 'list_id' is set
        if ('list_id' not in local_var_params or
                local_var_params['list_id'] is None):
            raise ApiValueError("Missing the required parameter `list_id` when calling `users_setlists_sets_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_token' in local_var_params:
            path_params['user_token'] = local_var_params['user_token']  # noqa: E501
        if 'list_id' in local_var_params:
            path_params['list_id'] = local_var_params['list_id']  # noqa: E501

        query_params = []
        if 'page' in local_var_params:
            query_params.append(('page', local_var_params['page']))  # noqa: E501
        if 'page_size' in local_var_params:
            query_params.append(('page_size', local_var_params['page_size']))  # noqa: E501
        if 'ordering' in local_var_params:
            query_params.append(('ordering', local_var_params['ordering']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/users/{user_token}/setlists/{list_id}/sets/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ArrayOfSetListSets',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_setlists_sets_partial_update(self, user_token, list_id, set_num, **kwargs):  # noqa: E501
        """Update an existing Set's details in the Set List.  # noqa: E501

        Update an existing Set's details in the Set List.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_setlists_sets_partial_update(user_token, list_id, set_num, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str user_token: user_token (required)
        :param str list_id: list_id (required)
        :param str set_num: set_num (required)
        :param str quantity: quantity
        :param str include_spares: include_spares
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.users_setlists_sets_partial_update_with_http_info(user_token, list_id, set_num, **kwargs)  # noqa: E501

    def users_setlists_sets_partial_update_with_http_info(self, user_token, list_id, set_num, **kwargs):  # noqa: E501
        """Update an existing Set's details in the Set List.  # noqa: E501

        Update an existing Set's details in the Set List.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_setlists_sets_partial_update_with_http_info(user_token, list_id, set_num, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str user_token: user_token (required)
        :param str list_id: list_id (required)
        :param str set_num: set_num (required)
        :param str quantity: quantity
        :param str include_spares: include_spares
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['user_token', 'list_id', 'set_num', 'quantity', 'include_spares']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_setlists_sets_partial_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'user_token' is set
        if ('user_token' not in local_var_params or
                local_var_params['user_token'] is None):
            raise ApiValueError("Missing the required parameter `user_token` when calling `users_setlists_sets_partial_update`")  # noqa: E501
        # verify the required parameter 'list_id' is set
        if ('list_id' not in local_var_params or
                local_var_params['list_id'] is None):
            raise ApiValueError("Missing the required parameter `list_id` when calling `users_setlists_sets_partial_update`")  # noqa: E501
        # verify the required parameter 'set_num' is set
        if ('set_num' not in local_var_params or
                local_var_params['set_num'] is None):
            raise ApiValueError("Missing the required parameter `set_num` when calling `users_setlists_sets_partial_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_token' in local_var_params:
            path_params['user_token'] = local_var_params['user_token']  # noqa: E501
        if 'list_id' in local_var_params:
            path_params['list_id'] = local_var_params['list_id']  # noqa: E501
        if 'set_num' in local_var_params:
            path_params['set_num'] = local_var_params['set_num']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'quantity' in local_var_params:
            form_params.append(('quantity', local_var_params['quantity']))  # noqa: E501
        if 'include_spares' in local_var_params:
            form_params.append(('include_spares', local_var_params['include_spares']))  # noqa: E501

        body_params = None
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/x-www-form-urlencoded'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/users/{user_token}/setlists/{list_id}/sets/{set_num}/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_setlists_sets_read(self, user_token, list_id, set_num, **kwargs):  # noqa: E501
        """Get details about a specific Set in the Set List.  # noqa: E501

        Get details about a specific Set in the Set List.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_setlists_sets_read(user_token, list_id, set_num, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str user_token: user_token (required)
        :param str list_id: list_id (required)
        :param str set_num: set_num (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: SetListSet
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.users_setlists_sets_read_with_http_info(user_token, list_id, set_num, **kwargs)  # noqa: E501

    def users_setlists_sets_read_with_http_info(self, user_token, list_id, set_num, **kwargs):  # noqa: E501
        """Get details about a specific Set in the Set List.  # noqa: E501

        Get details about a specific Set in the Set List.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_setlists_sets_read_with_http_info(user_token, list_id, set_num, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str user_token: user_token (required)
        :param str list_id: list_id (required)
        :param str set_num: set_num (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(SetListSet, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['user_token', 'list_id', 'set_num']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_setlists_sets_read" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'user_token' is set
        if ('user_token' not in local_var_params or
                local_var_params['user_token'] is None):
            raise ApiValueError("Missing the required parameter `user_token` when calling `users_setlists_sets_read`")  # noqa: E501
        # verify the required parameter 'list_id' is set
        if ('list_id' not in local_var_params or
                local_var_params['list_id'] is None):
            raise ApiValueError("Missing the required parameter `list_id` when calling `users_setlists_sets_read`")  # noqa: E501
        # verify the required parameter 'set_num' is set
        if ('set_num' not in local_var_params or
                local_var_params['set_num'] is None):
            raise ApiValueError("Missing the required parameter `set_num` when calling `users_setlists_sets_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_token' in local_var_params:
            path_params['user_token'] = local_var_params['user_token']  # noqa: E501
        if 'list_id' in local_var_params:
            path_params['list_id'] = local_var_params['list_id']  # noqa: E501
        if 'set_num' in local_var_params:
            path_params['set_num'] = local_var_params['set_num']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/users/{user_token}/setlists/{list_id}/sets/{set_num}/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SetListSet',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_setlists_sets_update(self, user_token, list_id, set_num, **kwargs):  # noqa: E501
        """Replace an existing Set's details in the Set List.  # noqa: E501

        Replace an existing Set's details in the Set List.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_setlists_sets_update(user_token, list_id, set_num, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str user_token: user_token (required)
        :param str list_id: list_id (required)
        :param str set_num: set_num (required)
        :param str quantity: quantity
        :param str include_spares: include_spares
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.users_setlists_sets_update_with_http_info(user_token, list_id, set_num, **kwargs)  # noqa: E501

    def users_setlists_sets_update_with_http_info(self, user_token, list_id, set_num, **kwargs):  # noqa: E501
        """Replace an existing Set's details in the Set List.  # noqa: E501

        Replace an existing Set's details in the Set List.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_setlists_sets_update_with_http_info(user_token, list_id, set_num, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str user_token: user_token (required)
        :param str list_id: list_id (required)
        :param str set_num: set_num (required)
        :param str quantity: quantity
        :param str include_spares: include_spares
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['user_token', 'list_id', 'set_num', 'quantity', 'include_spares']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_setlists_sets_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'user_token' is set
        if ('user_token' not in local_var_params or
                local_var_params['user_token'] is None):
            raise ApiValueError("Missing the required parameter `user_token` when calling `users_setlists_sets_update`")  # noqa: E501
        # verify the required parameter 'list_id' is set
        if ('list_id' not in local_var_params or
                local_var_params['list_id'] is None):
            raise ApiValueError("Missing the required parameter `list_id` when calling `users_setlists_sets_update`")  # noqa: E501
        # verify the required parameter 'set_num' is set
        if ('set_num' not in local_var_params or
                local_var_params['set_num'] is None):
            raise ApiValueError("Missing the required parameter `set_num` when calling `users_setlists_sets_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_token' in local_var_params:
            path_params['user_token'] = local_var_params['user_token']  # noqa: E501
        if 'list_id' in local_var_params:
            path_params['list_id'] = local_var_params['list_id']  # noqa: E501
        if 'set_num' in local_var_params:
            path_params['set_num'] = local_var_params['set_num']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'quantity' in local_var_params:
            form_params.append(('quantity', local_var_params['quantity']))  # noqa: E501
        if 'include_spares' in local_var_params:
            form_params.append(('include_spares', local_var_params['include_spares']))  # noqa: E501

        body_params = None
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/x-www-form-urlencoded'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/users/{user_token}/setlists/{list_id}/sets/{set_num}/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_setlists_update(self, user_token, list_id, name, **kwargs):  # noqa: E501
        """Replace an existing Set List's details.  # noqa: E501

        Replace an existing Set List's details.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_setlists_update(user_token, list_id, name, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str user_token: user_token (required)
        :param str list_id: list_id (required)
        :param str name: name (required)
        :param str is_buildable: is_buildable
        :param str num_sets: num_sets
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.users_setlists_update_with_http_info(user_token, list_id, name, **kwargs)  # noqa: E501

    def users_setlists_update_with_http_info(self, user_token, list_id, name, **kwargs):  # noqa: E501
        """Replace an existing Set List's details.  # noqa: E501

        Replace an existing Set List's details.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_setlists_update_with_http_info(user_token, list_id, name, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str user_token: user_token (required)
        :param str list_id: list_id (required)
        :param str name: name (required)
        :param str is_buildable: is_buildable
        :param str num_sets: num_sets
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['user_token', 'list_id', 'name', 'is_buildable', 'num_sets']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_setlists_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'user_token' is set
        if ('user_token' not in local_var_params or
                local_var_params['user_token'] is None):
            raise ApiValueError("Missing the required parameter `user_token` when calling `users_setlists_update`")  # noqa: E501
        # verify the required parameter 'list_id' is set
        if ('list_id' not in local_var_params or
                local_var_params['list_id'] is None):
            raise ApiValueError("Missing the required parameter `list_id` when calling `users_setlists_update`")  # noqa: E501
        # verify the required parameter 'name' is set
        if ('name' not in local_var_params or
                local_var_params['name'] is None):
            raise ApiValueError("Missing the required parameter `name` when calling `users_setlists_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_token' in local_var_params:
            path_params['user_token'] = local_var_params['user_token']  # noqa: E501
        if 'list_id' in local_var_params:
            path_params['list_id'] = local_var_params['list_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'is_buildable' in local_var_params:
            form_params.append(('is_buildable', local_var_params['is_buildable']))  # noqa: E501
        if 'name' in local_var_params:
            form_params.append(('name', local_var_params['name']))  # noqa: E501
        if 'num_sets' in local_var_params:
            form_params.append(('num_sets', local_var_params['num_sets']))  # noqa: E501

        body_params = None
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/x-www-form-urlencoded'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/users/{user_token}/setlists/{list_id}/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_sets_create(self, user_token, set_num, **kwargs):  # noqa: E501
        """Add one or more Sets to the user's LEGO collection. Existing Sets are unaffected.  # noqa: E501

        Add one or more Sets to the user's LEGO collection. Existing Sets are unaffected.  ### Set List logic The Set List used when adding sets is chosen in the following order: 1. If no Set Lists exist, one will be created and used 2. User's configured default Set List for Imports 3. The first Set List alphabetically  ### Single Set When adding a single Set, returns the successfully created Set (status 201) or details for why the Set could not be added. ### Multiple Sets To add multiple Sets, POST a JSON list of them (using a Content-Type header of 'application/json'). e.g: `[{\"set_num\":\"8043-1\", \"quantity\": 1}, {\"set_num\":\"8110-1\", \"quantity\": 2, \"include_spares\": \"False\"}]` Returns a list of successfully added Sets. If the Set already exists or is unrecognised, it will be skipped.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_sets_create(user_token, set_num, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str user_token: user_token (required)
        :param str set_num: set_num (required)
        :param str quantity: quantity
        :param str include_spares: include_spares
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: SetListSet
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.users_sets_create_with_http_info(user_token, set_num, **kwargs)  # noqa: E501

    def users_sets_create_with_http_info(self, user_token, set_num, **kwargs):  # noqa: E501
        """Add one or more Sets to the user's LEGO collection. Existing Sets are unaffected.  # noqa: E501

        Add one or more Sets to the user's LEGO collection. Existing Sets are unaffected.  ### Set List logic The Set List used when adding sets is chosen in the following order: 1. If no Set Lists exist, one will be created and used 2. User's configured default Set List for Imports 3. The first Set List alphabetically  ### Single Set When adding a single Set, returns the successfully created Set (status 201) or details for why the Set could not be added. ### Multiple Sets To add multiple Sets, POST a JSON list of them (using a Content-Type header of 'application/json'). e.g: `[{\"set_num\":\"8043-1\", \"quantity\": 1}, {\"set_num\":\"8110-1\", \"quantity\": 2, \"include_spares\": \"False\"}]` Returns a list of successfully added Sets. If the Set already exists or is unrecognised, it will be skipped.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_sets_create_with_http_info(user_token, set_num, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str user_token: user_token (required)
        :param str set_num: set_num (required)
        :param str quantity: quantity
        :param str include_spares: include_spares
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(SetListSet, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['user_token', 'set_num', 'quantity', 'include_spares']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_sets_create" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'user_token' is set
        if ('user_token' not in local_var_params or
                local_var_params['user_token'] is None):
            raise ApiValueError("Missing the required parameter `user_token` when calling `users_sets_create`")  # noqa: E501
        # verify the required parameter 'set_num' is set
        if ('set_num' not in local_var_params or
                local_var_params['set_num'] is None):
            raise ApiValueError("Missing the required parameter `set_num` when calling `users_sets_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_token' in local_var_params:
            path_params['user_token'] = local_var_params['user_token']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'set_num' in local_var_params:
            form_params.append(('set_num', local_var_params['set_num']))  # noqa: E501
        if 'quantity' in local_var_params:
            form_params.append(('quantity', local_var_params['quantity']))  # noqa: E501
        if 'include_spares' in local_var_params:
            form_params.append(('include_spares', local_var_params['include_spares']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/x-www-form-urlencoded'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/users/{user_token}/sets/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SetListSet',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_sets_delete(self, user_token, set_num, **kwargs):  # noqa: E501
        """Delete the Set from all the user's Set Lists.  # noqa: E501

        Delete the Set from all the user's Set Lists.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_sets_delete(user_token, set_num, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str user_token: user_token (required)
        :param str set_num: set_num (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.users_sets_delete_with_http_info(user_token, set_num, **kwargs)  # noqa: E501

    def users_sets_delete_with_http_info(self, user_token, set_num, **kwargs):  # noqa: E501
        """Delete the Set from all the user's Set Lists.  # noqa: E501

        Delete the Set from all the user's Set Lists.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_sets_delete_with_http_info(user_token, set_num, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str user_token: user_token (required)
        :param str set_num: set_num (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['user_token', 'set_num']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_sets_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'user_token' is set
        if ('user_token' not in local_var_params or
                local_var_params['user_token'] is None):
            raise ApiValueError("Missing the required parameter `user_token` when calling `users_sets_delete`")  # noqa: E501
        # verify the required parameter 'set_num' is set
        if ('set_num' not in local_var_params or
                local_var_params['set_num'] is None):
            raise ApiValueError("Missing the required parameter `set_num` when calling `users_sets_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_token' in local_var_params:
            path_params['user_token'] = local_var_params['user_token']  # noqa: E501
        if 'set_num' in local_var_params:
            path_params['set_num'] = local_var_params['set_num']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/users/{user_token}/sets/{set_num}/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_sets_list(self, user_token, **kwargs):  # noqa: E501
        """Get a list of all the Sets in the user's LEGO collection.  # noqa: E501

        Get a list of all the Sets in the user's LEGO collection.  ### Set List logic Sets appearing in multiple Set Lists will be listed multiple times.  Optionally, filter by one or more of the below query parameters.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_sets_list(user_token, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str user_token: user_token (required)
        :param str page: page
        :param str page_size: page_size
        :param str set_num: set_num
        :param str theme_id: theme_id
        :param str min_year: min_year
        :param str max_year: max_year
        :param str min_parts: min_parts
        :param str max_parts: max_parts
        :param str ordering: ordering
        :param str search: search
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ArrayOfSetListSets
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.users_sets_list_with_http_info(user_token, **kwargs)  # noqa: E501

    def users_sets_list_with_http_info(self, user_token, **kwargs):  # noqa: E501
        """Get a list of all the Sets in the user's LEGO collection.  # noqa: E501

        Get a list of all the Sets in the user's LEGO collection.  ### Set List logic Sets appearing in multiple Set Lists will be listed multiple times.  Optionally, filter by one or more of the below query parameters.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_sets_list_with_http_info(user_token, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str user_token: user_token (required)
        :param str page: page
        :param str page_size: page_size
        :param str set_num: set_num
        :param str theme_id: theme_id
        :param str min_year: min_year
        :param str max_year: max_year
        :param str min_parts: min_parts
        :param str max_parts: max_parts
        :param str ordering: ordering
        :param str search: search
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ArrayOfSetListSets, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['user_token', 'page', 'page_size', 'set_num', 'theme_id', 'min_year', 'max_year', 'min_parts', 'max_parts', 'ordering', 'search']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_sets_list" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'user_token' is set
        if ('user_token' not in local_var_params or
                local_var_params['user_token'] is None):
            raise ApiValueError("Missing the required parameter `user_token` when calling `users_sets_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_token' in local_var_params:
            path_params['user_token'] = local_var_params['user_token']  # noqa: E501

        query_params = []
        if 'page' in local_var_params:
            query_params.append(('page', local_var_params['page']))  # noqa: E501
        if 'page_size' in local_var_params:
            query_params.append(('page_size', local_var_params['page_size']))  # noqa: E501
        if 'set_num' in local_var_params:
            query_params.append(('set_num', local_var_params['set_num']))  # noqa: E501
        if 'theme_id' in local_var_params:
            query_params.append(('theme_id', local_var_params['theme_id']))  # noqa: E501
        if 'min_year' in local_var_params:
            query_params.append(('min_year', local_var_params['min_year']))  # noqa: E501
        if 'max_year' in local_var_params:
            query_params.append(('max_year', local_var_params['max_year']))  # noqa: E501
        if 'min_parts' in local_var_params:
            query_params.append(('min_parts', local_var_params['min_parts']))  # noqa: E501
        if 'max_parts' in local_var_params:
            query_params.append(('max_parts', local_var_params['max_parts']))  # noqa: E501
        if 'ordering' in local_var_params:
            query_params.append(('ordering', local_var_params['ordering']))  # noqa: E501
        if 'search' in local_var_params:
            query_params.append(('search', local_var_params['search']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/users/{user_token}/sets/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ArrayOfSetListSets',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_sets_read(self, user_token, set_num, **kwargs):  # noqa: E501
        """Get details about a specific Set in the user's LEGO collection.  # noqa: E501

        Get details about a specific Set in the user's LEGO collection.  ### Set List logic Because this merges sets found across all Set Lists the fields list_id and include_spares may not be accurate unless the Set actually only exists in a single Set List.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_sets_read(user_token, set_num, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str user_token: user_token (required)
        :param str set_num: set_num (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: SetListSet
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.users_sets_read_with_http_info(user_token, set_num, **kwargs)  # noqa: E501

    def users_sets_read_with_http_info(self, user_token, set_num, **kwargs):  # noqa: E501
        """Get details about a specific Set in the user's LEGO collection.  # noqa: E501

        Get details about a specific Set in the user's LEGO collection.  ### Set List logic Because this merges sets found across all Set Lists the fields list_id and include_spares may not be accurate unless the Set actually only exists in a single Set List.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_sets_read_with_http_info(user_token, set_num, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str user_token: user_token (required)
        :param str set_num: set_num (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(SetListSet, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['user_token', 'set_num']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_sets_read" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'user_token' is set
        if ('user_token' not in local_var_params or
                local_var_params['user_token'] is None):
            raise ApiValueError("Missing the required parameter `user_token` when calling `users_sets_read`")  # noqa: E501
        # verify the required parameter 'set_num' is set
        if ('set_num' not in local_var_params or
                local_var_params['set_num'] is None):
            raise ApiValueError("Missing the required parameter `set_num` when calling `users_sets_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_token' in local_var_params:
            path_params['user_token'] = local_var_params['user_token']  # noqa: E501
        if 'set_num' in local_var_params:
            path_params['set_num'] = local_var_params['set_num']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/users/{user_token}/sets/{set_num}/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SetListSet',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_sets_sync_create(self, user_token, set_num, **kwargs):  # noqa: E501
        """Synchronise a user's Sets to the POSTed list.  # noqa: E501

        Synchronise a user's Sets to the POSTed list.  ### Set List logic This is used to completely replace the user's Sets with those in the supplied list. It will remove any Sets in Rebrickable that are not found in the supplied list. It will attempt to keep any current Rebrickable Sets in their existing Set Lists, and will add any new Sets found into the Default Set List for Imports in the user's settings. ### Single Set When adding a single Set, returns the successfully created Set (status 201) or details for why the Set could not be added. ### Multiple Sets To add multiple Sets, POST a JSON list of them (using a Content-Type header of 'application/json'). e.g: `[{\"set_num\":\"8043-1\", \"quantity\": 1}, {\"set_num\":\"8110-1\", \"quantity\": 2, \"include_spares\": \"False\"}]` Returns a list of successfully added Sets. If the Set is unrecognised, it will be skipped.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_sets_sync_create(user_token, set_num, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str user_token: user_token (required)
        :param str set_num: set_num (required)
        :param str quantity: quantity
        :param str include_spares: include_spares
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.users_sets_sync_create_with_http_info(user_token, set_num, **kwargs)  # noqa: E501

    def users_sets_sync_create_with_http_info(self, user_token, set_num, **kwargs):  # noqa: E501
        """Synchronise a user's Sets to the POSTed list.  # noqa: E501

        Synchronise a user's Sets to the POSTed list.  ### Set List logic This is used to completely replace the user's Sets with those in the supplied list. It will remove any Sets in Rebrickable that are not found in the supplied list. It will attempt to keep any current Rebrickable Sets in their existing Set Lists, and will add any new Sets found into the Default Set List for Imports in the user's settings. ### Single Set When adding a single Set, returns the successfully created Set (status 201) or details for why the Set could not be added. ### Multiple Sets To add multiple Sets, POST a JSON list of them (using a Content-Type header of 'application/json'). e.g: `[{\"set_num\":\"8043-1\", \"quantity\": 1}, {\"set_num\":\"8110-1\", \"quantity\": 2, \"include_spares\": \"False\"}]` Returns a list of successfully added Sets. If the Set is unrecognised, it will be skipped.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_sets_sync_create_with_http_info(user_token, set_num, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str user_token: user_token (required)
        :param str set_num: set_num (required)
        :param str quantity: quantity
        :param str include_spares: include_spares
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['user_token', 'set_num', 'quantity', 'include_spares']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_sets_sync_create" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'user_token' is set
        if ('user_token' not in local_var_params or
                local_var_params['user_token'] is None):
            raise ApiValueError("Missing the required parameter `user_token` when calling `users_sets_sync_create`")  # noqa: E501
        # verify the required parameter 'set_num' is set
        if ('set_num' not in local_var_params or
                local_var_params['set_num'] is None):
            raise ApiValueError("Missing the required parameter `set_num` when calling `users_sets_sync_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_token' in local_var_params:
            path_params['user_token'] = local_var_params['user_token']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'quantity' in local_var_params:
            form_params.append(('quantity', local_var_params['quantity']))  # noqa: E501
        if 'include_spares' in local_var_params:
            form_params.append(('include_spares', local_var_params['include_spares']))  # noqa: E501
        if 'set_num' in local_var_params:
            form_params.append(('set_num', local_var_params['set_num']))  # noqa: E501

        body_params = None
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/x-www-form-urlencoded'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/users/{user_token}/sets/sync/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_sets_update(self, user_token, set_num, **kwargs):  # noqa: E501
        """Update an existing Set's quantity in all Set Lists. This PUT call is different to others in that it will create  # noqa: E501

        Update an existing Set's quantity in all Set Lists. This PUT call is different to others in that it will create the Set if it doesn't already exist, and it will delete the Set if you pass a quantity of 0.  ### Set List logic * Default Set List = user's configured default import list or the first alphabetically if none exist. * Increasing quantity = add to Set in default Set List if it exists, else add it there * Decreasing quantity = remove from Set in default Set List first, then from remaining lists until done  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_sets_update(user_token, set_num, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str user_token: user_token (required)
        :param str set_num: set_num (required)
        :param str quantity: quantity
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.users_sets_update_with_http_info(user_token, set_num, **kwargs)  # noqa: E501

    def users_sets_update_with_http_info(self, user_token, set_num, **kwargs):  # noqa: E501
        """Update an existing Set's quantity in all Set Lists. This PUT call is different to others in that it will create  # noqa: E501

        Update an existing Set's quantity in all Set Lists. This PUT call is different to others in that it will create the Set if it doesn't already exist, and it will delete the Set if you pass a quantity of 0.  ### Set List logic * Default Set List = user's configured default import list or the first alphabetically if none exist. * Increasing quantity = add to Set in default Set List if it exists, else add it there * Decreasing quantity = remove from Set in default Set List first, then from remaining lists until done  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_sets_update_with_http_info(user_token, set_num, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str user_token: user_token (required)
        :param str set_num: set_num (required)
        :param str quantity: quantity
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['user_token', 'set_num', 'quantity']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_sets_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'user_token' is set
        if ('user_token' not in local_var_params or
                local_var_params['user_token'] is None):
            raise ApiValueError("Missing the required parameter `user_token` when calling `users_sets_update`")  # noqa: E501
        # verify the required parameter 'set_num' is set
        if ('set_num' not in local_var_params or
                local_var_params['set_num'] is None):
            raise ApiValueError("Missing the required parameter `set_num` when calling `users_sets_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_token' in local_var_params:
            path_params['user_token'] = local_var_params['user_token']  # noqa: E501
        if 'set_num' in local_var_params:
            path_params['set_num'] = local_var_params['set_num']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'quantity' in local_var_params:
            form_params.append(('quantity', local_var_params['quantity']))  # noqa: E501

        body_params = None
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/x-www-form-urlencoded'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/users/{user_token}/sets/{set_num}/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_token_create(self, username, password, **kwargs):  # noqa: E501
        """Generate a User Token to be used for authorising user account actions in subsequent calls. Username can be either  # noqa: E501

        Generate a User Token to be used for authorising user account actions in subsequent calls. Username can be either the actual username or the user's email address.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_token_create(username, password, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str username: username (required)
        :param str password: password (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: UsersTokenResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.users_token_create_with_http_info(username, password, **kwargs)  # noqa: E501

    def users_token_create_with_http_info(self, username, password, **kwargs):  # noqa: E501
        """Generate a User Token to be used for authorising user account actions in subsequent calls. Username can be either  # noqa: E501

        Generate a User Token to be used for authorising user account actions in subsequent calls. Username can be either the actual username or the user's email address.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_token_create_with_http_info(username, password, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str username: username (required)
        :param str password: password (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(UsersTokenResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['username', 'password']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_token_create" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'username' is set
        if ('username' not in local_var_params or
                local_var_params['username'] is None):
            raise ApiValueError("Missing the required parameter `username` when calling `users_token_create`")  # noqa: E501
        # verify the required parameter 'password' is set
        if ('password' not in local_var_params or
                local_var_params['password'] is None):
            raise ApiValueError("Missing the required parameter `password` when calling `users_token_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'username' in local_var_params:
            form_params.append(('username', local_var_params['username']))  # noqa: E501
        if 'password' in local_var_params:
            form_params.append(('password', local_var_params['password']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/x-www-form-urlencoded'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/users/_token/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='UsersTokenResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)
