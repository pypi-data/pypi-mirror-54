# coding: utf-8

"""
    Intrinio API

    Welcome to the Intrinio API! Through our Financial Data Marketplace, we offer a wide selection of financial data feed APIs sourced by our own proprietary processes as well as from many data vendors. For a complete API request / response reference please view the [Intrinio API documentation](https://intrinio.com/documentation/api_v2). If you need additional help in using the API, please visit the [Intrinio website](https://intrinio.com) and click on the chat icon in the lower right corner.  # noqa: E501

    OpenAPI spec version: 2.8.4
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from intrinio_sdk.api_client import ApiClient


class CryptoApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def get_crypto_book_asks(self, **kwargs):  # noqa: E501
        """Crypto Book Asks  # noqa: E501

        Returns the entire ask order book for a given Crypto Currency Pair and Crypto Exchange.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_crypto_book_asks(_async=True)
        >>> result = thread.get()

        :param async bool
        :param str pair: Return the order book asks for the given Crypto Currency Pair.
        :param str exchange: Return the order book asks for a Crypto Currency on the given Crypto Exchange.
        :param str currency: Return the order book asks for the given Crypto Currency.
        :return: ApiResponseCryptoBookAsks
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_crypto_book_asks_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_crypto_book_asks_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_crypto_book_asks_with_http_info(self, **kwargs):  # noqa: E501
        """Crypto Book Asks  # noqa: E501

        Returns the entire ask order book for a given Crypto Currency Pair and Crypto Exchange.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_crypto_book_asks_with_http_info(_async=True)
        >>> result = thread.get()

        :param async bool
        :param str pair: Return the order book asks for the given Crypto Currency Pair.
        :param str exchange: Return the order book asks for a Crypto Currency on the given Crypto Exchange.
        :param str currency: Return the order book asks for the given Crypto Currency.
        :return: ApiResponseCryptoBookAsks
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['pair', 'exchange', 'currency']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_crypto_book_asks" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'pair' in params:
            query_params.append(('pair', params['pair']))  # noqa: E501
        if 'exchange' in params:
            query_params.append(('exchange', params['exchange']))  # noqa: E501
        if 'currency' in params:
            query_params.append(('currency', params['currency']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth']  # noqa: E501

        return self.api_client.call_api(
            '/crypto/book/asks', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ApiResponseCryptoBookAsks',  # noqa: E501
            auth_settings=auth_settings,
            _async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_crypto_book_bids(self, **kwargs):  # noqa: E501
        """Crypto Book Bids  # noqa: E501

        Returns the entire bid order book for a given Crypto Currency Pair and Crypto Exchange.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_crypto_book_bids(_async=True)
        >>> result = thread.get()

        :param async bool
        :param str pair: Return the order book bids for the given Crypto Currency Pair.
        :param str exchange: Return the order book bids for a Crypto Currency on the given Crypto Exchange.
        :param str currency: Return the order book bids for the given Crypto Currency.
        :return: ApiResponseCryptoBookBids
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_crypto_book_bids_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_crypto_book_bids_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_crypto_book_bids_with_http_info(self, **kwargs):  # noqa: E501
        """Crypto Book Bids  # noqa: E501

        Returns the entire bid order book for a given Crypto Currency Pair and Crypto Exchange.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_crypto_book_bids_with_http_info(_async=True)
        >>> result = thread.get()

        :param async bool
        :param str pair: Return the order book bids for the given Crypto Currency Pair.
        :param str exchange: Return the order book bids for a Crypto Currency on the given Crypto Exchange.
        :param str currency: Return the order book bids for the given Crypto Currency.
        :return: ApiResponseCryptoBookBids
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['pair', 'exchange', 'currency']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_crypto_book_bids" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'pair' in params:
            query_params.append(('pair', params['pair']))  # noqa: E501
        if 'exchange' in params:
            query_params.append(('exchange', params['exchange']))  # noqa: E501
        if 'currency' in params:
            query_params.append(('currency', params['currency']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth']  # noqa: E501

        return self.api_client.call_api(
            '/crypto/book/bids', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ApiResponseCryptoBookBids',  # noqa: E501
            auth_settings=auth_settings,
            _async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_crypto_book_summary(self, **kwargs):  # noqa: E501
        """Crypto Book Summary  # noqa: E501

        Returns the order book summary (bid/ask prices and size) for a given Crypto Currency Pair and Crypto Exchange.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_crypto_book_summary(_async=True)
        >>> result = thread.get()

        :param async bool
        :param int levels: The number of prices/levels to return on each side. For example, the max of 50 levels will return up to 50 bid prices and 50 ask prices.
        :param str pair: Return the order book summary for the given Crypto Currency Pair.
        :param str exchange: Return the order book summary for a Crypto Currency on the given Crypto Exchange.
        :param str currency: Return the order book summary for the given Crypto Currency.
        :return: ApiResponseCryptoBook
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_crypto_book_summary_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_crypto_book_summary_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_crypto_book_summary_with_http_info(self, **kwargs):  # noqa: E501
        """Crypto Book Summary  # noqa: E501

        Returns the order book summary (bid/ask prices and size) for a given Crypto Currency Pair and Crypto Exchange.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_crypto_book_summary_with_http_info(_async=True)
        >>> result = thread.get()

        :param async bool
        :param int levels: The number of prices/levels to return on each side. For example, the max of 50 levels will return up to 50 bid prices and 50 ask prices.
        :param str pair: Return the order book summary for the given Crypto Currency Pair.
        :param str exchange: Return the order book summary for a Crypto Currency on the given Crypto Exchange.
        :param str currency: Return the order book summary for the given Crypto Currency.
        :return: ApiResponseCryptoBook
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['levels', 'pair', 'exchange', 'currency']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_crypto_book_summary" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'levels' in params:
            query_params.append(('levels', params['levels']))  # noqa: E501
        if 'pair' in params:
            query_params.append(('pair', params['pair']))  # noqa: E501
        if 'exchange' in params:
            query_params.append(('exchange', params['exchange']))  # noqa: E501
        if 'currency' in params:
            query_params.append(('currency', params['currency']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth']  # noqa: E501

        return self.api_client.call_api(
            '/crypto/book', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ApiResponseCryptoBook',  # noqa: E501
            auth_settings=auth_settings,
            _async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_crypto_currencies(self, **kwargs):  # noqa: E501
        """Crypto Currencies  # noqa: E501

        Returns a list of Crypto Currencies for which prices are available.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_crypto_currencies(_async=True)
        >>> result = thread.get()

        :param async bool
        :param str exchange: Returns Crypto Currencies traded on the given Crypto Exchange.
        :return: ApiResponseCryptoCurrencies
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_crypto_currencies_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_crypto_currencies_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_crypto_currencies_with_http_info(self, **kwargs):  # noqa: E501
        """Crypto Currencies  # noqa: E501

        Returns a list of Crypto Currencies for which prices are available.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_crypto_currencies_with_http_info(_async=True)
        >>> result = thread.get()

        :param async bool
        :param str exchange: Returns Crypto Currencies traded on the given Crypto Exchange.
        :return: ApiResponseCryptoCurrencies
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['exchange']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_crypto_currencies" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'exchange' in params:
            query_params.append(('exchange', params['exchange']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth']  # noqa: E501

        return self.api_client.call_api(
            '/crypto/currencies', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ApiResponseCryptoCurrencies',  # noqa: E501
            auth_settings=auth_settings,
            _async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_crypto_exchanges(self, **kwargs):  # noqa: E501
        """Crypto Exchanges  # noqa: E501

        Returns a list of Crypto Exchanges for which prices are available.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_crypto_exchanges(_async=True)
        >>> result = thread.get()

        :param async bool
        :param str pair: Filter exchanges based on whether or not prices are available on the exchange for the crypto currency pair.
        :return: ApiResponseCryptoExchanges
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_crypto_exchanges_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_crypto_exchanges_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_crypto_exchanges_with_http_info(self, **kwargs):  # noqa: E501
        """Crypto Exchanges  # noqa: E501

        Returns a list of Crypto Exchanges for which prices are available.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_crypto_exchanges_with_http_info(_async=True)
        >>> result = thread.get()

        :param async bool
        :param str pair: Filter exchanges based on whether or not prices are available on the exchange for the crypto currency pair.
        :return: ApiResponseCryptoExchanges
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['pair']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_crypto_exchanges" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'pair' in params:
            query_params.append(('pair', params['pair']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth']  # noqa: E501

        return self.api_client.call_api(
            '/crypto/exchanges', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ApiResponseCryptoExchanges',  # noqa: E501
            auth_settings=auth_settings,
            _async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_crypto_pairs(self, **kwargs):  # noqa: E501
        """Crypto Pairs  # noqa: E501

        Returns a list of Crypto Currency Pairs for which data is available.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_crypto_pairs(_async=True)
        >>> result = thread.get()

        :param async bool
        :param str exchange: Return pairs traded on the given Crypto Exchange.
        :param str currency: Return pairs with one side being the given Crypto Currency.
        :param int page_size: An integer greater than or equal to 1 for specifying the number of results on each page.
        :param str next_page: Gets the next page of data from a previous API call
        :return: ApiResponseCryptoPairs
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_crypto_pairs_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_crypto_pairs_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_crypto_pairs_with_http_info(self, **kwargs):  # noqa: E501
        """Crypto Pairs  # noqa: E501

        Returns a list of Crypto Currency Pairs for which data is available.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_crypto_pairs_with_http_info(_async=True)
        >>> result = thread.get()

        :param async bool
        :param str exchange: Return pairs traded on the given Crypto Exchange.
        :param str currency: Return pairs with one side being the given Crypto Currency.
        :param int page_size: An integer greater than or equal to 1 for specifying the number of results on each page.
        :param str next_page: Gets the next page of data from a previous API call
        :return: ApiResponseCryptoPairs
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['exchange', 'currency', 'page_size', 'next_page']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_crypto_pairs" % key
                )
            params[key] = val
        del params['kwargs']

        if 'page_size' in params and params['page_size'] > 10000:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `get_crypto_pairs`, must be a value less than or equal to `10000`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'exchange' in params:
            query_params.append(('exchange', params['exchange']))  # noqa: E501
        if 'currency' in params:
            query_params.append(('currency', params['currency']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'next_page' in params:
            query_params.append(('next_page', params['next_page']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth']  # noqa: E501

        return self.api_client.call_api(
            '/crypto/pairs', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ApiResponseCryptoPairs',  # noqa: E501
            auth_settings=auth_settings,
            _async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_crypto_price_technicals_adi(self, **kwargs):  # noqa: E501
        """Accumulation/Distribution Index  # noqa: E501

        Returns the Accumulation/Distribution Index values of Crypto Currency Prices for a Crypto Currency Pair  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_crypto_price_technicals_adi(_async=True)
        >>> result = thread.get()

        :param async bool
        :param str pair: Return technicals for the given Crypto Currency Pair.
        :param str exchange: Return technicals for a Crypto Currency on the given Crypto Exchange.
        :param str currency: Return technicals for the given Crypto Currency.
        :param str timeframe: The time interval for the prices when calculating technicals.
        :param str timezone: Return technical date/times in this timezone, also interpret start/end date/time parameters in this timezone.
        :param date start_date: Return technicals on or after this date.
        :param str start_time: Return technicals at or after this time (24-hour).
        :param date end_date: Return technicals on or before this date.
        :param str end_time: Return technicals at or before this time (24-hour).
        :param int page_size: An integer greater than or equal to 1 for specifying the number of results on each page.
        :param str next_page: Gets the next page of data from a previous API call
        :return: ApiResponseCryptoAccumulationDistributionIndex
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_crypto_price_technicals_adi_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_crypto_price_technicals_adi_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_crypto_price_technicals_adi_with_http_info(self, **kwargs):  # noqa: E501
        """Accumulation/Distribution Index  # noqa: E501

        Returns the Accumulation/Distribution Index values of Crypto Currency Prices for a Crypto Currency Pair  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_crypto_price_technicals_adi_with_http_info(_async=True)
        >>> result = thread.get()

        :param async bool
        :param str pair: Return technicals for the given Crypto Currency Pair.
        :param str exchange: Return technicals for a Crypto Currency on the given Crypto Exchange.
        :param str currency: Return technicals for the given Crypto Currency.
        :param str timeframe: The time interval for the prices when calculating technicals.
        :param str timezone: Return technical date/times in this timezone, also interpret start/end date/time parameters in this timezone.
        :param date start_date: Return technicals on or after this date.
        :param str start_time: Return technicals at or after this time (24-hour).
        :param date end_date: Return technicals on or before this date.
        :param str end_time: Return technicals at or before this time (24-hour).
        :param int page_size: An integer greater than or equal to 1 for specifying the number of results on each page.
        :param str next_page: Gets the next page of data from a previous API call
        :return: ApiResponseCryptoAccumulationDistributionIndex
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['pair', 'exchange', 'currency', 'timeframe', 'timezone', 'start_date', 'start_time', 'end_date', 'end_time', 'page_size', 'next_page']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_crypto_price_technicals_adi" % key
                )
            params[key] = val
        del params['kwargs']

        if 'page_size' in params and params['page_size'] > 10000:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `get_crypto_price_technicals_adi`, must be a value less than or equal to `10000`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'pair' in params:
            query_params.append(('pair', params['pair']))  # noqa: E501
        if 'exchange' in params:
            query_params.append(('exchange', params['exchange']))  # noqa: E501
        if 'currency' in params:
            query_params.append(('currency', params['currency']))  # noqa: E501
        if 'timeframe' in params:
            query_params.append(('timeframe', params['timeframe']))  # noqa: E501
        if 'timezone' in params:
            query_params.append(('timezone', params['timezone']))  # noqa: E501
        if 'start_date' in params:
            query_params.append(('start_date', params['start_date']))  # noqa: E501
        if 'start_time' in params:
            query_params.append(('start_time', params['start_time']))  # noqa: E501
        if 'end_date' in params:
            query_params.append(('end_date', params['end_date']))  # noqa: E501
        if 'end_time' in params:
            query_params.append(('end_time', params['end_time']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'next_page' in params:
            query_params.append(('next_page', params['next_page']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth']  # noqa: E501

        return self.api_client.call_api(
            '/crypto/prices/technicals/adi', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ApiResponseCryptoAccumulationDistributionIndex',  # noqa: E501
            auth_settings=auth_settings,
            _async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_crypto_price_technicals_adtv(self, **kwargs):  # noqa: E501
        """Average Daily Trading Volume  # noqa: E501

        Returns the Average Daily Trading Volume values of Crypto Currency Prices for a Crypto Currency Pair  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_crypto_price_technicals_adtv(_async=True)
        >>> result = thread.get()

        :param async bool
        :param str pair: Return technicals for the given Crypto Currency Pair.
        :param str exchange: Return technicals for a Crypto Currency on the given Crypto Exchange.
        :param str currency: Return technicals for the given Crypto Currency.
        :param int period: The number of observations, per period, to calculate Average Daily Trading Volume.
        :param str timeframe: The time interval for the prices when calculating technicals.
        :param str timezone: Return technical date/times in this timezone, also interpret start/end date/time parameters in this timezone.
        :param date start_date: Return technicals on or after this date.
        :param str start_time: Return technicals at or after this time (24-hour).
        :param date end_date: Return technicals on or before this date.
        :param str end_time: Return technicals at or before this time (24-hour).
        :param int page_size: An integer greater than or equal to 1 for specifying the number of results on each page.
        :param str next_page: Gets the next page of data from a previous API call
        :return: ApiResponseCryptoAverageDailyTradingVolume
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_crypto_price_technicals_adtv_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_crypto_price_technicals_adtv_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_crypto_price_technicals_adtv_with_http_info(self, **kwargs):  # noqa: E501
        """Average Daily Trading Volume  # noqa: E501

        Returns the Average Daily Trading Volume values of Crypto Currency Prices for a Crypto Currency Pair  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_crypto_price_technicals_adtv_with_http_info(_async=True)
        >>> result = thread.get()

        :param async bool
        :param str pair: Return technicals for the given Crypto Currency Pair.
        :param str exchange: Return technicals for a Crypto Currency on the given Crypto Exchange.
        :param str currency: Return technicals for the given Crypto Currency.
        :param int period: The number of observations, per period, to calculate Average Daily Trading Volume.
        :param str timeframe: The time interval for the prices when calculating technicals.
        :param str timezone: Return technical date/times in this timezone, also interpret start/end date/time parameters in this timezone.
        :param date start_date: Return technicals on or after this date.
        :param str start_time: Return technicals at or after this time (24-hour).
        :param date end_date: Return technicals on or before this date.
        :param str end_time: Return technicals at or before this time (24-hour).
        :param int page_size: An integer greater than or equal to 1 for specifying the number of results on each page.
        :param str next_page: Gets the next page of data from a previous API call
        :return: ApiResponseCryptoAverageDailyTradingVolume
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['pair', 'exchange', 'currency', 'period', 'timeframe', 'timezone', 'start_date', 'start_time', 'end_date', 'end_time', 'page_size', 'next_page']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_crypto_price_technicals_adtv" % key
                )
            params[key] = val
        del params['kwargs']

        if 'period' in params and params['period'] < 5:  # noqa: E501
            raise ValueError("Invalid value for parameter `period` when calling `get_crypto_price_technicals_adtv`, must be a value greater than or equal to `5`")  # noqa: E501
        if 'page_size' in params and params['page_size'] > 10000:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `get_crypto_price_technicals_adtv`, must be a value less than or equal to `10000`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'pair' in params:
            query_params.append(('pair', params['pair']))  # noqa: E501
        if 'exchange' in params:
            query_params.append(('exchange', params['exchange']))  # noqa: E501
        if 'currency' in params:
            query_params.append(('currency', params['currency']))  # noqa: E501
        if 'period' in params:
            query_params.append(('period', params['period']))  # noqa: E501
        if 'timeframe' in params:
            query_params.append(('timeframe', params['timeframe']))  # noqa: E501
        if 'timezone' in params:
            query_params.append(('timezone', params['timezone']))  # noqa: E501
        if 'start_date' in params:
            query_params.append(('start_date', params['start_date']))  # noqa: E501
        if 'start_time' in params:
            query_params.append(('start_time', params['start_time']))  # noqa: E501
        if 'end_date' in params:
            query_params.append(('end_date', params['end_date']))  # noqa: E501
        if 'end_time' in params:
            query_params.append(('end_time', params['end_time']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'next_page' in params:
            query_params.append(('next_page', params['next_page']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth']  # noqa: E501

        return self.api_client.call_api(
            '/crypto/prices/technicals/adtv', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ApiResponseCryptoAverageDailyTradingVolume',  # noqa: E501
            auth_settings=auth_settings,
            _async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_crypto_price_technicals_adx(self, **kwargs):  # noqa: E501
        """Average Directional Index  # noqa: E501

        Returns the Average Directional Index values of Crypto Currency Prices for a Crypto Currency Pair  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_crypto_price_technicals_adx(_async=True)
        >>> result = thread.get()

        :param async bool
        :param str pair: Return technicals for the given Crypto Currency Pair.
        :param str exchange: Return technicals for a Crypto Currency on the given Crypto Exchange.
        :param str currency: Return technicals for the given Crypto Currency.
        :param int period: The number of observations, per period, to calculate Average Directional Index.
        :param str timeframe: The time interval for the prices when calculating technicals.
        :param str timezone: Return technical date/times in this timezone, also interpret start/end date/time parameters in this timezone.
        :param date start_date: Return technicals on or after this date.
        :param str start_time: Return technicals at or after this time (24-hour).
        :param date end_date: Return technicals on or before this date.
        :param str end_time: Return technicals at or before this time (24-hour).
        :param int page_size: An integer greater than or equal to 1 for specifying the number of results on each page.
        :param str next_page: Gets the next page of data from a previous API call
        :return: ApiResponseCryptoAverageDirectionalIndex
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_crypto_price_technicals_adx_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_crypto_price_technicals_adx_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_crypto_price_technicals_adx_with_http_info(self, **kwargs):  # noqa: E501
        """Average Directional Index  # noqa: E501

        Returns the Average Directional Index values of Crypto Currency Prices for a Crypto Currency Pair  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_crypto_price_technicals_adx_with_http_info(_async=True)
        >>> result = thread.get()

        :param async bool
        :param str pair: Return technicals for the given Crypto Currency Pair.
        :param str exchange: Return technicals for a Crypto Currency on the given Crypto Exchange.
        :param str currency: Return technicals for the given Crypto Currency.
        :param int period: The number of observations, per period, to calculate Average Directional Index.
        :param str timeframe: The time interval for the prices when calculating technicals.
        :param str timezone: Return technical date/times in this timezone, also interpret start/end date/time parameters in this timezone.
        :param date start_date: Return technicals on or after this date.
        :param str start_time: Return technicals at or after this time (24-hour).
        :param date end_date: Return technicals on or before this date.
        :param str end_time: Return technicals at or before this time (24-hour).
        :param int page_size: An integer greater than or equal to 1 for specifying the number of results on each page.
        :param str next_page: Gets the next page of data from a previous API call
        :return: ApiResponseCryptoAverageDirectionalIndex
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['pair', 'exchange', 'currency', 'period', 'timeframe', 'timezone', 'start_date', 'start_time', 'end_date', 'end_time', 'page_size', 'next_page']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_crypto_price_technicals_adx" % key
                )
            params[key] = val
        del params['kwargs']

        if 'period' in params and params['period'] < 5:  # noqa: E501
            raise ValueError("Invalid value for parameter `period` when calling `get_crypto_price_technicals_adx`, must be a value greater than or equal to `5`")  # noqa: E501
        if 'page_size' in params and params['page_size'] > 10000:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `get_crypto_price_technicals_adx`, must be a value less than or equal to `10000`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'pair' in params:
            query_params.append(('pair', params['pair']))  # noqa: E501
        if 'exchange' in params:
            query_params.append(('exchange', params['exchange']))  # noqa: E501
        if 'currency' in params:
            query_params.append(('currency', params['currency']))  # noqa: E501
        if 'period' in params:
            query_params.append(('period', params['period']))  # noqa: E501
        if 'timeframe' in params:
            query_params.append(('timeframe', params['timeframe']))  # noqa: E501
        if 'timezone' in params:
            query_params.append(('timezone', params['timezone']))  # noqa: E501
        if 'start_date' in params:
            query_params.append(('start_date', params['start_date']))  # noqa: E501
        if 'start_time' in params:
            query_params.append(('start_time', params['start_time']))  # noqa: E501
        if 'end_date' in params:
            query_params.append(('end_date', params['end_date']))  # noqa: E501
        if 'end_time' in params:
            query_params.append(('end_time', params['end_time']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'next_page' in params:
            query_params.append(('next_page', params['next_page']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth']  # noqa: E501

        return self.api_client.call_api(
            '/crypto/prices/technicals/adx', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ApiResponseCryptoAverageDirectionalIndex',  # noqa: E501
            auth_settings=auth_settings,
            _async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_crypto_price_technicals_ao(self, **kwargs):  # noqa: E501
        """Awesome Oscillator  # noqa: E501

        Returns the Awesome Oscillator values of Crypto Currency Prices for a Crypto Currency Pair  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_crypto_price_technicals_ao(_async=True)
        >>> result = thread.get()

        :param async bool
        :param str pair: Return technicals for the given Crypto Currency Pair.
        :param str exchange: Return technicals for a Crypto Currency on the given Crypto Exchange.
        :param str currency: Return technicals for the given Crypto Currency.
        :param int short_period: The number of observations, per period, to calculate short period Simple Moving Average of the Awesome Oscillator.
        :param int long_period: The number of observations, per period, to calculate long period Simple Moving Average of the Awesome Oscillator.
        :param str timeframe: The time interval for the prices when calculating technicals.
        :param str timezone: Return technical date/times in this timezone, also interpret start/end date/time parameters in this timezone.
        :param date start_date: Return technicals on or after this date.
        :param str start_time: Return technicals at or after this time (24-hour).
        :param date end_date: Return technicals on or before this date.
        :param str end_time: Return technicals at or before this time (24-hour).
        :param int page_size: An integer greater than or equal to 1 for specifying the number of results on each page.
        :param str next_page: Gets the next page of data from a previous API call
        :return: ApiResponseCryptoAwesomeOscillator
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_crypto_price_technicals_ao_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_crypto_price_technicals_ao_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_crypto_price_technicals_ao_with_http_info(self, **kwargs):  # noqa: E501
        """Awesome Oscillator  # noqa: E501

        Returns the Awesome Oscillator values of Crypto Currency Prices for a Crypto Currency Pair  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_crypto_price_technicals_ao_with_http_info(_async=True)
        >>> result = thread.get()

        :param async bool
        :param str pair: Return technicals for the given Crypto Currency Pair.
        :param str exchange: Return technicals for a Crypto Currency on the given Crypto Exchange.
        :param str currency: Return technicals for the given Crypto Currency.
        :param int short_period: The number of observations, per period, to calculate short period Simple Moving Average of the Awesome Oscillator.
        :param int long_period: The number of observations, per period, to calculate long period Simple Moving Average of the Awesome Oscillator.
        :param str timeframe: The time interval for the prices when calculating technicals.
        :param str timezone: Return technical date/times in this timezone, also interpret start/end date/time parameters in this timezone.
        :param date start_date: Return technicals on or after this date.
        :param str start_time: Return technicals at or after this time (24-hour).
        :param date end_date: Return technicals on or before this date.
        :param str end_time: Return technicals at or before this time (24-hour).
        :param int page_size: An integer greater than or equal to 1 for specifying the number of results on each page.
        :param str next_page: Gets the next page of data from a previous API call
        :return: ApiResponseCryptoAwesomeOscillator
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['pair', 'exchange', 'currency', 'short_period', 'long_period', 'timeframe', 'timezone', 'start_date', 'start_time', 'end_date', 'end_time', 'page_size', 'next_page']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_crypto_price_technicals_ao" % key
                )
            params[key] = val
        del params['kwargs']

        if 'long_period' in params and params['long_period'] < 5:  # noqa: E501
            raise ValueError("Invalid value for parameter `long_period` when calling `get_crypto_price_technicals_ao`, must be a value greater than or equal to `5`")  # noqa: E501
        if 'page_size' in params and params['page_size'] > 10000:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `get_crypto_price_technicals_ao`, must be a value less than or equal to `10000`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'pair' in params:
            query_params.append(('pair', params['pair']))  # noqa: E501
        if 'exchange' in params:
            query_params.append(('exchange', params['exchange']))  # noqa: E501
        if 'currency' in params:
            query_params.append(('currency', params['currency']))  # noqa: E501
        if 'short_period' in params:
            query_params.append(('short_period', params['short_period']))  # noqa: E501
        if 'long_period' in params:
            query_params.append(('long_period', params['long_period']))  # noqa: E501
        if 'timeframe' in params:
            query_params.append(('timeframe', params['timeframe']))  # noqa: E501
        if 'timezone' in params:
            query_params.append(('timezone', params['timezone']))  # noqa: E501
        if 'start_date' in params:
            query_params.append(('start_date', params['start_date']))  # noqa: E501
        if 'start_time' in params:
            query_params.append(('start_time', params['start_time']))  # noqa: E501
        if 'end_date' in params:
            query_params.append(('end_date', params['end_date']))  # noqa: E501
        if 'end_time' in params:
            query_params.append(('end_time', params['end_time']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'next_page' in params:
            query_params.append(('next_page', params['next_page']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth']  # noqa: E501

        return self.api_client.call_api(
            '/crypto/prices/technicals/ao', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ApiResponseCryptoAwesomeOscillator',  # noqa: E501
            auth_settings=auth_settings,
            _async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_crypto_price_technicals_atr(self, **kwargs):  # noqa: E501
        """Average True Range  # noqa: E501

        Returns the Average True Range values of Crypto Currency Prices for Crypto Currency Pair  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_crypto_price_technicals_atr(_async=True)
        >>> result = thread.get()

        :param async bool
        :param str pair: Return technicals for the given Crypto Currency Pair.
        :param str exchange: Return technicals for a Crypto Currency on the given Crypto Exchange.
        :param str currency: Return technicals for the given Crypto Currency.
        :param int period: The number of observations, per period, to calculate Average True Range.
        :param str timeframe: The time interval for the prices when calculating technicals.
        :param str timezone: Return technical date/times in this timezone, also interpret start/end date/time parameters in this timezone.
        :param date start_date: Return technicals on or after this date.
        :param str start_time: Return technicals at or after this time (24-hour).
        :param date end_date: Return technicals on or before this date.
        :param str end_time: Return technicals at or before this time (24-hour).
        :param int page_size: An integer greater than or equal to 1 for specifying the number of results on each page.
        :param str next_page: Gets the next page of data from a previous API call
        :return: ApiResponseCryptoAverageTrueRange
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_crypto_price_technicals_atr_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_crypto_price_technicals_atr_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_crypto_price_technicals_atr_with_http_info(self, **kwargs):  # noqa: E501
        """Average True Range  # noqa: E501

        Returns the Average True Range values of Crypto Currency Prices for Crypto Currency Pair  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_crypto_price_technicals_atr_with_http_info(_async=True)
        >>> result = thread.get()

        :param async bool
        :param str pair: Return technicals for the given Crypto Currency Pair.
        :param str exchange: Return technicals for a Crypto Currency on the given Crypto Exchange.
        :param str currency: Return technicals for the given Crypto Currency.
        :param int period: The number of observations, per period, to calculate Average True Range.
        :param str timeframe: The time interval for the prices when calculating technicals.
        :param str timezone: Return technical date/times in this timezone, also interpret start/end date/time parameters in this timezone.
        :param date start_date: Return technicals on or after this date.
        :param str start_time: Return technicals at or after this time (24-hour).
        :param date end_date: Return technicals on or before this date.
        :param str end_time: Return technicals at or before this time (24-hour).
        :param int page_size: An integer greater than or equal to 1 for specifying the number of results on each page.
        :param str next_page: Gets the next page of data from a previous API call
        :return: ApiResponseCryptoAverageTrueRange
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['pair', 'exchange', 'currency', 'period', 'timeframe', 'timezone', 'start_date', 'start_time', 'end_date', 'end_time', 'page_size', 'next_page']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_crypto_price_technicals_atr" % key
                )
            params[key] = val
        del params['kwargs']

        if 'period' in params and params['period'] < 5:  # noqa: E501
            raise ValueError("Invalid value for parameter `period` when calling `get_crypto_price_technicals_atr`, must be a value greater than or equal to `5`")  # noqa: E501
        if 'page_size' in params and params['page_size'] > 10000:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `get_crypto_price_technicals_atr`, must be a value less than or equal to `10000`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'pair' in params:
            query_params.append(('pair', params['pair']))  # noqa: E501
        if 'exchange' in params:
            query_params.append(('exchange', params['exchange']))  # noqa: E501
        if 'currency' in params:
            query_params.append(('currency', params['currency']))  # noqa: E501
        if 'period' in params:
            query_params.append(('period', params['period']))  # noqa: E501
        if 'timeframe' in params:
            query_params.append(('timeframe', params['timeframe']))  # noqa: E501
        if 'timezone' in params:
            query_params.append(('timezone', params['timezone']))  # noqa: E501
        if 'start_date' in params:
            query_params.append(('start_date', params['start_date']))  # noqa: E501
        if 'start_time' in params:
            query_params.append(('start_time', params['start_time']))  # noqa: E501
        if 'end_date' in params:
            query_params.append(('end_date', params['end_date']))  # noqa: E501
        if 'end_time' in params:
            query_params.append(('end_time', params['end_time']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'next_page' in params:
            query_params.append(('next_page', params['next_page']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth']  # noqa: E501

        return self.api_client.call_api(
            '/crypto/prices/technicals/atr', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ApiResponseCryptoAverageTrueRange',  # noqa: E501
            auth_settings=auth_settings,
            _async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_crypto_price_technicals_bb(self, **kwargs):  # noqa: E501
        """Bollinger Bands  # noqa: E501

        Returns the Bollinger Bands values of Crypto Currency Prices for a Crypto Currency Pair  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_crypto_price_technicals_bb(_async=True)
        >>> result = thread.get()

        :param async bool
        :param str pair: Return technicals for the given Crypto Currency Pair.
        :param str exchange: Return technicals for a Crypto Currency on the given Crypto Exchange.
        :param str currency: Return technicals for the given Crypto Currency.
        :param int period: The number of observations, per period, to calculate Bollinger Bands.
        :param float standard_deviations: The number of standard deviations to calculate the upper and lower bands of the Bollinger Bands.
        :param str price_key: The Crypto Currency Price field to use when calculating Bollinger Bands.
        :param str timeframe: The time interval for the prices when calculating technicals.
        :param str timezone: Return technical date/times in this timezone, also interpret start/end date/time parameters in this timezone.
        :param date start_date: Return technicals on or after this date.
        :param str start_time: Return technicals at or after this time (24-hour).
        :param date end_date: Return technicals on or before this date.
        :param str end_time: Return technicals at or before this time (24-hour).
        :param int page_size: An integer greater than or equal to 1 for specifying the number of results on each page.
        :param str next_page: Gets the next page of data from a previous API call
        :return: ApiResponseCryptoBollingerBands
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_crypto_price_technicals_bb_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_crypto_price_technicals_bb_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_crypto_price_technicals_bb_with_http_info(self, **kwargs):  # noqa: E501
        """Bollinger Bands  # noqa: E501

        Returns the Bollinger Bands values of Crypto Currency Prices for a Crypto Currency Pair  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_crypto_price_technicals_bb_with_http_info(_async=True)
        >>> result = thread.get()

        :param async bool
        :param str pair: Return technicals for the given Crypto Currency Pair.
        :param str exchange: Return technicals for a Crypto Currency on the given Crypto Exchange.
        :param str currency: Return technicals for the given Crypto Currency.
        :param int period: The number of observations, per period, to calculate Bollinger Bands.
        :param float standard_deviations: The number of standard deviations to calculate the upper and lower bands of the Bollinger Bands.
        :param str price_key: The Crypto Currency Price field to use when calculating Bollinger Bands.
        :param str timeframe: The time interval for the prices when calculating technicals.
        :param str timezone: Return technical date/times in this timezone, also interpret start/end date/time parameters in this timezone.
        :param date start_date: Return technicals on or after this date.
        :param str start_time: Return technicals at or after this time (24-hour).
        :param date end_date: Return technicals on or before this date.
        :param str end_time: Return technicals at or before this time (24-hour).
        :param int page_size: An integer greater than or equal to 1 for specifying the number of results on each page.
        :param str next_page: Gets the next page of data from a previous API call
        :return: ApiResponseCryptoBollingerBands
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['pair', 'exchange', 'currency', 'period', 'standard_deviations', 'price_key', 'timeframe', 'timezone', 'start_date', 'start_time', 'end_date', 'end_time', 'page_size', 'next_page']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_crypto_price_technicals_bb" % key
                )
            params[key] = val
        del params['kwargs']

        if 'period' in params and params['period'] < 5:  # noqa: E501
            raise ValueError("Invalid value for parameter `period` when calling `get_crypto_price_technicals_bb`, must be a value greater than or equal to `5`")  # noqa: E501
        if 'page_size' in params and params['page_size'] > 10000:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `get_crypto_price_technicals_bb`, must be a value less than or equal to `10000`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'pair' in params:
            query_params.append(('pair', params['pair']))  # noqa: E501
        if 'exchange' in params:
            query_params.append(('exchange', params['exchange']))  # noqa: E501
        if 'currency' in params:
            query_params.append(('currency', params['currency']))  # noqa: E501
        if 'period' in params:
            query_params.append(('period', params['period']))  # noqa: E501
        if 'standard_deviations' in params:
            query_params.append(('standard_deviations', params['standard_deviations']))  # noqa: E501
        if 'price_key' in params:
            query_params.append(('price_key', params['price_key']))  # noqa: E501
        if 'timeframe' in params:
            query_params.append(('timeframe', params['timeframe']))  # noqa: E501
        if 'timezone' in params:
            query_params.append(('timezone', params['timezone']))  # noqa: E501
        if 'start_date' in params:
            query_params.append(('start_date', params['start_date']))  # noqa: E501
        if 'start_time' in params:
            query_params.append(('start_time', params['start_time']))  # noqa: E501
        if 'end_date' in params:
            query_params.append(('end_date', params['end_date']))  # noqa: E501
        if 'end_time' in params:
            query_params.append(('end_time', params['end_time']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'next_page' in params:
            query_params.append(('next_page', params['next_page']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth']  # noqa: E501

        return self.api_client.call_api(
            '/crypto/prices/technicals/bb', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ApiResponseCryptoBollingerBands',  # noqa: E501
            auth_settings=auth_settings,
            _async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_crypto_price_technicals_cci(self, **kwargs):  # noqa: E501
        """Commodity Channel Index  # noqa: E501

        Returns the Commodity Channel Index values of Crypto Currency Prices for Crypto Currency Pair  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_crypto_price_technicals_cci(_async=True)
        >>> result = thread.get()

        :param async bool
        :param str pair: Return technicals for the given Crypto Currency Pair.
        :param str exchange: Return technicals for a Crypto Currency on the given Crypto Exchange.
        :param str currency: Return technicals for the given Crypto Currency.
        :param int period: The number of observations, per period, to calculate Commodity Channel Index.
        :param float constant: The number of observations, per period, to calculate Commodity Channel Index.
        :param str timeframe: The time interval for the prices when calculating technicals.
        :param str timezone: Return technical date/times in this timezone, also interpret start/end date/time parameters in this timezone.
        :param date start_date: Return technicals on or after this date.
        :param str start_time: Return technicals at or after this time (24-hour).
        :param date end_date: Return technicals on or before this date.
        :param str end_time: Return technicals at or before this time (24-hour).
        :param int page_size: An integer greater than or equal to 1 for specifying the number of results on each page.
        :param str next_page: Gets the next page of data from a previous API call
        :return: ApiResponseCryptoCommodityChannelIndex
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_crypto_price_technicals_cci_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_crypto_price_technicals_cci_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_crypto_price_technicals_cci_with_http_info(self, **kwargs):  # noqa: E501
        """Commodity Channel Index  # noqa: E501

        Returns the Commodity Channel Index values of Crypto Currency Prices for Crypto Currency Pair  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_crypto_price_technicals_cci_with_http_info(_async=True)
        >>> result = thread.get()

        :param async bool
        :param str pair: Return technicals for the given Crypto Currency Pair.
        :param str exchange: Return technicals for a Crypto Currency on the given Crypto Exchange.
        :param str currency: Return technicals for the given Crypto Currency.
        :param int period: The number of observations, per period, to calculate Commodity Channel Index.
        :param float constant: The number of observations, per period, to calculate Commodity Channel Index.
        :param str timeframe: The time interval for the prices when calculating technicals.
        :param str timezone: Return technical date/times in this timezone, also interpret start/end date/time parameters in this timezone.
        :param date start_date: Return technicals on or after this date.
        :param str start_time: Return technicals at or after this time (24-hour).
        :param date end_date: Return technicals on or before this date.
        :param str end_time: Return technicals at or before this time (24-hour).
        :param int page_size: An integer greater than or equal to 1 for specifying the number of results on each page.
        :param str next_page: Gets the next page of data from a previous API call
        :return: ApiResponseCryptoCommodityChannelIndex
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['pair', 'exchange', 'currency', 'period', 'constant', 'timeframe', 'timezone', 'start_date', 'start_time', 'end_date', 'end_time', 'page_size', 'next_page']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_crypto_price_technicals_cci" % key
                )
            params[key] = val
        del params['kwargs']

        if 'period' in params and params['period'] < 5:  # noqa: E501
            raise ValueError("Invalid value for parameter `period` when calling `get_crypto_price_technicals_cci`, must be a value greater than or equal to `5`")  # noqa: E501
        if 'page_size' in params and params['page_size'] > 10000:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `get_crypto_price_technicals_cci`, must be a value less than or equal to `10000`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'pair' in params:
            query_params.append(('pair', params['pair']))  # noqa: E501
        if 'exchange' in params:
            query_params.append(('exchange', params['exchange']))  # noqa: E501
        if 'currency' in params:
            query_params.append(('currency', params['currency']))  # noqa: E501
        if 'period' in params:
            query_params.append(('period', params['period']))  # noqa: E501
        if 'constant' in params:
            query_params.append(('constant', params['constant']))  # noqa: E501
        if 'timeframe' in params:
            query_params.append(('timeframe', params['timeframe']))  # noqa: E501
        if 'timezone' in params:
            query_params.append(('timezone', params['timezone']))  # noqa: E501
        if 'start_date' in params:
            query_params.append(('start_date', params['start_date']))  # noqa: E501
        if 'start_time' in params:
            query_params.append(('start_time', params['start_time']))  # noqa: E501
        if 'end_date' in params:
            query_params.append(('end_date', params['end_date']))  # noqa: E501
        if 'end_time' in params:
            query_params.append(('end_time', params['end_time']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'next_page' in params:
            query_params.append(('next_page', params['next_page']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth']  # noqa: E501

        return self.api_client.call_api(
            '/crypto/prices/technicals/cci', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ApiResponseCryptoCommodityChannelIndex',  # noqa: E501
            auth_settings=auth_settings,
            _async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_crypto_price_technicals_cmf(self, **kwargs):  # noqa: E501
        """Chaikin Money Flow  # noqa: E501

        Returns the Chaikin Money Flow values of Crypto Currency Prices for a Crypto Currency Pair  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_crypto_price_technicals_cmf(_async=True)
        >>> result = thread.get()

        :param async bool
        :param str pair: Return technicals for the given Crypto Currency Pair.
        :param str exchange: Return technicals for a Crypto Currency on the given Crypto Exchange.
        :param str currency: Return technicals for the given Crypto Currency.
        :param int period: The number of observations, per period, to calculate Chaikin Money Flow.
        :param str timeframe: The time interval for the prices when calculating technicals.
        :param str timezone: Return technical date/times in this timezone, also interpret start/end date/time parameters in this timezone.
        :param date start_date: Return technicals on or after this date.
        :param str start_time: Return technicals at or after this time (24-hour).
        :param date end_date: Return technicals on or before this date.
        :param str end_time: Return technicals at or before this time (24-hour).
        :param int page_size: An integer greater than or equal to 1 for specifying the number of results on each page.
        :param str next_page: Gets the next page of data from a previous API call
        :return: ApiResponseCryptoChaikinMoneyFlow
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_crypto_price_technicals_cmf_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_crypto_price_technicals_cmf_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_crypto_price_technicals_cmf_with_http_info(self, **kwargs):  # noqa: E501
        """Chaikin Money Flow  # noqa: E501

        Returns the Chaikin Money Flow values of Crypto Currency Prices for a Crypto Currency Pair  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_crypto_price_technicals_cmf_with_http_info(_async=True)
        >>> result = thread.get()

        :param async bool
        :param str pair: Return technicals for the given Crypto Currency Pair.
        :param str exchange: Return technicals for a Crypto Currency on the given Crypto Exchange.
        :param str currency: Return technicals for the given Crypto Currency.
        :param int period: The number of observations, per period, to calculate Chaikin Money Flow.
        :param str timeframe: The time interval for the prices when calculating technicals.
        :param str timezone: Return technical date/times in this timezone, also interpret start/end date/time parameters in this timezone.
        :param date start_date: Return technicals on or after this date.
        :param str start_time: Return technicals at or after this time (24-hour).
        :param date end_date: Return technicals on or before this date.
        :param str end_time: Return technicals at or before this time (24-hour).
        :param int page_size: An integer greater than or equal to 1 for specifying the number of results on each page.
        :param str next_page: Gets the next page of data from a previous API call
        :return: ApiResponseCryptoChaikinMoneyFlow
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['pair', 'exchange', 'currency', 'period', 'timeframe', 'timezone', 'start_date', 'start_time', 'end_date', 'end_time', 'page_size', 'next_page']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_crypto_price_technicals_cmf" % key
                )
            params[key] = val
        del params['kwargs']

        if 'period' in params and params['period'] < 5:  # noqa: E501
            raise ValueError("Invalid value for parameter `period` when calling `get_crypto_price_technicals_cmf`, must be a value greater than or equal to `5`")  # noqa: E501
        if 'page_size' in params and params['page_size'] > 10000:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `get_crypto_price_technicals_cmf`, must be a value less than or equal to `10000`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'pair' in params:
            query_params.append(('pair', params['pair']))  # noqa: E501
        if 'exchange' in params:
            query_params.append(('exchange', params['exchange']))  # noqa: E501
        if 'currency' in params:
            query_params.append(('currency', params['currency']))  # noqa: E501
        if 'period' in params:
            query_params.append(('period', params['period']))  # noqa: E501
        if 'timeframe' in params:
            query_params.append(('timeframe', params['timeframe']))  # noqa: E501
        if 'timezone' in params:
            query_params.append(('timezone', params['timezone']))  # noqa: E501
        if 'start_date' in params:
            query_params.append(('start_date', params['start_date']))  # noqa: E501
        if 'start_time' in params:
            query_params.append(('start_time', params['start_time']))  # noqa: E501
        if 'end_date' in params:
            query_params.append(('end_date', params['end_date']))  # noqa: E501
        if 'end_time' in params:
            query_params.append(('end_time', params['end_time']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'next_page' in params:
            query_params.append(('next_page', params['next_page']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth']  # noqa: E501

        return self.api_client.call_api(
            '/crypto/prices/technicals/cmf', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ApiResponseCryptoChaikinMoneyFlow',  # noqa: E501
            auth_settings=auth_settings,
            _async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_crypto_price_technicals_dc(self, **kwargs):  # noqa: E501
        """Donchian Channel  # noqa: E501

        Returns the Donchian Channel values of Crypto Currency Prices for a Crypto Currency Pair  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_crypto_price_technicals_dc(_async=True)
        >>> result = thread.get()

        :param async bool
        :param str pair: Return technicals for the given Crypto Currency Pair.
        :param str exchange: Return technicals for a Crypto Currency on the given Crypto Exchange.
        :param str currency: Return technicals for the given Crypto Currency.
        :param int period: The number of observations, per period, to calculate Donchian Channel.
        :param str price_key: The Crypto Currency Price field to use when calculating Donchian Channel.
        :param str timeframe: The time interval for the prices when calculating technicals.
        :param str timezone: Return technical date/times in this timezone, also interpret start/end date/time parameters in this timezone.
        :param date start_date: Return technicals on or after this date.
        :param str start_time: Return technicals at or after this time (24-hour).
        :param date end_date: Return technicals on or before this date.
        :param str end_time: Return technicals at or before this time (24-hour).
        :param int page_size: An integer greater than or equal to 1 for specifying the number of results on each page.
        :param str next_page: Gets the next page of data from a previous API call
        :return: ApiResponseCryptoDonchianChannel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_crypto_price_technicals_dc_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_crypto_price_technicals_dc_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_crypto_price_technicals_dc_with_http_info(self, **kwargs):  # noqa: E501
        """Donchian Channel  # noqa: E501

        Returns the Donchian Channel values of Crypto Currency Prices for a Crypto Currency Pair  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_crypto_price_technicals_dc_with_http_info(_async=True)
        >>> result = thread.get()

        :param async bool
        :param str pair: Return technicals for the given Crypto Currency Pair.
        :param str exchange: Return technicals for a Crypto Currency on the given Crypto Exchange.
        :param str currency: Return technicals for the given Crypto Currency.
        :param int period: The number of observations, per period, to calculate Donchian Channel.
        :param str price_key: The Crypto Currency Price field to use when calculating Donchian Channel.
        :param str timeframe: The time interval for the prices when calculating technicals.
        :param str timezone: Return technical date/times in this timezone, also interpret start/end date/time parameters in this timezone.
        :param date start_date: Return technicals on or after this date.
        :param str start_time: Return technicals at or after this time (24-hour).
        :param date end_date: Return technicals on or before this date.
        :param str end_time: Return technicals at or before this time (24-hour).
        :param int page_size: An integer greater than or equal to 1 for specifying the number of results on each page.
        :param str next_page: Gets the next page of data from a previous API call
        :return: ApiResponseCryptoDonchianChannel
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['pair', 'exchange', 'currency', 'period', 'price_key', 'timeframe', 'timezone', 'start_date', 'start_time', 'end_date', 'end_time', 'page_size', 'next_page']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_crypto_price_technicals_dc" % key
                )
            params[key] = val
        del params['kwargs']

        if 'period' in params and params['period'] < 5:  # noqa: E501
            raise ValueError("Invalid value for parameter `period` when calling `get_crypto_price_technicals_dc`, must be a value greater than or equal to `5`")  # noqa: E501
        if 'page_size' in params and params['page_size'] > 10000:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `get_crypto_price_technicals_dc`, must be a value less than or equal to `10000`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'pair' in params:
            query_params.append(('pair', params['pair']))  # noqa: E501
        if 'exchange' in params:
            query_params.append(('exchange', params['exchange']))  # noqa: E501
        if 'currency' in params:
            query_params.append(('currency', params['currency']))  # noqa: E501
        if 'period' in params:
            query_params.append(('period', params['period']))  # noqa: E501
        if 'price_key' in params:
            query_params.append(('price_key', params['price_key']))  # noqa: E501
        if 'timeframe' in params:
            query_params.append(('timeframe', params['timeframe']))  # noqa: E501
        if 'timezone' in params:
            query_params.append(('timezone', params['timezone']))  # noqa: E501
        if 'start_date' in params:
            query_params.append(('start_date', params['start_date']))  # noqa: E501
        if 'start_time' in params:
            query_params.append(('start_time', params['start_time']))  # noqa: E501
        if 'end_date' in params:
            query_params.append(('end_date', params['end_date']))  # noqa: E501
        if 'end_time' in params:
            query_params.append(('end_time', params['end_time']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'next_page' in params:
            query_params.append(('next_page', params['next_page']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth']  # noqa: E501

        return self.api_client.call_api(
            '/crypto/prices/technicals/dc', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ApiResponseCryptoDonchianChannel',  # noqa: E501
            auth_settings=auth_settings,
            _async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_crypto_price_technicals_dpo(self, **kwargs):  # noqa: E501
        """Detrended Price Oscillator  # noqa: E501

        Returns the Detrended Price Oscillator values of Crypto Currency Prices for a Crypto Currency Pair  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_crypto_price_technicals_dpo(_async=True)
        >>> result = thread.get()

        :param async bool
        :param str pair: Return technicals for the given Crypto Currency Pair.
        :param str exchange: Return technicals for a Crypto Currency on the given Crypto Exchange.
        :param str currency: Return technicals for the given Crypto Currency.
        :param int period: The number of observations, per period, to calculate Detrended Price Oscillator.
        :param str price_key: The Crypto Currency Price field to use when calculating Detrended Price Oscillator.
        :param str timeframe: The time interval for the prices when calculating technicals.
        :param str timezone: Return technical date/times in this timezone, also interpret start/end date/time parameters in this timezone.
        :param date start_date: Return technicals on or after this date.
        :param str start_time: Return technicals at or after this time (24-hour).
        :param date end_date: Return technicals on or before this date.
        :param str end_time: Return technicals at or before this time (24-hour).
        :param int page_size: An integer greater than or equal to 1 for specifying the number of results on each page.
        :param str next_page: Gets the next page of data from a previous API call
        :return: ApiResponseCryptoDetrendedPriceOscillator
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_crypto_price_technicals_dpo_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_crypto_price_technicals_dpo_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_crypto_price_technicals_dpo_with_http_info(self, **kwargs):  # noqa: E501
        """Detrended Price Oscillator  # noqa: E501

        Returns the Detrended Price Oscillator values of Crypto Currency Prices for a Crypto Currency Pair  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_crypto_price_technicals_dpo_with_http_info(_async=True)
        >>> result = thread.get()

        :param async bool
        :param str pair: Return technicals for the given Crypto Currency Pair.
        :param str exchange: Return technicals for a Crypto Currency on the given Crypto Exchange.
        :param str currency: Return technicals for the given Crypto Currency.
        :param int period: The number of observations, per period, to calculate Detrended Price Oscillator.
        :param str price_key: The Crypto Currency Price field to use when calculating Detrended Price Oscillator.
        :param str timeframe: The time interval for the prices when calculating technicals.
        :param str timezone: Return technical date/times in this timezone, also interpret start/end date/time parameters in this timezone.
        :param date start_date: Return technicals on or after this date.
        :param str start_time: Return technicals at or after this time (24-hour).
        :param date end_date: Return technicals on or before this date.
        :param str end_time: Return technicals at or before this time (24-hour).
        :param int page_size: An integer greater than or equal to 1 for specifying the number of results on each page.
        :param str next_page: Gets the next page of data from a previous API call
        :return: ApiResponseCryptoDetrendedPriceOscillator
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['pair', 'exchange', 'currency', 'period', 'price_key', 'timeframe', 'timezone', 'start_date', 'start_time', 'end_date', 'end_time', 'page_size', 'next_page']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_crypto_price_technicals_dpo" % key
                )
            params[key] = val
        del params['kwargs']

        if 'page_size' in params and params['page_size'] > 10000:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `get_crypto_price_technicals_dpo`, must be a value less than or equal to `10000`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'pair' in params:
            query_params.append(('pair', params['pair']))  # noqa: E501
        if 'exchange' in params:
            query_params.append(('exchange', params['exchange']))  # noqa: E501
        if 'currency' in params:
            query_params.append(('currency', params['currency']))  # noqa: E501
        if 'period' in params:
            query_params.append(('period', params['period']))  # noqa: E501
        if 'price_key' in params:
            query_params.append(('price_key', params['price_key']))  # noqa: E501
        if 'timeframe' in params:
            query_params.append(('timeframe', params['timeframe']))  # noqa: E501
        if 'timezone' in params:
            query_params.append(('timezone', params['timezone']))  # noqa: E501
        if 'start_date' in params:
            query_params.append(('start_date', params['start_date']))  # noqa: E501
        if 'start_time' in params:
            query_params.append(('start_time', params['start_time']))  # noqa: E501
        if 'end_date' in params:
            query_params.append(('end_date', params['end_date']))  # noqa: E501
        if 'end_time' in params:
            query_params.append(('end_time', params['end_time']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'next_page' in params:
            query_params.append(('next_page', params['next_page']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth']  # noqa: E501

        return self.api_client.call_api(
            '/crypto/prices/technicals/dpo', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ApiResponseCryptoDetrendedPriceOscillator',  # noqa: E501
            auth_settings=auth_settings,
            _async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_crypto_price_technicals_eom(self, **kwargs):  # noqa: E501
        """Ease of Movement  # noqa: E501

        Returns the Ease of Movement values of Crypto Currency Prices for a Crypto Currency Pair  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_crypto_price_technicals_eom(_async=True)
        >>> result = thread.get()

        :param async bool
        :param str pair: Return technicals for the given Crypto Currency Pair.
        :param str exchange: Return technicals for a Crypto Currency on the given Crypto Exchange.
        :param str currency: Return technicals for the given Crypto Currency.
        :param int period: The number of observations, per period, to calculate Ease of Movement.
        :param str timeframe: The time interval for the prices when calculating technicals.
        :param str timezone: Return technical date/times in this timezone, also interpret start/end date/time parameters in this timezone.
        :param date start_date: Return technicals on or after this date.
        :param str start_time: Return technicals at or after this time (24-hour).
        :param date end_date: Return technicals on or before this date.
        :param str end_time: Return technicals at or before this time (24-hour).
        :param int page_size: An integer greater than or equal to 1 for specifying the number of results on each page.
        :param str next_page: Gets the next page of data from a previous API call
        :return: ApiResponseCryptoEaseOfMovement
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_crypto_price_technicals_eom_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_crypto_price_technicals_eom_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_crypto_price_technicals_eom_with_http_info(self, **kwargs):  # noqa: E501
        """Ease of Movement  # noqa: E501

        Returns the Ease of Movement values of Crypto Currency Prices for a Crypto Currency Pair  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_crypto_price_technicals_eom_with_http_info(_async=True)
        >>> result = thread.get()

        :param async bool
        :param str pair: Return technicals for the given Crypto Currency Pair.
        :param str exchange: Return technicals for a Crypto Currency on the given Crypto Exchange.
        :param str currency: Return technicals for the given Crypto Currency.
        :param int period: The number of observations, per period, to calculate Ease of Movement.
        :param str timeframe: The time interval for the prices when calculating technicals.
        :param str timezone: Return technical date/times in this timezone, also interpret start/end date/time parameters in this timezone.
        :param date start_date: Return technicals on or after this date.
        :param str start_time: Return technicals at or after this time (24-hour).
        :param date end_date: Return technicals on or before this date.
        :param str end_time: Return technicals at or before this time (24-hour).
        :param int page_size: An integer greater than or equal to 1 for specifying the number of results on each page.
        :param str next_page: Gets the next page of data from a previous API call
        :return: ApiResponseCryptoEaseOfMovement
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['pair', 'exchange', 'currency', 'period', 'timeframe', 'timezone', 'start_date', 'start_time', 'end_date', 'end_time', 'page_size', 'next_page']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_crypto_price_technicals_eom" % key
                )
            params[key] = val
        del params['kwargs']

        if 'period' in params and params['period'] < 4:  # noqa: E501
            raise ValueError("Invalid value for parameter `period` when calling `get_crypto_price_technicals_eom`, must be a value greater than or equal to `4`")  # noqa: E501
        if 'page_size' in params and params['page_size'] > 10000:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `get_crypto_price_technicals_eom`, must be a value less than or equal to `10000`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'pair' in params:
            query_params.append(('pair', params['pair']))  # noqa: E501
        if 'exchange' in params:
            query_params.append(('exchange', params['exchange']))  # noqa: E501
        if 'currency' in params:
            query_params.append(('currency', params['currency']))  # noqa: E501
        if 'period' in params:
            query_params.append(('period', params['period']))  # noqa: E501
        if 'timeframe' in params:
            query_params.append(('timeframe', params['timeframe']))  # noqa: E501
        if 'timezone' in params:
            query_params.append(('timezone', params['timezone']))  # noqa: E501
        if 'start_date' in params:
            query_params.append(('start_date', params['start_date']))  # noqa: E501
        if 'start_time' in params:
            query_params.append(('start_time', params['start_time']))  # noqa: E501
        if 'end_date' in params:
            query_params.append(('end_date', params['end_date']))  # noqa: E501
        if 'end_time' in params:
            query_params.append(('end_time', params['end_time']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'next_page' in params:
            query_params.append(('next_page', params['next_page']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth']  # noqa: E501

        return self.api_client.call_api(
            '/crypto/prices/technicals/eom', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ApiResponseCryptoEaseOfMovement',  # noqa: E501
            auth_settings=auth_settings,
            _async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_crypto_price_technicals_fi(self, **kwargs):  # noqa: E501
        """Force Index  # noqa: E501

        Returns the Force Index values of Crypto Currency Prices for a Crypto Currency Pair  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_crypto_price_technicals_fi(_async=True)
        >>> result = thread.get()

        :param async bool
        :param str pair: Return technicals for the given Crypto Currency Pair.
        :param str exchange: Return technicals for a Crypto Currency on the given Crypto Exchange.
        :param str currency: Return technicals for the given Crypto Currency.
        :param str timeframe: The time interval for the prices when calculating technicals.
        :param str timezone: Return technical date/times in this timezone, also interpret start/end date/time parameters in this timezone.
        :param date start_date: Return technicals on or after this date.
        :param str start_time: Return technicals at or after this time (24-hour).
        :param date end_date: Return technicals on or before this date.
        :param str end_time: Return technicals at or before this time (24-hour).
        :param int page_size: An integer greater than or equal to 1 for specifying the number of results on each page.
        :param str next_page: Gets the next page of data from a previous API call
        :return: ApiResponseCryptoForceIndex
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_crypto_price_technicals_fi_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_crypto_price_technicals_fi_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_crypto_price_technicals_fi_with_http_info(self, **kwargs):  # noqa: E501
        """Force Index  # noqa: E501

        Returns the Force Index values of Crypto Currency Prices for a Crypto Currency Pair  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_crypto_price_technicals_fi_with_http_info(_async=True)
        >>> result = thread.get()

        :param async bool
        :param str pair: Return technicals for the given Crypto Currency Pair.
        :param str exchange: Return technicals for a Crypto Currency on the given Crypto Exchange.
        :param str currency: Return technicals for the given Crypto Currency.
        :param str timeframe: The time interval for the prices when calculating technicals.
        :param str timezone: Return technical date/times in this timezone, also interpret start/end date/time parameters in this timezone.
        :param date start_date: Return technicals on or after this date.
        :param str start_time: Return technicals at or after this time (24-hour).
        :param date end_date: Return technicals on or before this date.
        :param str end_time: Return technicals at or before this time (24-hour).
        :param int page_size: An integer greater than or equal to 1 for specifying the number of results on each page.
        :param str next_page: Gets the next page of data from a previous API call
        :return: ApiResponseCryptoForceIndex
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['pair', 'exchange', 'currency', 'timeframe', 'timezone', 'start_date', 'start_time', 'end_date', 'end_time', 'page_size', 'next_page']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_crypto_price_technicals_fi" % key
                )
            params[key] = val
        del params['kwargs']

        if 'page_size' in params and params['page_size'] > 10000:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `get_crypto_price_technicals_fi`, must be a value less than or equal to `10000`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'pair' in params:
            query_params.append(('pair', params['pair']))  # noqa: E501
        if 'exchange' in params:
            query_params.append(('exchange', params['exchange']))  # noqa: E501
        if 'currency' in params:
            query_params.append(('currency', params['currency']))  # noqa: E501
        if 'timeframe' in params:
            query_params.append(('timeframe', params['timeframe']))  # noqa: E501
        if 'timezone' in params:
            query_params.append(('timezone', params['timezone']))  # noqa: E501
        if 'start_date' in params:
            query_params.append(('start_date', params['start_date']))  # noqa: E501
        if 'start_time' in params:
            query_params.append(('start_time', params['start_time']))  # noqa: E501
        if 'end_date' in params:
            query_params.append(('end_date', params['end_date']))  # noqa: E501
        if 'end_time' in params:
            query_params.append(('end_time', params['end_time']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'next_page' in params:
            query_params.append(('next_page', params['next_page']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth']  # noqa: E501

        return self.api_client.call_api(
            '/crypto/prices/technicals/fi', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ApiResponseCryptoForceIndex',  # noqa: E501
            auth_settings=auth_settings,
            _async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_crypto_price_technicals_ichimoku(self, **kwargs):  # noqa: E501
        """Ichimoku Kinko Hyo  # noqa: E501

        Returns the Ichimoku Kinko Hyo values of Crypto Currency Prices for a Crypto Currency Pair  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_crypto_price_technicals_ichimoku(_async=True)
        >>> result = thread.get()

        :param async bool
        :param str pair: Return technicals for the given Crypto Currency Pair.
        :param str exchange: Return technicals for a Crypto Currency on the given Crypto Exchange.
        :param str currency: Return technicals for the given Crypto Currency.
        :param int low_period: The number of observations, per period, to calculate Tenkan Sen (Conversion Line) of Ichimoku Kinko Hyo.
        :param int medium_period: The number of observations, per period, to calculate Kijun Sen (Base Line), Senkou Span A (Leading Span A), and Chikou Span (Lagging Span) of Ichimoku Kinko Hyo.
        :param int high_period: The number of observations, per period, to calculate Senkou Span B (Leading Span B) of Ichimoku Kinko Hyo.
        :param str timeframe: The time interval for the prices when calculating technicals.
        :param str timezone: Return technical date/times in this timezone, also interpret start/end date/time parameters in this timezone.
        :param date start_date: Return technicals on or after this date.
        :param str start_time: Return technicals at or after this time (24-hour).
        :param date end_date: Return technicals on or before this date.
        :param str end_time: Return technicals at or before this time (24-hour).
        :param int page_size: An integer greater than or equal to 1 for specifying the number of results on each page.
        :param str next_page: Gets the next page of data from a previous API call
        :return: ApiResponseCryptoIchimokuKinkoHyo
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_crypto_price_technicals_ichimoku_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_crypto_price_technicals_ichimoku_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_crypto_price_technicals_ichimoku_with_http_info(self, **kwargs):  # noqa: E501
        """Ichimoku Kinko Hyo  # noqa: E501

        Returns the Ichimoku Kinko Hyo values of Crypto Currency Prices for a Crypto Currency Pair  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_crypto_price_technicals_ichimoku_with_http_info(_async=True)
        >>> result = thread.get()

        :param async bool
        :param str pair: Return technicals for the given Crypto Currency Pair.
        :param str exchange: Return technicals for a Crypto Currency on the given Crypto Exchange.
        :param str currency: Return technicals for the given Crypto Currency.
        :param int low_period: The number of observations, per period, to calculate Tenkan Sen (Conversion Line) of Ichimoku Kinko Hyo.
        :param int medium_period: The number of observations, per period, to calculate Kijun Sen (Base Line), Senkou Span A (Leading Span A), and Chikou Span (Lagging Span) of Ichimoku Kinko Hyo.
        :param int high_period: The number of observations, per period, to calculate Senkou Span B (Leading Span B) of Ichimoku Kinko Hyo.
        :param str timeframe: The time interval for the prices when calculating technicals.
        :param str timezone: Return technical date/times in this timezone, also interpret start/end date/time parameters in this timezone.
        :param date start_date: Return technicals on or after this date.
        :param str start_time: Return technicals at or after this time (24-hour).
        :param date end_date: Return technicals on or before this date.
        :param str end_time: Return technicals at or before this time (24-hour).
        :param int page_size: An integer greater than or equal to 1 for specifying the number of results on each page.
        :param str next_page: Gets the next page of data from a previous API call
        :return: ApiResponseCryptoIchimokuKinkoHyo
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['pair', 'exchange', 'currency', 'low_period', 'medium_period', 'high_period', 'timeframe', 'timezone', 'start_date', 'start_time', 'end_date', 'end_time', 'page_size', 'next_page']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_crypto_price_technicals_ichimoku" % key
                )
            params[key] = val
        del params['kwargs']

        if 'medium_period' in params and params['medium_period'] < 2:  # noqa: E501
            raise ValueError("Invalid value for parameter `medium_period` when calling `get_crypto_price_technicals_ichimoku`, must be a value greater than or equal to `2`")  # noqa: E501
        if 'high_period' in params and params['high_period'] < 4:  # noqa: E501
            raise ValueError("Invalid value for parameter `high_period` when calling `get_crypto_price_technicals_ichimoku`, must be a value greater than or equal to `4`")  # noqa: E501
        if 'page_size' in params and params['page_size'] > 10000:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `get_crypto_price_technicals_ichimoku`, must be a value less than or equal to `10000`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'pair' in params:
            query_params.append(('pair', params['pair']))  # noqa: E501
        if 'exchange' in params:
            query_params.append(('exchange', params['exchange']))  # noqa: E501
        if 'currency' in params:
            query_params.append(('currency', params['currency']))  # noqa: E501
        if 'low_period' in params:
            query_params.append(('low_period', params['low_period']))  # noqa: E501
        if 'medium_period' in params:
            query_params.append(('medium_period', params['medium_period']))  # noqa: E501
        if 'high_period' in params:
            query_params.append(('high_period', params['high_period']))  # noqa: E501
        if 'timeframe' in params:
            query_params.append(('timeframe', params['timeframe']))  # noqa: E501
        if 'timezone' in params:
            query_params.append(('timezone', params['timezone']))  # noqa: E501
        if 'start_date' in params:
            query_params.append(('start_date', params['start_date']))  # noqa: E501
        if 'start_time' in params:
            query_params.append(('start_time', params['start_time']))  # noqa: E501
        if 'end_date' in params:
            query_params.append(('end_date', params['end_date']))  # noqa: E501
        if 'end_time' in params:
            query_params.append(('end_time', params['end_time']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'next_page' in params:
            query_params.append(('next_page', params['next_page']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth']  # noqa: E501

        return self.api_client.call_api(
            '/crypto/prices/technicals/ichimoku', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ApiResponseCryptoIchimokuKinkoHyo',  # noqa: E501
            auth_settings=auth_settings,
            _async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_crypto_price_technicals_kc(self, **kwargs):  # noqa: E501
        """Keltner Channel  # noqa: E501

        Returns the Keltner Channel values of Crypto Currency Prices for a Crypto Currency Pair  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_crypto_price_technicals_kc(_async=True)
        >>> result = thread.get()

        :param async bool
        :param str pair: Return technicals for the given Crypto Currency Pair.
        :param str exchange: Return technicals for a Crypto Currency on the given Crypto Exchange.
        :param str currency: Return technicals for the given Crypto Currency.
        :param int period: The number of observations, per period, to calculate Kelter Channel.
        :param str timeframe: The time interval for the prices when calculating technicals.
        :param str timezone: Return technical date/times in this timezone, also interpret start/end date/time parameters in this timezone.
        :param date start_date: Return technicals on or after this date.
        :param str start_time: Return technicals at or after this time (24-hour).
        :param date end_date: Return technicals on or before this date.
        :param str end_time: Return technicals at or before this time (24-hour).
        :param int page_size: An integer greater than or equal to 1 for specifying the number of results on each page.
        :param str next_page: Gets the next page of data from a previous API call
        :return: ApiResponseCryptoKeltnerChannel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_crypto_price_technicals_kc_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_crypto_price_technicals_kc_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_crypto_price_technicals_kc_with_http_info(self, **kwargs):  # noqa: E501
        """Keltner Channel  # noqa: E501

        Returns the Keltner Channel values of Crypto Currency Prices for a Crypto Currency Pair  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_crypto_price_technicals_kc_with_http_info(_async=True)
        >>> result = thread.get()

        :param async bool
        :param str pair: Return technicals for the given Crypto Currency Pair.
        :param str exchange: Return technicals for a Crypto Currency on the given Crypto Exchange.
        :param str currency: Return technicals for the given Crypto Currency.
        :param int period: The number of observations, per period, to calculate Kelter Channel.
        :param str timeframe: The time interval for the prices when calculating technicals.
        :param str timezone: Return technical date/times in this timezone, also interpret start/end date/time parameters in this timezone.
        :param date start_date: Return technicals on or after this date.
        :param str start_time: Return technicals at or after this time (24-hour).
        :param date end_date: Return technicals on or before this date.
        :param str end_time: Return technicals at or before this time (24-hour).
        :param int page_size: An integer greater than or equal to 1 for specifying the number of results on each page.
        :param str next_page: Gets the next page of data from a previous API call
        :return: ApiResponseCryptoKeltnerChannel
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['pair', 'exchange', 'currency', 'period', 'timeframe', 'timezone', 'start_date', 'start_time', 'end_date', 'end_time', 'page_size', 'next_page']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_crypto_price_technicals_kc" % key
                )
            params[key] = val
        del params['kwargs']

        if 'period' in params and params['period'] < 5:  # noqa: E501
            raise ValueError("Invalid value for parameter `period` when calling `get_crypto_price_technicals_kc`, must be a value greater than or equal to `5`")  # noqa: E501
        if 'page_size' in params and params['page_size'] > 10000:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `get_crypto_price_technicals_kc`, must be a value less than or equal to `10000`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'pair' in params:
            query_params.append(('pair', params['pair']))  # noqa: E501
        if 'exchange' in params:
            query_params.append(('exchange', params['exchange']))  # noqa: E501
        if 'currency' in params:
            query_params.append(('currency', params['currency']))  # noqa: E501
        if 'period' in params:
            query_params.append(('period', params['period']))  # noqa: E501
        if 'timeframe' in params:
            query_params.append(('timeframe', params['timeframe']))  # noqa: E501
        if 'timezone' in params:
            query_params.append(('timezone', params['timezone']))  # noqa: E501
        if 'start_date' in params:
            query_params.append(('start_date', params['start_date']))  # noqa: E501
        if 'start_time' in params:
            query_params.append(('start_time', params['start_time']))  # noqa: E501
        if 'end_date' in params:
            query_params.append(('end_date', params['end_date']))  # noqa: E501
        if 'end_time' in params:
            query_params.append(('end_time', params['end_time']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'next_page' in params:
            query_params.append(('next_page', params['next_page']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth']  # noqa: E501

        return self.api_client.call_api(
            '/crypto/prices/technicals/kc', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ApiResponseCryptoKeltnerChannel',  # noqa: E501
            auth_settings=auth_settings,
            _async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_crypto_price_technicals_kst(self, **kwargs):  # noqa: E501
        """Know Sure Thing  # noqa: E501

        Returns the Know Sure Thing values of Crypto Currency Prices for a Crypto Currency Pair  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_crypto_price_technicals_kst(_async=True)
        >>> result = thread.get()

        :param async bool
        :param str pair: Return technicals for the given Crypto Currency Pair.
        :param str exchange: Return technicals for a Crypto Currency on the given Crypto Exchange.
        :param str currency: Return technicals for the given Crypto Currency.
        :param int roc1: The number of observations, per period, to calculate the rate-of-change for RCMA1.
        :param int roc2: The number of observations, per period, to calculate the rate-of-change for RCMA2.
        :param int roc3: The number of observations, per period, to calculate the rate-of-change for RCMA3.
        :param int roc4: The number of observations, per period, to calculate the rate-of-change for RCMA4.
        :param int sma1: The number of observations, per period, to calculate the Simple Moving Average of the rate-of-change for RCMA1.
        :param int sma2: The number of observations, per period, to calculate the Simple Moving Average of the rate-of-change for RCMA2.
        :param int sma3: The number of observations, per period, to calculate the Simple Moving Average of the rate-of-change for RCMA3.
        :param int sma4: The number of observations, per period, to calculate the Simple Moving Average of the rate-of-change for RCMA4.
        :param str price_key: The Crypto Currency Price field to use when calculating Know Sure Thing.
        :param str timeframe: The time interval for the prices when calculating technicals.
        :param str timezone: Return technical date/times in this timezone, also interpret start/end date/time parameters in this timezone.
        :param date start_date: Return technicals on or after this date.
        :param str start_time: Return technicals at or after this time (24-hour).
        :param date end_date: Return technicals on or before this date.
        :param str end_time: Return technicals at or before this time (24-hour).
        :param int page_size: An integer greater than or equal to 1 for specifying the number of results on each page.
        :param str next_page: Gets the next page of data from a previous API call
        :return: ApiResponseCryptoKnowSureThing
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_crypto_price_technicals_kst_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_crypto_price_technicals_kst_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_crypto_price_technicals_kst_with_http_info(self, **kwargs):  # noqa: E501
        """Know Sure Thing  # noqa: E501

        Returns the Know Sure Thing values of Crypto Currency Prices for a Crypto Currency Pair  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_crypto_price_technicals_kst_with_http_info(_async=True)
        >>> result = thread.get()

        :param async bool
        :param str pair: Return technicals for the given Crypto Currency Pair.
        :param str exchange: Return technicals for a Crypto Currency on the given Crypto Exchange.
        :param str currency: Return technicals for the given Crypto Currency.
        :param int roc1: The number of observations, per period, to calculate the rate-of-change for RCMA1.
        :param int roc2: The number of observations, per period, to calculate the rate-of-change for RCMA2.
        :param int roc3: The number of observations, per period, to calculate the rate-of-change for RCMA3.
        :param int roc4: The number of observations, per period, to calculate the rate-of-change for RCMA4.
        :param int sma1: The number of observations, per period, to calculate the Simple Moving Average of the rate-of-change for RCMA1.
        :param int sma2: The number of observations, per period, to calculate the Simple Moving Average of the rate-of-change for RCMA2.
        :param int sma3: The number of observations, per period, to calculate the Simple Moving Average of the rate-of-change for RCMA3.
        :param int sma4: The number of observations, per period, to calculate the Simple Moving Average of the rate-of-change for RCMA4.
        :param str price_key: The Crypto Currency Price field to use when calculating Know Sure Thing.
        :param str timeframe: The time interval for the prices when calculating technicals.
        :param str timezone: Return technical date/times in this timezone, also interpret start/end date/time parameters in this timezone.
        :param date start_date: Return technicals on or after this date.
        :param str start_time: Return technicals at or after this time (24-hour).
        :param date end_date: Return technicals on or before this date.
        :param str end_time: Return technicals at or before this time (24-hour).
        :param int page_size: An integer greater than or equal to 1 for specifying the number of results on each page.
        :param str next_page: Gets the next page of data from a previous API call
        :return: ApiResponseCryptoKnowSureThing
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['pair', 'exchange', 'currency', 'roc1', 'roc2', 'roc3', 'roc4', 'sma1', 'sma2', 'sma3', 'sma4', 'price_key', 'timeframe', 'timezone', 'start_date', 'start_time', 'end_date', 'end_time', 'page_size', 'next_page']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_crypto_price_technicals_kst" % key
                )
            params[key] = val
        del params['kwargs']

        if 'roc4' in params and params['roc4'] < 3:  # noqa: E501
            raise ValueError("Invalid value for parameter `roc4` when calling `get_crypto_price_technicals_kst`, must be a value greater than or equal to `3`")  # noqa: E501
        if 'sma4' in params and params['sma4'] < 3:  # noqa: E501
            raise ValueError("Invalid value for parameter `sma4` when calling `get_crypto_price_technicals_kst`, must be a value greater than or equal to `3`")  # noqa: E501
        if 'page_size' in params and params['page_size'] > 10000:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `get_crypto_price_technicals_kst`, must be a value less than or equal to `10000`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'pair' in params:
            query_params.append(('pair', params['pair']))  # noqa: E501
        if 'exchange' in params:
            query_params.append(('exchange', params['exchange']))  # noqa: E501
        if 'currency' in params:
            query_params.append(('currency', params['currency']))  # noqa: E501
        if 'roc1' in params:
            query_params.append(('roc1', params['roc1']))  # noqa: E501
        if 'roc2' in params:
            query_params.append(('roc2', params['roc2']))  # noqa: E501
        if 'roc3' in params:
            query_params.append(('roc3', params['roc3']))  # noqa: E501
        if 'roc4' in params:
            query_params.append(('roc4', params['roc4']))  # noqa: E501
        if 'sma1' in params:
            query_params.append(('sma1', params['sma1']))  # noqa: E501
        if 'sma2' in params:
            query_params.append(('sma2', params['sma2']))  # noqa: E501
        if 'sma3' in params:
            query_params.append(('sma3', params['sma3']))  # noqa: E501
        if 'sma4' in params:
            query_params.append(('sma4', params['sma4']))  # noqa: E501
        if 'price_key' in params:
            query_params.append(('price_key', params['price_key']))  # noqa: E501
        if 'timeframe' in params:
            query_params.append(('timeframe', params['timeframe']))  # noqa: E501
        if 'timezone' in params:
            query_params.append(('timezone', params['timezone']))  # noqa: E501
        if 'start_date' in params:
            query_params.append(('start_date', params['start_date']))  # noqa: E501
        if 'start_time' in params:
            query_params.append(('start_time', params['start_time']))  # noqa: E501
        if 'end_date' in params:
            query_params.append(('end_date', params['end_date']))  # noqa: E501
        if 'end_time' in params:
            query_params.append(('end_time', params['end_time']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'next_page' in params:
            query_params.append(('next_page', params['next_page']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth']  # noqa: E501

        return self.api_client.call_api(
            '/crypto/prices/technicals/kst', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ApiResponseCryptoKnowSureThing',  # noqa: E501
            auth_settings=auth_settings,
            _async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_crypto_price_technicals_macd(self, **kwargs):  # noqa: E501
        """Moving Average Convergence Divergence  # noqa: E501

        Returns the Moving Average Convergence Divergence values of Crypto Currency Prices for a Crypto Currency Pair  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_crypto_price_technicals_macd(_async=True)
        >>> result = thread.get()

        :param async bool
        :param str pair: Return technicals for the given Crypto Currency Pair.
        :param str exchange: Return technicals for a Crypto Currency on the given Crypto Exchange.
        :param str currency: Return technicals for the given Crypto Currency.
        :param int fast_period: The number of observations, per period, to calculate the fast moving Exponential Moving Average for Moving Average Convergence Divergence.
        :param int slow_period: The number of observations, per period, to calculate the slow moving Exponential Moving Average for Moving Average Convergence Divergence.
        :param int signal_period: The number of observations, per period, to calculate the signal line for Moving Average Convergence Divergence.
        :param str price_key: The Crypto Currency Price field to use when calculating Moving Average Convergence Divergence.
        :param str timeframe: The time interval for the prices when calculating technicals.
        :param str timezone: Return technical date/times in this timezone, also interpret start/end date/time parameters in this timezone.
        :param date start_date: Return technicals on or after this date.
        :param str start_time: Return technicals at or after this time (24-hour).
        :param date end_date: Return technicals on or before this date.
        :param str end_time: Return technicals at or before this time (24-hour).
        :param int page_size: An integer greater than or equal to 1 for specifying the number of results on each page.
        :param str next_page: Gets the next page of data from a previous API call
        :return: ApiResponseCryptoMovingAverageConvergenceDivergence
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_crypto_price_technicals_macd_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_crypto_price_technicals_macd_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_crypto_price_technicals_macd_with_http_info(self, **kwargs):  # noqa: E501
        """Moving Average Convergence Divergence  # noqa: E501

        Returns the Moving Average Convergence Divergence values of Crypto Currency Prices for a Crypto Currency Pair  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_crypto_price_technicals_macd_with_http_info(_async=True)
        >>> result = thread.get()

        :param async bool
        :param str pair: Return technicals for the given Crypto Currency Pair.
        :param str exchange: Return technicals for a Crypto Currency on the given Crypto Exchange.
        :param str currency: Return technicals for the given Crypto Currency.
        :param int fast_period: The number of observations, per period, to calculate the fast moving Exponential Moving Average for Moving Average Convergence Divergence.
        :param int slow_period: The number of observations, per period, to calculate the slow moving Exponential Moving Average for Moving Average Convergence Divergence.
        :param int signal_period: The number of observations, per period, to calculate the signal line for Moving Average Convergence Divergence.
        :param str price_key: The Crypto Currency Price field to use when calculating Moving Average Convergence Divergence.
        :param str timeframe: The time interval for the prices when calculating technicals.
        :param str timezone: Return technical date/times in this timezone, also interpret start/end date/time parameters in this timezone.
        :param date start_date: Return technicals on or after this date.
        :param str start_time: Return technicals at or after this time (24-hour).
        :param date end_date: Return technicals on or before this date.
        :param str end_time: Return technicals at or before this time (24-hour).
        :param int page_size: An integer greater than or equal to 1 for specifying the number of results on each page.
        :param str next_page: Gets the next page of data from a previous API call
        :return: ApiResponseCryptoMovingAverageConvergenceDivergence
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['pair', 'exchange', 'currency', 'fast_period', 'slow_period', 'signal_period', 'price_key', 'timeframe', 'timezone', 'start_date', 'start_time', 'end_date', 'end_time', 'page_size', 'next_page']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_crypto_price_technicals_macd" % key
                )
            params[key] = val
        del params['kwargs']

        if 'slow_period' in params and params['slow_period'] < 3:  # noqa: E501
            raise ValueError("Invalid value for parameter `slow_period` when calling `get_crypto_price_technicals_macd`, must be a value greater than or equal to `3`")  # noqa: E501
        if 'signal_period' in params and params['signal_period'] < 3:  # noqa: E501
            raise ValueError("Invalid value for parameter `signal_period` when calling `get_crypto_price_technicals_macd`, must be a value greater than or equal to `3`")  # noqa: E501
        if 'page_size' in params and params['page_size'] > 10000:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `get_crypto_price_technicals_macd`, must be a value less than or equal to `10000`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'pair' in params:
            query_params.append(('pair', params['pair']))  # noqa: E501
        if 'exchange' in params:
            query_params.append(('exchange', params['exchange']))  # noqa: E501
        if 'currency' in params:
            query_params.append(('currency', params['currency']))  # noqa: E501
        if 'fast_period' in params:
            query_params.append(('fast_period', params['fast_period']))  # noqa: E501
        if 'slow_period' in params:
            query_params.append(('slow_period', params['slow_period']))  # noqa: E501
        if 'signal_period' in params:
            query_params.append(('signal_period', params['signal_period']))  # noqa: E501
        if 'price_key' in params:
            query_params.append(('price_key', params['price_key']))  # noqa: E501
        if 'timeframe' in params:
            query_params.append(('timeframe', params['timeframe']))  # noqa: E501
        if 'timezone' in params:
            query_params.append(('timezone', params['timezone']))  # noqa: E501
        if 'start_date' in params:
            query_params.append(('start_date', params['start_date']))  # noqa: E501
        if 'start_time' in params:
            query_params.append(('start_time', params['start_time']))  # noqa: E501
        if 'end_date' in params:
            query_params.append(('end_date', params['end_date']))  # noqa: E501
        if 'end_time' in params:
            query_params.append(('end_time', params['end_time']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'next_page' in params:
            query_params.append(('next_page', params['next_page']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth']  # noqa: E501

        return self.api_client.call_api(
            '/crypto/prices/technicals/macd', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ApiResponseCryptoMovingAverageConvergenceDivergence',  # noqa: E501
            auth_settings=auth_settings,
            _async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_crypto_price_technicals_mfi(self, **kwargs):  # noqa: E501
        """Money Flow Index  # noqa: E501

        Returns the Money Flow Index values of Crypto Currency Prices for a Crypto Currency Pair  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_crypto_price_technicals_mfi(_async=True)
        >>> result = thread.get()

        :param async bool
        :param str pair: Return technicals for the given Crypto Currency Pair.
        :param str exchange: Return technicals for a Crypto Currency on the given Crypto Exchange.
        :param str currency: Return technicals for the given Crypto Currency.
        :param int period: The number of observations, per period, to calculate Money Flow Index.
        :param str timeframe: The time interval for the prices when calculating technicals.
        :param str timezone: Return technical date/times in this timezone, also interpret start/end date/time parameters in this timezone.
        :param date start_date: Return technicals on or after this date.
        :param str start_time: Return technicals at or after this time (24-hour).
        :param date end_date: Return technicals on or before this date.
        :param str end_time: Return technicals at or before this time (24-hour).
        :param int page_size: An integer greater than or equal to 1 for specifying the number of results on each page.
        :param str next_page: Gets the next page of data from a previous API call
        :return: ApiResponseCryptoMoneyFlowIndex
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_crypto_price_technicals_mfi_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_crypto_price_technicals_mfi_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_crypto_price_technicals_mfi_with_http_info(self, **kwargs):  # noqa: E501
        """Money Flow Index  # noqa: E501

        Returns the Money Flow Index values of Crypto Currency Prices for a Crypto Currency Pair  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_crypto_price_technicals_mfi_with_http_info(_async=True)
        >>> result = thread.get()

        :param async bool
        :param str pair: Return technicals for the given Crypto Currency Pair.
        :param str exchange: Return technicals for a Crypto Currency on the given Crypto Exchange.
        :param str currency: Return technicals for the given Crypto Currency.
        :param int period: The number of observations, per period, to calculate Money Flow Index.
        :param str timeframe: The time interval for the prices when calculating technicals.
        :param str timezone: Return technical date/times in this timezone, also interpret start/end date/time parameters in this timezone.
        :param date start_date: Return technicals on or after this date.
        :param str start_time: Return technicals at or after this time (24-hour).
        :param date end_date: Return technicals on or before this date.
        :param str end_time: Return technicals at or before this time (24-hour).
        :param int page_size: An integer greater than or equal to 1 for specifying the number of results on each page.
        :param str next_page: Gets the next page of data from a previous API call
        :return: ApiResponseCryptoMoneyFlowIndex
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['pair', 'exchange', 'currency', 'period', 'timeframe', 'timezone', 'start_date', 'start_time', 'end_date', 'end_time', 'page_size', 'next_page']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_crypto_price_technicals_mfi" % key
                )
            params[key] = val
        del params['kwargs']

        if 'period' in params and params['period'] < 4:  # noqa: E501
            raise ValueError("Invalid value for parameter `period` when calling `get_crypto_price_technicals_mfi`, must be a value greater than or equal to `4`")  # noqa: E501
        if 'page_size' in params and params['page_size'] > 10000:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `get_crypto_price_technicals_mfi`, must be a value less than or equal to `10000`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'pair' in params:
            query_params.append(('pair', params['pair']))  # noqa: E501
        if 'exchange' in params:
            query_params.append(('exchange', params['exchange']))  # noqa: E501
        if 'currency' in params:
            query_params.append(('currency', params['currency']))  # noqa: E501
        if 'period' in params:
            query_params.append(('period', params['period']))  # noqa: E501
        if 'timeframe' in params:
            query_params.append(('timeframe', params['timeframe']))  # noqa: E501
        if 'timezone' in params:
            query_params.append(('timezone', params['timezone']))  # noqa: E501
        if 'start_date' in params:
            query_params.append(('start_date', params['start_date']))  # noqa: E501
        if 'start_time' in params:
            query_params.append(('start_time', params['start_time']))  # noqa: E501
        if 'end_date' in params:
            query_params.append(('end_date', params['end_date']))  # noqa: E501
        if 'end_time' in params:
            query_params.append(('end_time', params['end_time']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'next_page' in params:
            query_params.append(('next_page', params['next_page']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth']  # noqa: E501

        return self.api_client.call_api(
            '/crypto/prices/technicals/mfi', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ApiResponseCryptoMoneyFlowIndex',  # noqa: E501
            auth_settings=auth_settings,
            _async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_crypto_price_technicals_mi(self, **kwargs):  # noqa: E501
        """Mass Index  # noqa: E501

        Returns the Mass Index values of Crypto Currency Prices for a Crypto Currency Pair  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_crypto_price_technicals_mi(_async=True)
        >>> result = thread.get()

        :param async bool
        :param str pair: Return technicals for the given Crypto Currency Pair.
        :param str exchange: Return technicals for a Crypto Currency on the given Crypto Exchange.
        :param str currency: Return technicals for the given Crypto Currency.
        :param int ema_period: The number of observations, per period, to calculate the single Exponential Moving Average and the Double Exponential Moving Average for Mass Index.
        :param int sum_period: The number of observations, per period, to calculate the sum of the Exponetinal Moving Average Ratios for Mass Index.
        :param str timeframe: The time interval for the prices when calculating technicals.
        :param str timezone: Return technical date/times in this timezone, also interpret start/end date/time parameters in this timezone.
        :param date start_date: Return technicals on or after this date.
        :param str start_time: Return technicals at or after this time (24-hour).
        :param date end_date: Return technicals on or before this date.
        :param str end_time: Return technicals at or before this time (24-hour).
        :param int page_size: An integer greater than or equal to 1 for specifying the number of results on each page.
        :param str next_page: Gets the next page of data from a previous API call
        :return: ApiResponseCryptoMassIndex
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_crypto_price_technicals_mi_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_crypto_price_technicals_mi_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_crypto_price_technicals_mi_with_http_info(self, **kwargs):  # noqa: E501
        """Mass Index  # noqa: E501

        Returns the Mass Index values of Crypto Currency Prices for a Crypto Currency Pair  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_crypto_price_technicals_mi_with_http_info(_async=True)
        >>> result = thread.get()

        :param async bool
        :param str pair: Return technicals for the given Crypto Currency Pair.
        :param str exchange: Return technicals for a Crypto Currency on the given Crypto Exchange.
        :param str currency: Return technicals for the given Crypto Currency.
        :param int ema_period: The number of observations, per period, to calculate the single Exponential Moving Average and the Double Exponential Moving Average for Mass Index.
        :param int sum_period: The number of observations, per period, to calculate the sum of the Exponetinal Moving Average Ratios for Mass Index.
        :param str timeframe: The time interval for the prices when calculating technicals.
        :param str timezone: Return technical date/times in this timezone, also interpret start/end date/time parameters in this timezone.
        :param date start_date: Return technicals on or after this date.
        :param str start_time: Return technicals at or after this time (24-hour).
        :param date end_date: Return technicals on or before this date.
        :param str end_time: Return technicals at or before this time (24-hour).
        :param int page_size: An integer greater than or equal to 1 for specifying the number of results on each page.
        :param str next_page: Gets the next page of data from a previous API call
        :return: ApiResponseCryptoMassIndex
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['pair', 'exchange', 'currency', 'ema_period', 'sum_period', 'timeframe', 'timezone', 'start_date', 'start_time', 'end_date', 'end_time', 'page_size', 'next_page']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_crypto_price_technicals_mi" % key
                )
            params[key] = val
        del params['kwargs']

        if 'ema_period' in params and params['ema_period'] < 2:  # noqa: E501
            raise ValueError("Invalid value for parameter `ema_period` when calling `get_crypto_price_technicals_mi`, must be a value greater than or equal to `2`")  # noqa: E501
        if 'sum_period' in params and params['sum_period'] < 3:  # noqa: E501
            raise ValueError("Invalid value for parameter `sum_period` when calling `get_crypto_price_technicals_mi`, must be a value greater than or equal to `3`")  # noqa: E501
        if 'page_size' in params and params['page_size'] > 10000:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `get_crypto_price_technicals_mi`, must be a value less than or equal to `10000`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'pair' in params:
            query_params.append(('pair', params['pair']))  # noqa: E501
        if 'exchange' in params:
            query_params.append(('exchange', params['exchange']))  # noqa: E501
        if 'currency' in params:
            query_params.append(('currency', params['currency']))  # noqa: E501
        if 'ema_period' in params:
            query_params.append(('ema_period', params['ema_period']))  # noqa: E501
        if 'sum_period' in params:
            query_params.append(('sum_period', params['sum_period']))  # noqa: E501
        if 'timeframe' in params:
            query_params.append(('timeframe', params['timeframe']))  # noqa: E501
        if 'timezone' in params:
            query_params.append(('timezone', params['timezone']))  # noqa: E501
        if 'start_date' in params:
            query_params.append(('start_date', params['start_date']))  # noqa: E501
        if 'start_time' in params:
            query_params.append(('start_time', params['start_time']))  # noqa: E501
        if 'end_date' in params:
            query_params.append(('end_date', params['end_date']))  # noqa: E501
        if 'end_time' in params:
            query_params.append(('end_time', params['end_time']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'next_page' in params:
            query_params.append(('next_page', params['next_page']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth']  # noqa: E501

        return self.api_client.call_api(
            '/crypto/prices/technicals/mi', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ApiResponseCryptoMassIndex',  # noqa: E501
            auth_settings=auth_settings,
            _async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_crypto_price_technicals_nvi(self, **kwargs):  # noqa: E501
        """Negative Volume Index  # noqa: E501

        Returns the Negative Volume Index values of Crypto Currency Prices for a Crypto Currency Pair  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_crypto_price_technicals_nvi(_async=True)
        >>> result = thread.get()

        :param async bool
        :param str pair: Return technicals for the given Crypto Currency Pair.
        :param str exchange: Return technicals for a Crypto Currency on the given Crypto Exchange.
        :param str currency: Return technicals for the given Crypto Currency.
        :param str timeframe: The time interval for the prices when calculating technicals.
        :param str timezone: Return technical date/times in this timezone, also interpret start/end date/time parameters in this timezone.
        :param date start_date: Return technicals on or after this date.
        :param str start_time: Return technicals at or after this time (24-hour).
        :param date end_date: Return technicals on or before this date.
        :param str end_time: Return technicals at or before this time (24-hour).
        :param int page_size: An integer greater than or equal to 1 for specifying the number of results on each page.
        :param str next_page: Gets the next page of data from a previous API call
        :return: ApiResponseCryptoNegativeVolumeIndex
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_crypto_price_technicals_nvi_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_crypto_price_technicals_nvi_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_crypto_price_technicals_nvi_with_http_info(self, **kwargs):  # noqa: E501
        """Negative Volume Index  # noqa: E501

        Returns the Negative Volume Index values of Crypto Currency Prices for a Crypto Currency Pair  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_crypto_price_technicals_nvi_with_http_info(_async=True)
        >>> result = thread.get()

        :param async bool
        :param str pair: Return technicals for the given Crypto Currency Pair.
        :param str exchange: Return technicals for a Crypto Currency on the given Crypto Exchange.
        :param str currency: Return technicals for the given Crypto Currency.
        :param str timeframe: The time interval for the prices when calculating technicals.
        :param str timezone: Return technical date/times in this timezone, also interpret start/end date/time parameters in this timezone.
        :param date start_date: Return technicals on or after this date.
        :param str start_time: Return technicals at or after this time (24-hour).
        :param date end_date: Return technicals on or before this date.
        :param str end_time: Return technicals at or before this time (24-hour).
        :param int page_size: An integer greater than or equal to 1 for specifying the number of results on each page.
        :param str next_page: Gets the next page of data from a previous API call
        :return: ApiResponseCryptoNegativeVolumeIndex
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['pair', 'exchange', 'currency', 'timeframe', 'timezone', 'start_date', 'start_time', 'end_date', 'end_time', 'page_size', 'next_page']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_crypto_price_technicals_nvi" % key
                )
            params[key] = val
        del params['kwargs']

        if 'page_size' in params and params['page_size'] > 10000:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `get_crypto_price_technicals_nvi`, must be a value less than or equal to `10000`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'pair' in params:
            query_params.append(('pair', params['pair']))  # noqa: E501
        if 'exchange' in params:
            query_params.append(('exchange', params['exchange']))  # noqa: E501
        if 'currency' in params:
            query_params.append(('currency', params['currency']))  # noqa: E501
        if 'timeframe' in params:
            query_params.append(('timeframe', params['timeframe']))  # noqa: E501
        if 'timezone' in params:
            query_params.append(('timezone', params['timezone']))  # noqa: E501
        if 'start_date' in params:
            query_params.append(('start_date', params['start_date']))  # noqa: E501
        if 'start_time' in params:
            query_params.append(('start_time', params['start_time']))  # noqa: E501
        if 'end_date' in params:
            query_params.append(('end_date', params['end_date']))  # noqa: E501
        if 'end_time' in params:
            query_params.append(('end_time', params['end_time']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'next_page' in params:
            query_params.append(('next_page', params['next_page']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth']  # noqa: E501

        return self.api_client.call_api(
            '/crypto/prices/technicals/nvi', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ApiResponseCryptoNegativeVolumeIndex',  # noqa: E501
            auth_settings=auth_settings,
            _async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_crypto_price_technicals_obv(self, **kwargs):  # noqa: E501
        """On-balance Volume  # noqa: E501

        Returns the On-balance Volume values of Crypto Currency Prices for a Crypto Currency Pair  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_crypto_price_technicals_obv(_async=True)
        >>> result = thread.get()

        :param async bool
        :param str pair: Return technicals for the given Crypto Currency Pair.
        :param str exchange: Return technicals for a Crypto Currency on the given Crypto Exchange.
        :param str currency: Return technicals for the given Crypto Currency.
        :param str timeframe: The time interval for the prices when calculating technicals.
        :param str timezone: Return technical date/times in this timezone, also interpret start/end date/time parameters in this timezone.
        :param date start_date: Return technicals on or after this date.
        :param str start_time: Return technicals at or after this time (24-hour).
        :param date end_date: Return technicals on or before this date.
        :param str end_time: Return technicals at or before this time (24-hour).
        :param int page_size: An integer greater than or equal to 1 for specifying the number of results on each page.
        :param str next_page: Gets the next page of data from a previous API call
        :return: ApiResponseCryptoOnBalanceVolume
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_crypto_price_technicals_obv_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_crypto_price_technicals_obv_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_crypto_price_technicals_obv_with_http_info(self, **kwargs):  # noqa: E501
        """On-balance Volume  # noqa: E501

        Returns the On-balance Volume values of Crypto Currency Prices for a Crypto Currency Pair  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_crypto_price_technicals_obv_with_http_info(_async=True)
        >>> result = thread.get()

        :param async bool
        :param str pair: Return technicals for the given Crypto Currency Pair.
        :param str exchange: Return technicals for a Crypto Currency on the given Crypto Exchange.
        :param str currency: Return technicals for the given Crypto Currency.
        :param str timeframe: The time interval for the prices when calculating technicals.
        :param str timezone: Return technical date/times in this timezone, also interpret start/end date/time parameters in this timezone.
        :param date start_date: Return technicals on or after this date.
        :param str start_time: Return technicals at or after this time (24-hour).
        :param date end_date: Return technicals on or before this date.
        :param str end_time: Return technicals at or before this time (24-hour).
        :param int page_size: An integer greater than or equal to 1 for specifying the number of results on each page.
        :param str next_page: Gets the next page of data from a previous API call
        :return: ApiResponseCryptoOnBalanceVolume
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['pair', 'exchange', 'currency', 'timeframe', 'timezone', 'start_date', 'start_time', 'end_date', 'end_time', 'page_size', 'next_page']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_crypto_price_technicals_obv" % key
                )
            params[key] = val
        del params['kwargs']

        if 'page_size' in params and params['page_size'] > 10000:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `get_crypto_price_technicals_obv`, must be a value less than or equal to `10000`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'pair' in params:
            query_params.append(('pair', params['pair']))  # noqa: E501
        if 'exchange' in params:
            query_params.append(('exchange', params['exchange']))  # noqa: E501
        if 'currency' in params:
            query_params.append(('currency', params['currency']))  # noqa: E501
        if 'timeframe' in params:
            query_params.append(('timeframe', params['timeframe']))  # noqa: E501
        if 'timezone' in params:
            query_params.append(('timezone', params['timezone']))  # noqa: E501
        if 'start_date' in params:
            query_params.append(('start_date', params['start_date']))  # noqa: E501
        if 'start_time' in params:
            query_params.append(('start_time', params['start_time']))  # noqa: E501
        if 'end_date' in params:
            query_params.append(('end_date', params['end_date']))  # noqa: E501
        if 'end_time' in params:
            query_params.append(('end_time', params['end_time']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'next_page' in params:
            query_params.append(('next_page', params['next_page']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth']  # noqa: E501

        return self.api_client.call_api(
            '/crypto/prices/technicals/obv', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ApiResponseCryptoOnBalanceVolume',  # noqa: E501
            auth_settings=auth_settings,
            _async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_crypto_price_technicals_obv_mean(self, **kwargs):  # noqa: E501
        """On-balance Volume Mean  # noqa: E501

        Returns the On-balance Volume Mean values of Crypto Currency Prices for a Crypto Currency Pair  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_crypto_price_technicals_obv_mean(_async=True)
        >>> result = thread.get()

        :param async bool
        :param str pair: Return technicals for the given Crypto Currency Pair.
        :param str exchange: Return technicals for a Crypto Currency on the given Crypto Exchange.
        :param str currency: Return technicals for the given Crypto Currency.
        :param int period: The number of observations, per period, to calculate On-balance Volume Mean.
        :param str timeframe: The time interval for the prices when calculating technicals.
        :param str timezone: Return technical date/times in this timezone, also interpret start/end date/time parameters in this timezone.
        :param date start_date: Return technicals on or after this date.
        :param str start_time: Return technicals at or after this time (24-hour).
        :param date end_date: Return technicals on or before this date.
        :param str end_time: Return technicals at or before this time (24-hour).
        :param int page_size: An integer greater than or equal to 1 for specifying the number of results on each page.
        :param str next_page: Gets the next page of data from a previous API call
        :return: ApiResponseCryptoOnBalanceVolumeMean
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_crypto_price_technicals_obv_mean_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_crypto_price_technicals_obv_mean_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_crypto_price_technicals_obv_mean_with_http_info(self, **kwargs):  # noqa: E501
        """On-balance Volume Mean  # noqa: E501

        Returns the On-balance Volume Mean values of Crypto Currency Prices for a Crypto Currency Pair  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_crypto_price_technicals_obv_mean_with_http_info(_async=True)
        >>> result = thread.get()

        :param async bool
        :param str pair: Return technicals for the given Crypto Currency Pair.
        :param str exchange: Return technicals for a Crypto Currency on the given Crypto Exchange.
        :param str currency: Return technicals for the given Crypto Currency.
        :param int period: The number of observations, per period, to calculate On-balance Volume Mean.
        :param str timeframe: The time interval for the prices when calculating technicals.
        :param str timezone: Return technical date/times in this timezone, also interpret start/end date/time parameters in this timezone.
        :param date start_date: Return technicals on or after this date.
        :param str start_time: Return technicals at or after this time (24-hour).
        :param date end_date: Return technicals on or before this date.
        :param str end_time: Return technicals at or before this time (24-hour).
        :param int page_size: An integer greater than or equal to 1 for specifying the number of results on each page.
        :param str next_page: Gets the next page of data from a previous API call
        :return: ApiResponseCryptoOnBalanceVolumeMean
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['pair', 'exchange', 'currency', 'period', 'timeframe', 'timezone', 'start_date', 'start_time', 'end_date', 'end_time', 'page_size', 'next_page']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_crypto_price_technicals_obv_mean" % key
                )
            params[key] = val
        del params['kwargs']

        if 'period' in params and params['period'] < 4:  # noqa: E501
            raise ValueError("Invalid value for parameter `period` when calling `get_crypto_price_technicals_obv_mean`, must be a value greater than or equal to `4`")  # noqa: E501
        if 'page_size' in params and params['page_size'] > 10000:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `get_crypto_price_technicals_obv_mean`, must be a value less than or equal to `10000`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'pair' in params:
            query_params.append(('pair', params['pair']))  # noqa: E501
        if 'exchange' in params:
            query_params.append(('exchange', params['exchange']))  # noqa: E501
        if 'currency' in params:
            query_params.append(('currency', params['currency']))  # noqa: E501
        if 'period' in params:
            query_params.append(('period', params['period']))  # noqa: E501
        if 'timeframe' in params:
            query_params.append(('timeframe', params['timeframe']))  # noqa: E501
        if 'timezone' in params:
            query_params.append(('timezone', params['timezone']))  # noqa: E501
        if 'start_date' in params:
            query_params.append(('start_date', params['start_date']))  # noqa: E501
        if 'start_time' in params:
            query_params.append(('start_time', params['start_time']))  # noqa: E501
        if 'end_date' in params:
            query_params.append(('end_date', params['end_date']))  # noqa: E501
        if 'end_time' in params:
            query_params.append(('end_time', params['end_time']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'next_page' in params:
            query_params.append(('next_page', params['next_page']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth']  # noqa: E501

        return self.api_client.call_api(
            '/crypto/prices/technicals/obv_mean', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ApiResponseCryptoOnBalanceVolumeMean',  # noqa: E501
            auth_settings=auth_settings,
            _async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_crypto_price_technicals_rsi(self, **kwargs):  # noqa: E501
        """Relative Strength Index  # noqa: E501

        Returns the Relative Strength Index values of Crypto Currency Prices for a Crypto Currency Pair  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_crypto_price_technicals_rsi(_async=True)
        >>> result = thread.get()

        :param async bool
        :param str pair: Return technicals for the given Crypto Currency Pair.
        :param str exchange: Return technicals for a Crypto Currency on the given Crypto Exchange.
        :param str currency: Return technicals for the given Crypto Currency.
        :param int period: The number of observations, per period, to calculate Relative Strength Index.
        :param str price_key: The Crypto Currency Price field to use when calculating Relative Strength Index.
        :param str timeframe: The time interval for the prices when calculating technicals.
        :param str timezone: Return technical date/times in this timezone, also interpret start/end date/time parameters in this timezone.
        :param date start_date: Return technicals on or after this date.
        :param str start_time: Return technicals at or after this time (24-hour).
        :param date end_date: Return technicals on or before this date.
        :param str end_time: Return technicals at or before this time (24-hour).
        :param int page_size: An integer greater than or equal to 1 for specifying the number of results on each page.
        :param str next_page: Gets the next page of data from a previous API call
        :return: ApiResponseCryptoRelativeStrengthIndex
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_crypto_price_technicals_rsi_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_crypto_price_technicals_rsi_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_crypto_price_technicals_rsi_with_http_info(self, **kwargs):  # noqa: E501
        """Relative Strength Index  # noqa: E501

        Returns the Relative Strength Index values of Crypto Currency Prices for a Crypto Currency Pair  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_crypto_price_technicals_rsi_with_http_info(_async=True)
        >>> result = thread.get()

        :param async bool
        :param str pair: Return technicals for the given Crypto Currency Pair.
        :param str exchange: Return technicals for a Crypto Currency on the given Crypto Exchange.
        :param str currency: Return technicals for the given Crypto Currency.
        :param int period: The number of observations, per period, to calculate Relative Strength Index.
        :param str price_key: The Crypto Currency Price field to use when calculating Relative Strength Index.
        :param str timeframe: The time interval for the prices when calculating technicals.
        :param str timezone: Return technical date/times in this timezone, also interpret start/end date/time parameters in this timezone.
        :param date start_date: Return technicals on or after this date.
        :param str start_time: Return technicals at or after this time (24-hour).
        :param date end_date: Return technicals on or before this date.
        :param str end_time: Return technicals at or before this time (24-hour).
        :param int page_size: An integer greater than or equal to 1 for specifying the number of results on each page.
        :param str next_page: Gets the next page of data from a previous API call
        :return: ApiResponseCryptoRelativeStrengthIndex
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['pair', 'exchange', 'currency', 'period', 'price_key', 'timeframe', 'timezone', 'start_date', 'start_time', 'end_date', 'end_time', 'page_size', 'next_page']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_crypto_price_technicals_rsi" % key
                )
            params[key] = val
        del params['kwargs']

        if 'period' in params and params['period'] < 4:  # noqa: E501
            raise ValueError("Invalid value for parameter `period` when calling `get_crypto_price_technicals_rsi`, must be a value greater than or equal to `4`")  # noqa: E501
        if 'page_size' in params and params['page_size'] > 10000:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `get_crypto_price_technicals_rsi`, must be a value less than or equal to `10000`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'pair' in params:
            query_params.append(('pair', params['pair']))  # noqa: E501
        if 'exchange' in params:
            query_params.append(('exchange', params['exchange']))  # noqa: E501
        if 'currency' in params:
            query_params.append(('currency', params['currency']))  # noqa: E501
        if 'period' in params:
            query_params.append(('period', params['period']))  # noqa: E501
        if 'price_key' in params:
            query_params.append(('price_key', params['price_key']))  # noqa: E501
        if 'timeframe' in params:
            query_params.append(('timeframe', params['timeframe']))  # noqa: E501
        if 'timezone' in params:
            query_params.append(('timezone', params['timezone']))  # noqa: E501
        if 'start_date' in params:
            query_params.append(('start_date', params['start_date']))  # noqa: E501
        if 'start_time' in params:
            query_params.append(('start_time', params['start_time']))  # noqa: E501
        if 'end_date' in params:
            query_params.append(('end_date', params['end_date']))  # noqa: E501
        if 'end_time' in params:
            query_params.append(('end_time', params['end_time']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'next_page' in params:
            query_params.append(('next_page', params['next_page']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth']  # noqa: E501

        return self.api_client.call_api(
            '/crypto/prices/technicals/rsi', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ApiResponseCryptoRelativeStrengthIndex',  # noqa: E501
            auth_settings=auth_settings,
            _async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_crypto_price_technicals_sma(self, **kwargs):  # noqa: E501
        """Simple Moving Average  # noqa: E501

        Returns the Simple Moving Average values of Crypto Currency Prices for a Crypto Currency Pair  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_crypto_price_technicals_sma(_async=True)
        >>> result = thread.get()

        :param async bool
        :param str pair: Return technicals for the given Crypto Currency Pair.
        :param str exchange: Return technicals for a Crypto Currency on the given Crypto Exchange.
        :param str currency: Return technicals for the given Crypto Currency.
        :param int period: The number of observations, per period, to calculate Simple Moving Average.
        :param str price_key: The Crypto Currency Price field to use when calculating Simple Moving Average.
        :param str timeframe: The time interval for the prices when calculating technicals.
        :param str timezone: Return technical date/times in this timezone, also interpret start/end date/time parameters in this timezone.
        :param date start_date: Return technicals on or after this date.
        :param str start_time: Return technicals at or after this time (24-hour).
        :param date end_date: Return technicals on or before this date.
        :param str end_time: Return technicals at or before this time (24-hour).
        :param int page_size: An integer greater than or equal to 1 for specifying the number of results on each page.
        :param str next_page: Gets the next page of data from a previous API call
        :return: ApiResponseCryptoSimpleMovingAverage
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_crypto_price_technicals_sma_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_crypto_price_technicals_sma_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_crypto_price_technicals_sma_with_http_info(self, **kwargs):  # noqa: E501
        """Simple Moving Average  # noqa: E501

        Returns the Simple Moving Average values of Crypto Currency Prices for a Crypto Currency Pair  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_crypto_price_technicals_sma_with_http_info(_async=True)
        >>> result = thread.get()

        :param async bool
        :param str pair: Return technicals for the given Crypto Currency Pair.
        :param str exchange: Return technicals for a Crypto Currency on the given Crypto Exchange.
        :param str currency: Return technicals for the given Crypto Currency.
        :param int period: The number of observations, per period, to calculate Simple Moving Average.
        :param str price_key: The Crypto Currency Price field to use when calculating Simple Moving Average.
        :param str timeframe: The time interval for the prices when calculating technicals.
        :param str timezone: Return technical date/times in this timezone, also interpret start/end date/time parameters in this timezone.
        :param date start_date: Return technicals on or after this date.
        :param str start_time: Return technicals at or after this time (24-hour).
        :param date end_date: Return technicals on or before this date.
        :param str end_time: Return technicals at or before this time (24-hour).
        :param int page_size: An integer greater than or equal to 1 for specifying the number of results on each page.
        :param str next_page: Gets the next page of data from a previous API call
        :return: ApiResponseCryptoSimpleMovingAverage
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['pair', 'exchange', 'currency', 'period', 'price_key', 'timeframe', 'timezone', 'start_date', 'start_time', 'end_date', 'end_time', 'page_size', 'next_page']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_crypto_price_technicals_sma" % key
                )
            params[key] = val
        del params['kwargs']

        if 'period' in params and params['period'] < 5:  # noqa: E501
            raise ValueError("Invalid value for parameter `period` when calling `get_crypto_price_technicals_sma`, must be a value greater than or equal to `5`")  # noqa: E501
        if 'page_size' in params and params['page_size'] > 10000:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `get_crypto_price_technicals_sma`, must be a value less than or equal to `10000`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'pair' in params:
            query_params.append(('pair', params['pair']))  # noqa: E501
        if 'exchange' in params:
            query_params.append(('exchange', params['exchange']))  # noqa: E501
        if 'currency' in params:
            query_params.append(('currency', params['currency']))  # noqa: E501
        if 'period' in params:
            query_params.append(('period', params['period']))  # noqa: E501
        if 'price_key' in params:
            query_params.append(('price_key', params['price_key']))  # noqa: E501
        if 'timeframe' in params:
            query_params.append(('timeframe', params['timeframe']))  # noqa: E501
        if 'timezone' in params:
            query_params.append(('timezone', params['timezone']))  # noqa: E501
        if 'start_date' in params:
            query_params.append(('start_date', params['start_date']))  # noqa: E501
        if 'start_time' in params:
            query_params.append(('start_time', params['start_time']))  # noqa: E501
        if 'end_date' in params:
            query_params.append(('end_date', params['end_date']))  # noqa: E501
        if 'end_time' in params:
            query_params.append(('end_time', params['end_time']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'next_page' in params:
            query_params.append(('next_page', params['next_page']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth']  # noqa: E501

        return self.api_client.call_api(
            '/crypto/prices/technicals/sma', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ApiResponseCryptoSimpleMovingAverage',  # noqa: E501
            auth_settings=auth_settings,
            _async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_crypto_price_technicals_sr(self, **kwargs):  # noqa: E501
        """Stochastic Oscillator  # noqa: E501

        Returns the Stochastic Oscillator values of Crypto Currency Prices for a Crypto Currency Pair  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_crypto_price_technicals_sr(_async=True)
        >>> result = thread.get()

        :param async bool
        :param str pair: Return technicals for the given Crypto Currency Pair.
        :param str exchange: Return technicals for a Crypto Currency on the given Crypto Exchange.
        :param str currency: Return technicals for the given Crypto Currency.
        :param int period: The number of observations, per period, to calculate %K of Stochastic Oscillator.
        :param int signal_period: The number of observations, per period, to calculate the %D (the Simple Moving Average of %K) as a signal line for Stochastic Oscillator.
        :param str timeframe: The time interval for the prices when calculating technicals.
        :param str timezone: Return technical date/times in this timezone, also interpret start/end date/time parameters in this timezone.
        :param date start_date: Return technicals on or after this date.
        :param str start_time: Return technicals at or after this time (24-hour).
        :param date end_date: Return technicals on or before this date.
        :param str end_time: Return technicals at or before this time (24-hour).
        :param int page_size: An integer greater than or equal to 1 for specifying the number of results on each page.
        :param str next_page: Gets the next page of data from a previous API call
        :return: ApiResponseCryptoStochasticOscillator
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_crypto_price_technicals_sr_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_crypto_price_technicals_sr_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_crypto_price_technicals_sr_with_http_info(self, **kwargs):  # noqa: E501
        """Stochastic Oscillator  # noqa: E501

        Returns the Stochastic Oscillator values of Crypto Currency Prices for a Crypto Currency Pair  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_crypto_price_technicals_sr_with_http_info(_async=True)
        >>> result = thread.get()

        :param async bool
        :param str pair: Return technicals for the given Crypto Currency Pair.
        :param str exchange: Return technicals for a Crypto Currency on the given Crypto Exchange.
        :param str currency: Return technicals for the given Crypto Currency.
        :param int period: The number of observations, per period, to calculate %K of Stochastic Oscillator.
        :param int signal_period: The number of observations, per period, to calculate the %D (the Simple Moving Average of %K) as a signal line for Stochastic Oscillator.
        :param str timeframe: The time interval for the prices when calculating technicals.
        :param str timezone: Return technical date/times in this timezone, also interpret start/end date/time parameters in this timezone.
        :param date start_date: Return technicals on or after this date.
        :param str start_time: Return technicals at or after this time (24-hour).
        :param date end_date: Return technicals on or before this date.
        :param str end_time: Return technicals at or before this time (24-hour).
        :param int page_size: An integer greater than or equal to 1 for specifying the number of results on each page.
        :param str next_page: Gets the next page of data from a previous API call
        :return: ApiResponseCryptoStochasticOscillator
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['pair', 'exchange', 'currency', 'period', 'signal_period', 'timeframe', 'timezone', 'start_date', 'start_time', 'end_date', 'end_time', 'page_size', 'next_page']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_crypto_price_technicals_sr" % key
                )
            params[key] = val
        del params['kwargs']

        if 'period' in params and params['period'] < 3:  # noqa: E501
            raise ValueError("Invalid value for parameter `period` when calling `get_crypto_price_technicals_sr`, must be a value greater than or equal to `3`")  # noqa: E501
        if 'signal_period' in params and params['signal_period'] < 3:  # noqa: E501
            raise ValueError("Invalid value for parameter `signal_period` when calling `get_crypto_price_technicals_sr`, must be a value greater than or equal to `3`")  # noqa: E501
        if 'page_size' in params and params['page_size'] > 10000:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `get_crypto_price_technicals_sr`, must be a value less than or equal to `10000`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'pair' in params:
            query_params.append(('pair', params['pair']))  # noqa: E501
        if 'exchange' in params:
            query_params.append(('exchange', params['exchange']))  # noqa: E501
        if 'currency' in params:
            query_params.append(('currency', params['currency']))  # noqa: E501
        if 'period' in params:
            query_params.append(('period', params['period']))  # noqa: E501
        if 'signal_period' in params:
            query_params.append(('signal_period', params['signal_period']))  # noqa: E501
        if 'timeframe' in params:
            query_params.append(('timeframe', params['timeframe']))  # noqa: E501
        if 'timezone' in params:
            query_params.append(('timezone', params['timezone']))  # noqa: E501
        if 'start_date' in params:
            query_params.append(('start_date', params['start_date']))  # noqa: E501
        if 'start_time' in params:
            query_params.append(('start_time', params['start_time']))  # noqa: E501
        if 'end_date' in params:
            query_params.append(('end_date', params['end_date']))  # noqa: E501
        if 'end_time' in params:
            query_params.append(('end_time', params['end_time']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'next_page' in params:
            query_params.append(('next_page', params['next_page']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth']  # noqa: E501

        return self.api_client.call_api(
            '/crypto/prices/technicals/sr', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ApiResponseCryptoStochasticOscillator',  # noqa: E501
            auth_settings=auth_settings,
            _async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_crypto_price_technicals_trix(self, **kwargs):  # noqa: E501
        """Triple Exponential Average  # noqa: E501

        Returns the Simple Moving Average values of Crypto Currency Prices for a Crypto Currency Pair  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_crypto_price_technicals_trix(_async=True)
        >>> result = thread.get()

        :param async bool
        :param str pair: Return technicals for the given Crypto Currency Pair.
        :param str exchange: Return technicals for a Crypto Currency on the given Crypto Exchange.
        :param str currency: Return technicals for the given Crypto Currency.
        :param int period: The number of observations, per period, to calculate Exponential Moving Average for Triple Exponential Average.
        :param str timeframe: The time interval for the prices when calculating technicals.
        :param str timezone: Return technical date/times in this timezone, also interpret start/end date/time parameters in this timezone.
        :param date start_date: Return technicals on or after this date.
        :param str start_time: Return technicals at or after this time (24-hour).
        :param date end_date: Return technicals on or before this date.
        :param str end_time: Return technicals at or before this time (24-hour).
        :param int page_size: An integer greater than or equal to 1 for specifying the number of results on each page.
        :param str next_page: Gets the next page of data from a previous API call
        :return: ApiResponseCryptoTripleExponentialAverage
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_crypto_price_technicals_trix_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_crypto_price_technicals_trix_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_crypto_price_technicals_trix_with_http_info(self, **kwargs):  # noqa: E501
        """Triple Exponential Average  # noqa: E501

        Returns the Simple Moving Average values of Crypto Currency Prices for a Crypto Currency Pair  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_crypto_price_technicals_trix_with_http_info(_async=True)
        >>> result = thread.get()

        :param async bool
        :param str pair: Return technicals for the given Crypto Currency Pair.
        :param str exchange: Return technicals for a Crypto Currency on the given Crypto Exchange.
        :param str currency: Return technicals for the given Crypto Currency.
        :param int period: The number of observations, per period, to calculate Exponential Moving Average for Triple Exponential Average.
        :param str timeframe: The time interval for the prices when calculating technicals.
        :param str timezone: Return technical date/times in this timezone, also interpret start/end date/time parameters in this timezone.
        :param date start_date: Return technicals on or after this date.
        :param str start_time: Return technicals at or after this time (24-hour).
        :param date end_date: Return technicals on or before this date.
        :param str end_time: Return technicals at or before this time (24-hour).
        :param int page_size: An integer greater than or equal to 1 for specifying the number of results on each page.
        :param str next_page: Gets the next page of data from a previous API call
        :return: ApiResponseCryptoTripleExponentialAverage
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['pair', 'exchange', 'currency', 'period', 'timeframe', 'timezone', 'start_date', 'start_time', 'end_date', 'end_time', 'page_size', 'next_page']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_crypto_price_technicals_trix" % key
                )
            params[key] = val
        del params['kwargs']

        if 'period' in params and params['period'] < 2:  # noqa: E501
            raise ValueError("Invalid value for parameter `period` when calling `get_crypto_price_technicals_trix`, must be a value greater than or equal to `2`")  # noqa: E501
        if 'page_size' in params and params['page_size'] > 10000:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `get_crypto_price_technicals_trix`, must be a value less than or equal to `10000`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'pair' in params:
            query_params.append(('pair', params['pair']))  # noqa: E501
        if 'exchange' in params:
            query_params.append(('exchange', params['exchange']))  # noqa: E501
        if 'currency' in params:
            query_params.append(('currency', params['currency']))  # noqa: E501
        if 'period' in params:
            query_params.append(('period', params['period']))  # noqa: E501
        if 'timeframe' in params:
            query_params.append(('timeframe', params['timeframe']))  # noqa: E501
        if 'timezone' in params:
            query_params.append(('timezone', params['timezone']))  # noqa: E501
        if 'start_date' in params:
            query_params.append(('start_date', params['start_date']))  # noqa: E501
        if 'start_time' in params:
            query_params.append(('start_time', params['start_time']))  # noqa: E501
        if 'end_date' in params:
            query_params.append(('end_date', params['end_date']))  # noqa: E501
        if 'end_time' in params:
            query_params.append(('end_time', params['end_time']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'next_page' in params:
            query_params.append(('next_page', params['next_page']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth']  # noqa: E501

        return self.api_client.call_api(
            '/crypto/prices/technicals/trix', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ApiResponseCryptoTripleExponentialAverage',  # noqa: E501
            auth_settings=auth_settings,
            _async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_crypto_price_technicals_tsi(self, **kwargs):  # noqa: E501
        """True Strength Index  # noqa: E501

        Returns the True Strength Index values of Crypto Currency Prices for a Crypto Currency Pair  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_crypto_price_technicals_tsi(_async=True)
        >>> result = thread.get()

        :param async bool
        :param str pair: Return technicals for the given Crypto Currency Pair.
        :param str exchange: Return technicals for a Crypto Currency on the given Crypto Exchange.
        :param str currency: Return technicals for the given Crypto Currency.
        :param int low_period: The number of observations, per period, to calculate low period Exponential Moving Average for smoothing in True Strength Index.
        :param int high_period: The number of observations, per period, to calculate high period Exponential Moving Average for smoothing in True Strength Index.
        :param str price_key: The Crypto Currency Price field to use when calculating True Strength Index.
        :param str timeframe: The time interval for the prices when calculating technicals.
        :param str timezone: Return technical date/times in this timezone, also interpret start/end date/time parameters in this timezone.
        :param date start_date: Return technicals on or after this date.
        :param str start_time: Return technicals at or after this time (24-hour).
        :param date end_date: Return technicals on or before this date.
        :param str end_time: Return technicals at or before this time (24-hour).
        :param int page_size: An integer greater than or equal to 1 for specifying the number of results on each page.
        :param str next_page: Gets the next page of data from a previous API call
        :return: ApiResponseCryptoTrueStrengthIndex
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_crypto_price_technicals_tsi_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_crypto_price_technicals_tsi_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_crypto_price_technicals_tsi_with_http_info(self, **kwargs):  # noqa: E501
        """True Strength Index  # noqa: E501

        Returns the True Strength Index values of Crypto Currency Prices for a Crypto Currency Pair  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_crypto_price_technicals_tsi_with_http_info(_async=True)
        >>> result = thread.get()

        :param async bool
        :param str pair: Return technicals for the given Crypto Currency Pair.
        :param str exchange: Return technicals for a Crypto Currency on the given Crypto Exchange.
        :param str currency: Return technicals for the given Crypto Currency.
        :param int low_period: The number of observations, per period, to calculate low period Exponential Moving Average for smoothing in True Strength Index.
        :param int high_period: The number of observations, per period, to calculate high period Exponential Moving Average for smoothing in True Strength Index.
        :param str price_key: The Crypto Currency Price field to use when calculating True Strength Index.
        :param str timeframe: The time interval for the prices when calculating technicals.
        :param str timezone: Return technical date/times in this timezone, also interpret start/end date/time parameters in this timezone.
        :param date start_date: Return technicals on or after this date.
        :param str start_time: Return technicals at or after this time (24-hour).
        :param date end_date: Return technicals on or before this date.
        :param str end_time: Return technicals at or before this time (24-hour).
        :param int page_size: An integer greater than or equal to 1 for specifying the number of results on each page.
        :param str next_page: Gets the next page of data from a previous API call
        :return: ApiResponseCryptoTrueStrengthIndex
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['pair', 'exchange', 'currency', 'low_period', 'high_period', 'price_key', 'timeframe', 'timezone', 'start_date', 'start_time', 'end_date', 'end_time', 'page_size', 'next_page']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_crypto_price_technicals_tsi" % key
                )
            params[key] = val
        del params['kwargs']

        if 'low_period' in params and params['low_period'] < 3:  # noqa: E501
            raise ValueError("Invalid value for parameter `low_period` when calling `get_crypto_price_technicals_tsi`, must be a value greater than or equal to `3`")  # noqa: E501
        if 'high_period' in params and params['high_period'] < 3:  # noqa: E501
            raise ValueError("Invalid value for parameter `high_period` when calling `get_crypto_price_technicals_tsi`, must be a value greater than or equal to `3`")  # noqa: E501
        if 'page_size' in params and params['page_size'] > 10000:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `get_crypto_price_technicals_tsi`, must be a value less than or equal to `10000`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'pair' in params:
            query_params.append(('pair', params['pair']))  # noqa: E501
        if 'exchange' in params:
            query_params.append(('exchange', params['exchange']))  # noqa: E501
        if 'currency' in params:
            query_params.append(('currency', params['currency']))  # noqa: E501
        if 'low_period' in params:
            query_params.append(('low_period', params['low_period']))  # noqa: E501
        if 'high_period' in params:
            query_params.append(('high_period', params['high_period']))  # noqa: E501
        if 'price_key' in params:
            query_params.append(('price_key', params['price_key']))  # noqa: E501
        if 'timeframe' in params:
            query_params.append(('timeframe', params['timeframe']))  # noqa: E501
        if 'timezone' in params:
            query_params.append(('timezone', params['timezone']))  # noqa: E501
        if 'start_date' in params:
            query_params.append(('start_date', params['start_date']))  # noqa: E501
        if 'start_time' in params:
            query_params.append(('start_time', params['start_time']))  # noqa: E501
        if 'end_date' in params:
            query_params.append(('end_date', params['end_date']))  # noqa: E501
        if 'end_time' in params:
            query_params.append(('end_time', params['end_time']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'next_page' in params:
            query_params.append(('next_page', params['next_page']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth']  # noqa: E501

        return self.api_client.call_api(
            '/crypto/prices/technicals/tsi', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ApiResponseCryptoTrueStrengthIndex',  # noqa: E501
            auth_settings=auth_settings,
            _async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_crypto_price_technicals_uo(self, **kwargs):  # noqa: E501
        """Ultimate Oscillator  # noqa: E501

        Returns the Ultimate Oscillator values of Crypto Currency Prices for a Crypto Currency Pair  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_crypto_price_technicals_uo(_async=True)
        >>> result = thread.get()

        :param async bool
        :param str pair: Return technicals for the given Crypto Currency Pair.
        :param str exchange: Return technicals for a Crypto Currency on the given Crypto Exchange.
        :param str currency: Return technicals for the given Crypto Currency.
        :param int short_period: The number of observations, per period, to calculate the short period for Ultimate Oscillator.
        :param int medium_period: The number of observations, per period, to calculate the medium period for Ultimate Oscillator.
        :param int long_period: The number of observations, per period, to calculate the long period for Ultimate Oscillator.
        :param float short_weight: The weight of short Buying Pressure average for Ultimate Oscillator.
        :param float medium_weight: The weight of medium Buying Pressure average for Ultimate Oscillator.
        :param float long_weight: The weight of long Buying Pressure average for Ultimate Oscillator.
        :param str timeframe: The time interval for the prices when calculating technicals.
        :param str timezone: Return technical date/times in this timezone, also interpret start/end date/time parameters in this timezone.
        :param date start_date: Return technicals on or after this date.
        :param str start_time: Return technicals at or after this time (24-hour).
        :param date end_date: Return technicals on or before this date.
        :param str end_time: Return technicals at or before this time (24-hour).
        :param int page_size: An integer greater than or equal to 1 for specifying the number of results on each page.
        :param str next_page: Gets the next page of data from a previous API call
        :return: ApiResponseCryptoUltimateOscillator
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_crypto_price_technicals_uo_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_crypto_price_technicals_uo_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_crypto_price_technicals_uo_with_http_info(self, **kwargs):  # noqa: E501
        """Ultimate Oscillator  # noqa: E501

        Returns the Ultimate Oscillator values of Crypto Currency Prices for a Crypto Currency Pair  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_crypto_price_technicals_uo_with_http_info(_async=True)
        >>> result = thread.get()

        :param async bool
        :param str pair: Return technicals for the given Crypto Currency Pair.
        :param str exchange: Return technicals for a Crypto Currency on the given Crypto Exchange.
        :param str currency: Return technicals for the given Crypto Currency.
        :param int short_period: The number of observations, per period, to calculate the short period for Ultimate Oscillator.
        :param int medium_period: The number of observations, per period, to calculate the medium period for Ultimate Oscillator.
        :param int long_period: The number of observations, per period, to calculate the long period for Ultimate Oscillator.
        :param float short_weight: The weight of short Buying Pressure average for Ultimate Oscillator.
        :param float medium_weight: The weight of medium Buying Pressure average for Ultimate Oscillator.
        :param float long_weight: The weight of long Buying Pressure average for Ultimate Oscillator.
        :param str timeframe: The time interval for the prices when calculating technicals.
        :param str timezone: Return technical date/times in this timezone, also interpret start/end date/time parameters in this timezone.
        :param date start_date: Return technicals on or after this date.
        :param str start_time: Return technicals at or after this time (24-hour).
        :param date end_date: Return technicals on or before this date.
        :param str end_time: Return technicals at or before this time (24-hour).
        :param int page_size: An integer greater than or equal to 1 for specifying the number of results on each page.
        :param str next_page: Gets the next page of data from a previous API call
        :return: ApiResponseCryptoUltimateOscillator
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['pair', 'exchange', 'currency', 'short_period', 'medium_period', 'long_period', 'short_weight', 'medium_weight', 'long_weight', 'timeframe', 'timezone', 'start_date', 'start_time', 'end_date', 'end_time', 'page_size', 'next_page']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_crypto_price_technicals_uo" % key
                )
            params[key] = val
        del params['kwargs']

        if 'long_period' in params and params['long_period'] < 4:  # noqa: E501
            raise ValueError("Invalid value for parameter `long_period` when calling `get_crypto_price_technicals_uo`, must be a value greater than or equal to `4`")  # noqa: E501
        if 'page_size' in params and params['page_size'] > 10000:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `get_crypto_price_technicals_uo`, must be a value less than or equal to `10000`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'pair' in params:
            query_params.append(('pair', params['pair']))  # noqa: E501
        if 'exchange' in params:
            query_params.append(('exchange', params['exchange']))  # noqa: E501
        if 'currency' in params:
            query_params.append(('currency', params['currency']))  # noqa: E501
        if 'short_period' in params:
            query_params.append(('short_period', params['short_period']))  # noqa: E501
        if 'medium_period' in params:
            query_params.append(('medium_period', params['medium_period']))  # noqa: E501
        if 'long_period' in params:
            query_params.append(('long_period', params['long_period']))  # noqa: E501
        if 'short_weight' in params:
            query_params.append(('short_weight', params['short_weight']))  # noqa: E501
        if 'medium_weight' in params:
            query_params.append(('medium_weight', params['medium_weight']))  # noqa: E501
        if 'long_weight' in params:
            query_params.append(('long_weight', params['long_weight']))  # noqa: E501
        if 'timeframe' in params:
            query_params.append(('timeframe', params['timeframe']))  # noqa: E501
        if 'timezone' in params:
            query_params.append(('timezone', params['timezone']))  # noqa: E501
        if 'start_date' in params:
            query_params.append(('start_date', params['start_date']))  # noqa: E501
        if 'start_time' in params:
            query_params.append(('start_time', params['start_time']))  # noqa: E501
        if 'end_date' in params:
            query_params.append(('end_date', params['end_date']))  # noqa: E501
        if 'end_time' in params:
            query_params.append(('end_time', params['end_time']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'next_page' in params:
            query_params.append(('next_page', params['next_page']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth']  # noqa: E501

        return self.api_client.call_api(
            '/crypto/prices/technicals/uo', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ApiResponseCryptoUltimateOscillator',  # noqa: E501
            auth_settings=auth_settings,
            _async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_crypto_price_technicals_vi(self, **kwargs):  # noqa: E501
        """Vortex Indicator  # noqa: E501

        Returns the Vortex Indicator values of Crypto Currency Prices for a Crypto Currency Pair  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_crypto_price_technicals_vi(_async=True)
        >>> result = thread.get()

        :param async bool
        :param str pair: Return technicals for the given Crypto Currency Pair.
        :param str exchange: Return technicals for a Crypto Currency on the given Crypto Exchange.
        :param str currency: Return technicals for the given Crypto Currency.
        :param int period: The number of observations, per period, to calculate Vortex Indicator.
        :param str timeframe: The time interval for the prices when calculating technicals.
        :param str timezone: Return technical date/times in this timezone, also interpret start/end date/time parameters in this timezone.
        :param date start_date: Return technicals on or after this date.
        :param str start_time: Return technicals at or after this time (24-hour).
        :param date end_date: Return technicals on or before this date.
        :param str end_time: Return technicals at or before this time (24-hour).
        :param int page_size: An integer greater than or equal to 1 for specifying the number of results on each page.
        :param str next_page: Gets the next page of data from a previous API call
        :return: ApiResponseCryptoVortexIndicator
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_crypto_price_technicals_vi_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_crypto_price_technicals_vi_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_crypto_price_technicals_vi_with_http_info(self, **kwargs):  # noqa: E501
        """Vortex Indicator  # noqa: E501

        Returns the Vortex Indicator values of Crypto Currency Prices for a Crypto Currency Pair  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_crypto_price_technicals_vi_with_http_info(_async=True)
        >>> result = thread.get()

        :param async bool
        :param str pair: Return technicals for the given Crypto Currency Pair.
        :param str exchange: Return technicals for a Crypto Currency on the given Crypto Exchange.
        :param str currency: Return technicals for the given Crypto Currency.
        :param int period: The number of observations, per period, to calculate Vortex Indicator.
        :param str timeframe: The time interval for the prices when calculating technicals.
        :param str timezone: Return technical date/times in this timezone, also interpret start/end date/time parameters in this timezone.
        :param date start_date: Return technicals on or after this date.
        :param str start_time: Return technicals at or after this time (24-hour).
        :param date end_date: Return technicals on or before this date.
        :param str end_time: Return technicals at or before this time (24-hour).
        :param int page_size: An integer greater than or equal to 1 for specifying the number of results on each page.
        :param str next_page: Gets the next page of data from a previous API call
        :return: ApiResponseCryptoVortexIndicator
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['pair', 'exchange', 'currency', 'period', 'timeframe', 'timezone', 'start_date', 'start_time', 'end_date', 'end_time', 'page_size', 'next_page']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_crypto_price_technicals_vi" % key
                )
            params[key] = val
        del params['kwargs']

        if 'period' in params and params['period'] < 4:  # noqa: E501
            raise ValueError("Invalid value for parameter `period` when calling `get_crypto_price_technicals_vi`, must be a value greater than or equal to `4`")  # noqa: E501
        if 'page_size' in params and params['page_size'] > 10000:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `get_crypto_price_technicals_vi`, must be a value less than or equal to `10000`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'pair' in params:
            query_params.append(('pair', params['pair']))  # noqa: E501
        if 'exchange' in params:
            query_params.append(('exchange', params['exchange']))  # noqa: E501
        if 'currency' in params:
            query_params.append(('currency', params['currency']))  # noqa: E501
        if 'period' in params:
            query_params.append(('period', params['period']))  # noqa: E501
        if 'timeframe' in params:
            query_params.append(('timeframe', params['timeframe']))  # noqa: E501
        if 'timezone' in params:
            query_params.append(('timezone', params['timezone']))  # noqa: E501
        if 'start_date' in params:
            query_params.append(('start_date', params['start_date']))  # noqa: E501
        if 'start_time' in params:
            query_params.append(('start_time', params['start_time']))  # noqa: E501
        if 'end_date' in params:
            query_params.append(('end_date', params['end_date']))  # noqa: E501
        if 'end_time' in params:
            query_params.append(('end_time', params['end_time']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'next_page' in params:
            query_params.append(('next_page', params['next_page']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth']  # noqa: E501

        return self.api_client.call_api(
            '/crypto/prices/technicals/vi', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ApiResponseCryptoVortexIndicator',  # noqa: E501
            auth_settings=auth_settings,
            _async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_crypto_price_technicals_vpt(self, **kwargs):  # noqa: E501
        """Volume-price Trend  # noqa: E501

        Returns the Volume-price Trend values of Crypto Currency Prices for a Crypto Currency Pair  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_crypto_price_technicals_vpt(_async=True)
        >>> result = thread.get()

        :param async bool
        :param str pair: Return technicals for the given Crypto Currency Pair.
        :param str exchange: Return technicals for a Crypto Currency on the given Crypto Exchange.
        :param str currency: Return technicals for the given Crypto Currency.
        :param str timeframe: The time interval for the prices when calculating technicals.
        :param str timezone: Return technical date/times in this timezone, also interpret start/end date/time parameters in this timezone.
        :param date start_date: Return technicals on or after this date.
        :param str start_time: Return technicals at or after this time (24-hour).
        :param date end_date: Return technicals on or before this date.
        :param str end_time: Return technicals at or before this time (24-hour).
        :param int page_size: An integer greater than or equal to 1 for specifying the number of results on each page.
        :param str next_page: Gets the next page of data from a previous API call
        :return: ApiResponseCryptoVolumePriceTrend
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_crypto_price_technicals_vpt_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_crypto_price_technicals_vpt_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_crypto_price_technicals_vpt_with_http_info(self, **kwargs):  # noqa: E501
        """Volume-price Trend  # noqa: E501

        Returns the Volume-price Trend values of Crypto Currency Prices for a Crypto Currency Pair  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_crypto_price_technicals_vpt_with_http_info(_async=True)
        >>> result = thread.get()

        :param async bool
        :param str pair: Return technicals for the given Crypto Currency Pair.
        :param str exchange: Return technicals for a Crypto Currency on the given Crypto Exchange.
        :param str currency: Return technicals for the given Crypto Currency.
        :param str timeframe: The time interval for the prices when calculating technicals.
        :param str timezone: Return technical date/times in this timezone, also interpret start/end date/time parameters in this timezone.
        :param date start_date: Return technicals on or after this date.
        :param str start_time: Return technicals at or after this time (24-hour).
        :param date end_date: Return technicals on or before this date.
        :param str end_time: Return technicals at or before this time (24-hour).
        :param int page_size: An integer greater than or equal to 1 for specifying the number of results on each page.
        :param str next_page: Gets the next page of data from a previous API call
        :return: ApiResponseCryptoVolumePriceTrend
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['pair', 'exchange', 'currency', 'timeframe', 'timezone', 'start_date', 'start_time', 'end_date', 'end_time', 'page_size', 'next_page']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_crypto_price_technicals_vpt" % key
                )
            params[key] = val
        del params['kwargs']

        if 'page_size' in params and params['page_size'] > 10000:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `get_crypto_price_technicals_vpt`, must be a value less than or equal to `10000`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'pair' in params:
            query_params.append(('pair', params['pair']))  # noqa: E501
        if 'exchange' in params:
            query_params.append(('exchange', params['exchange']))  # noqa: E501
        if 'currency' in params:
            query_params.append(('currency', params['currency']))  # noqa: E501
        if 'timeframe' in params:
            query_params.append(('timeframe', params['timeframe']))  # noqa: E501
        if 'timezone' in params:
            query_params.append(('timezone', params['timezone']))  # noqa: E501
        if 'start_date' in params:
            query_params.append(('start_date', params['start_date']))  # noqa: E501
        if 'start_time' in params:
            query_params.append(('start_time', params['start_time']))  # noqa: E501
        if 'end_date' in params:
            query_params.append(('end_date', params['end_date']))  # noqa: E501
        if 'end_time' in params:
            query_params.append(('end_time', params['end_time']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'next_page' in params:
            query_params.append(('next_page', params['next_page']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth']  # noqa: E501

        return self.api_client.call_api(
            '/crypto/prices/technicals/vpt', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ApiResponseCryptoVolumePriceTrend',  # noqa: E501
            auth_settings=auth_settings,
            _async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_crypto_price_technicals_vwap(self, **kwargs):  # noqa: E501
        """Volume Weighted Average Price  # noqa: E501

        Returns the Volume Weighted Average Price values of Crypto Currency Prices for a Crypto Currency Pair  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_crypto_price_technicals_vwap(_async=True)
        >>> result = thread.get()

        :param async bool
        :param str pair: Return technicals for the given Crypto Currency Pair.
        :param str exchange: Return technicals for a Crypto Currency on the given Crypto Exchange.
        :param str currency: Return technicals for the given Crypto Currency.
        :param str timeframe: The time interval for the prices when calculating technicals.
        :param str timezone: Return technical date/times in this timezone, also interpret start/end date/time parameters in this timezone.
        :param date start_date: Return technicals on or after this date.
        :param str start_time: Return technicals at or after this time (24-hour).
        :param date end_date: Return technicals on or before this date.
        :param str end_time: Return technicals at or before this time (24-hour).
        :param int page_size: An integer greater than or equal to 1 for specifying the number of results on each page.
        :param str next_page: Gets the next page of data from a previous API call
        :return: ApiResponseCryptoVolumeWeightedAveragePrice
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_crypto_price_technicals_vwap_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_crypto_price_technicals_vwap_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_crypto_price_technicals_vwap_with_http_info(self, **kwargs):  # noqa: E501
        """Volume Weighted Average Price  # noqa: E501

        Returns the Volume Weighted Average Price values of Crypto Currency Prices for a Crypto Currency Pair  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_crypto_price_technicals_vwap_with_http_info(_async=True)
        >>> result = thread.get()

        :param async bool
        :param str pair: Return technicals for the given Crypto Currency Pair.
        :param str exchange: Return technicals for a Crypto Currency on the given Crypto Exchange.
        :param str currency: Return technicals for the given Crypto Currency.
        :param str timeframe: The time interval for the prices when calculating technicals.
        :param str timezone: Return technical date/times in this timezone, also interpret start/end date/time parameters in this timezone.
        :param date start_date: Return technicals on or after this date.
        :param str start_time: Return technicals at or after this time (24-hour).
        :param date end_date: Return technicals on or before this date.
        :param str end_time: Return technicals at or before this time (24-hour).
        :param int page_size: An integer greater than or equal to 1 for specifying the number of results on each page.
        :param str next_page: Gets the next page of data from a previous API call
        :return: ApiResponseCryptoVolumeWeightedAveragePrice
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['pair', 'exchange', 'currency', 'timeframe', 'timezone', 'start_date', 'start_time', 'end_date', 'end_time', 'page_size', 'next_page']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_crypto_price_technicals_vwap" % key
                )
            params[key] = val
        del params['kwargs']

        if 'page_size' in params and params['page_size'] > 10000:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `get_crypto_price_technicals_vwap`, must be a value less than or equal to `10000`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'pair' in params:
            query_params.append(('pair', params['pair']))  # noqa: E501
        if 'exchange' in params:
            query_params.append(('exchange', params['exchange']))  # noqa: E501
        if 'currency' in params:
            query_params.append(('currency', params['currency']))  # noqa: E501
        if 'timeframe' in params:
            query_params.append(('timeframe', params['timeframe']))  # noqa: E501
        if 'timezone' in params:
            query_params.append(('timezone', params['timezone']))  # noqa: E501
        if 'start_date' in params:
            query_params.append(('start_date', params['start_date']))  # noqa: E501
        if 'start_time' in params:
            query_params.append(('start_time', params['start_time']))  # noqa: E501
        if 'end_date' in params:
            query_params.append(('end_date', params['end_date']))  # noqa: E501
        if 'end_time' in params:
            query_params.append(('end_time', params['end_time']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'next_page' in params:
            query_params.append(('next_page', params['next_page']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth']  # noqa: E501

        return self.api_client.call_api(
            '/crypto/prices/technicals/vwap', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ApiResponseCryptoVolumeWeightedAveragePrice',  # noqa: E501
            auth_settings=auth_settings,
            _async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_crypto_price_technicals_wr(self, **kwargs):  # noqa: E501
        """Williams %R  # noqa: E501

        Returns the Williams %R values of Crypto Currency Prices for a Crypto Currency Pair  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_crypto_price_technicals_wr(_async=True)
        >>> result = thread.get()

        :param async bool
        :param str pair: Return technicals for the given Crypto Currency Pair.
        :param str exchange: Return technicals for a Crypto Currency on the given Crypto Exchange.
        :param str currency: Return technicals for the given Crypto Currency.
        :param int period: The number of observations, per period, to look-back when calculating Williams %R.
        :param str timeframe: The time interval for the prices when calculating technicals.
        :param str timezone: Return technical date/times in this timezone, also interpret start/end date/time parameters in this timezone.
        :param date start_date: Return technicals on or after this date.
        :param str start_time: Return technicals at or after this time (24-hour).
        :param date end_date: Return technicals on or before this date.
        :param str end_time: Return technicals at or before this time (24-hour).
        :param int page_size: An integer greater than or equal to 1 for specifying the number of results on each page.
        :param str next_page: Gets the next page of data from a previous API call
        :return: ApiResponseCryptoWilliamsR
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_crypto_price_technicals_wr_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_crypto_price_technicals_wr_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_crypto_price_technicals_wr_with_http_info(self, **kwargs):  # noqa: E501
        """Williams %R  # noqa: E501

        Returns the Williams %R values of Crypto Currency Prices for a Crypto Currency Pair  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_crypto_price_technicals_wr_with_http_info(_async=True)
        >>> result = thread.get()

        :param async bool
        :param str pair: Return technicals for the given Crypto Currency Pair.
        :param str exchange: Return technicals for a Crypto Currency on the given Crypto Exchange.
        :param str currency: Return technicals for the given Crypto Currency.
        :param int period: The number of observations, per period, to look-back when calculating Williams %R.
        :param str timeframe: The time interval for the prices when calculating technicals.
        :param str timezone: Return technical date/times in this timezone, also interpret start/end date/time parameters in this timezone.
        :param date start_date: Return technicals on or after this date.
        :param str start_time: Return technicals at or after this time (24-hour).
        :param date end_date: Return technicals on or before this date.
        :param str end_time: Return technicals at or before this time (24-hour).
        :param int page_size: An integer greater than or equal to 1 for specifying the number of results on each page.
        :param str next_page: Gets the next page of data from a previous API call
        :return: ApiResponseCryptoWilliamsR
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['pair', 'exchange', 'currency', 'period', 'timeframe', 'timezone', 'start_date', 'start_time', 'end_date', 'end_time', 'page_size', 'next_page']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_crypto_price_technicals_wr" % key
                )
            params[key] = val
        del params['kwargs']

        if 'period' in params and params['period'] < 5:  # noqa: E501
            raise ValueError("Invalid value for parameter `period` when calling `get_crypto_price_technicals_wr`, must be a value greater than or equal to `5`")  # noqa: E501
        if 'page_size' in params and params['page_size'] > 10000:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `get_crypto_price_technicals_wr`, must be a value less than or equal to `10000`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'pair' in params:
            query_params.append(('pair', params['pair']))  # noqa: E501
        if 'exchange' in params:
            query_params.append(('exchange', params['exchange']))  # noqa: E501
        if 'currency' in params:
            query_params.append(('currency', params['currency']))  # noqa: E501
        if 'period' in params:
            query_params.append(('period', params['period']))  # noqa: E501
        if 'timeframe' in params:
            query_params.append(('timeframe', params['timeframe']))  # noqa: E501
        if 'timezone' in params:
            query_params.append(('timezone', params['timezone']))  # noqa: E501
        if 'start_date' in params:
            query_params.append(('start_date', params['start_date']))  # noqa: E501
        if 'start_time' in params:
            query_params.append(('start_time', params['start_time']))  # noqa: E501
        if 'end_date' in params:
            query_params.append(('end_date', params['end_date']))  # noqa: E501
        if 'end_time' in params:
            query_params.append(('end_time', params['end_time']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'next_page' in params:
            query_params.append(('next_page', params['next_page']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth']  # noqa: E501

        return self.api_client.call_api(
            '/crypto/prices/technicals/wr', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ApiResponseCryptoWilliamsR',  # noqa: E501
            auth_settings=auth_settings,
            _async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_crypto_prices(self, timeframe, **kwargs):  # noqa: E501
        """Crypto Prices  # noqa: E501

        Returns a list of available Crypto Currency Prices.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_crypto_prices(timeframe, _async=True)
        >>> result = thread.get()

        :param async bool
        :param str timeframe: The time interval for the prices. (required)
        :param str pair: Return prices for the given Crypto Currency Pair.
        :param str exchange: Return prices for a Crypto Currency on the given Crypto Exchange.
        :param str currency: Return prices for the given Crypto Currency.
        :param str timezone: Return price date/times in this timezone, also interpret start/end date/time parameters in this timezone.
        :param date start_date: Return Crypto Prices on or after this date.
        :param str start_time: Return Crypto Prices at or after this time (24-hour).
        :param date end_date: Return Crypto Prices on or before this date.
        :param str end_time: Return Crypto Prices at or before this time (24-hour).
        :param int page_size: An integer greater than or equal to 1 for specifying the number of results on each page.
        :param str next_page: Gets the next page of data from a previous API call
        :return: ApiResponseCryptoPrices
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_crypto_prices_with_http_info(timeframe, **kwargs)  # noqa: E501
        else:
            (data) = self.get_crypto_prices_with_http_info(timeframe, **kwargs)  # noqa: E501
            return data

    def get_crypto_prices_with_http_info(self, timeframe, **kwargs):  # noqa: E501
        """Crypto Prices  # noqa: E501

        Returns a list of available Crypto Currency Prices.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_crypto_prices_with_http_info(timeframe, _async=True)
        >>> result = thread.get()

        :param async bool
        :param str timeframe: The time interval for the prices. (required)
        :param str pair: Return prices for the given Crypto Currency Pair.
        :param str exchange: Return prices for a Crypto Currency on the given Crypto Exchange.
        :param str currency: Return prices for the given Crypto Currency.
        :param str timezone: Return price date/times in this timezone, also interpret start/end date/time parameters in this timezone.
        :param date start_date: Return Crypto Prices on or after this date.
        :param str start_time: Return Crypto Prices at or after this time (24-hour).
        :param date end_date: Return Crypto Prices on or before this date.
        :param str end_time: Return Crypto Prices at or before this time (24-hour).
        :param int page_size: An integer greater than or equal to 1 for specifying the number of results on each page.
        :param str next_page: Gets the next page of data from a previous API call
        :return: ApiResponseCryptoPrices
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['timeframe', 'pair', 'exchange', 'currency', 'timezone', 'start_date', 'start_time', 'end_date', 'end_time', 'page_size', 'next_page']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_crypto_prices" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'timeframe' is set
        if ('timeframe' not in params or
                params['timeframe'] is None):
            raise ValueError("Missing the required parameter `timeframe` when calling `get_crypto_prices`")  # noqa: E501

        if 'page_size' in params and params['page_size'] > 10000:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `get_crypto_prices`, must be a value less than or equal to `10000`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'pair' in params:
            query_params.append(('pair', params['pair']))  # noqa: E501
        if 'exchange' in params:
            query_params.append(('exchange', params['exchange']))  # noqa: E501
        if 'currency' in params:
            query_params.append(('currency', params['currency']))  # noqa: E501
        if 'timeframe' in params:
            query_params.append(('timeframe', params['timeframe']))  # noqa: E501
        if 'timezone' in params:
            query_params.append(('timezone', params['timezone']))  # noqa: E501
        if 'start_date' in params:
            query_params.append(('start_date', params['start_date']))  # noqa: E501
        if 'start_time' in params:
            query_params.append(('start_time', params['start_time']))  # noqa: E501
        if 'end_date' in params:
            query_params.append(('end_date', params['end_date']))  # noqa: E501
        if 'end_time' in params:
            query_params.append(('end_time', params['end_time']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'next_page' in params:
            query_params.append(('next_page', params['next_page']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth']  # noqa: E501

        return self.api_client.call_api(
            '/crypto/prices', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ApiResponseCryptoPrices',  # noqa: E501
            auth_settings=auth_settings,
            _async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_crypto_snapshot(self, **kwargs):  # noqa: E501
        """Crypto Snapshot  # noqa: E501

        Returns a market snapshot over that last 24 hours for the given currency pair and exchange.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_crypto_snapshot(_async=True)
        >>> result = thread.get()

        :param async bool
        :param str pair: Return the snapshot for the given Crypto Currency Pair.
        :param str exchange: Return the snapshot for a Crypto Currency on the given Crypto Exchange.
        :param str currency: Return the snapshot for the given Crypto Currency.
        :return: ApiResponseCryptoSnapshot
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_crypto_snapshot_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_crypto_snapshot_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_crypto_snapshot_with_http_info(self, **kwargs):  # noqa: E501
        """Crypto Snapshot  # noqa: E501

        Returns a market snapshot over that last 24 hours for the given currency pair and exchange.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_crypto_snapshot_with_http_info(_async=True)
        >>> result = thread.get()

        :param async bool
        :param str pair: Return the snapshot for the given Crypto Currency Pair.
        :param str exchange: Return the snapshot for a Crypto Currency on the given Crypto Exchange.
        :param str currency: Return the snapshot for the given Crypto Currency.
        :return: ApiResponseCryptoSnapshot
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['pair', 'exchange', 'currency']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_crypto_snapshot" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'pair' in params:
            query_params.append(('pair', params['pair']))  # noqa: E501
        if 'exchange' in params:
            query_params.append(('exchange', params['exchange']))  # noqa: E501
        if 'currency' in params:
            query_params.append(('currency', params['currency']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth']  # noqa: E501

        return self.api_client.call_api(
            '/crypto/snapshot', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ApiResponseCryptoSnapshot',  # noqa: E501
            auth_settings=auth_settings,
            _async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_crypto_stats(self, **kwargs):  # noqa: E501
        """Crypto Stats  # noqa: E501

        Returns available stats on Crypto Currencies.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_crypto_stats(_async=True)
        >>> result = thread.get()

        :param async bool
        :param str exchange: Returns stats for Crypto Currencies that trade on the specified Crypto Exchange.
        :param str currency: Returns stats for the specified Crypto Currency.
        :return: ApiResponseCryptoStats
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_crypto_stats_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_crypto_stats_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_crypto_stats_with_http_info(self, **kwargs):  # noqa: E501
        """Crypto Stats  # noqa: E501

        Returns available stats on Crypto Currencies.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_crypto_stats_with_http_info(_async=True)
        >>> result = thread.get()

        :param async bool
        :param str exchange: Returns stats for Crypto Currencies that trade on the specified Crypto Exchange.
        :param str currency: Returns stats for the specified Crypto Currency.
        :return: ApiResponseCryptoStats
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['exchange', 'currency']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_crypto_stats" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'exchange' in params:
            query_params.append(('exchange', params['exchange']))  # noqa: E501
        if 'currency' in params:
            query_params.append(('currency', params['currency']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth']  # noqa: E501

        return self.api_client.call_api(
            '/crypto/stats', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ApiResponseCryptoStats',  # noqa: E501
            auth_settings=auth_settings,
            _async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
