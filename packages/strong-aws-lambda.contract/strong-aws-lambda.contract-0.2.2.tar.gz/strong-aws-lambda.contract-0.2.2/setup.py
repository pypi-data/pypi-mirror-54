# -*- coding: utf-8 -*-
from distutils.core import setup

package_dir = \
{'': '.'}

packages = \
['strong_aws_pkg']

package_data = \
{'': ['*']}

install_requires = \
['aws-lambda-context>=1.1,<2.0', 'dacite>=1.0,<2.0']

setup_kwargs = {
    'name': 'strong-aws-lambda.contract',
    'version': '0.2.2',
    'description': 'Extra lambda utils',
    'long_description': '# Strong AWS Lambda\n\nAWS lambdas are a very important feature from AWS platform, due to the intense use of it by the clients and also internally in order to enable other features.\nDue to the intensive usage of it, I\'d like to make its surrounds a bit more comfortable to develop on. \nAs a developer with a big static programming language background, I created this module to bring the advantages of \na static type language to the python lambda world  (especially custom resources) + automate some repetitive code we always create while\nusing lambdas, like parsing the event input information, guarantee the correct result, etc.\n\n\n## Usage\nThe solution is based in some new decorators, which brings extra features for the lambda handlers.\nAs you might know, the first params for a lambda handler or a custom resource handler is and object event. \nWhich in lambda can be anything but for custom resource is for sure a dictionary with values.\n\n\nThis library convert the event to an object of a given contract you defined and call the function using the new object.\nBefore that it execute all the static typing and consistency with between the given params and the expected params.\n\n\nThe contract must to be a `dataclass` where the name of the fields will be the name of the keys you want to exist in\nthe call to your lambda/custom resource. In case the conversion fails a `ValueError` exception will raise informing\nwhich fields were missing in the `event` params. The message will raise as:\n\n`ValueError: Keys [\'X\', \'Y\', \'Z\'] not found in event`, where `X`, `Y` and `Z` are the fields which couldn\'t be found in \nthe `event` param.\n\nThis also checks for the types you define. If in your contract you expect `field1` as `str` but the information is \nsent as `int` for example. The conversion will fail and raise the given exception:\n\n`WrongTypeError: wrong type for field "X" - should be "str" instead of "int"`, where `X` will be the \n\nThe conversions are use as engine the `dacite` project. So if you want to check more information, how the mapping \nfrom and dictionary to `dataclass` works and what are the possibilities. \nCheck their project [here](https://github.com/konradhalas/dacite)   \n\n\n### Lambdas\nYou just need to add the decorator `strong_aws_lambda` and set the param `contract_class` with your desired contract \ndataclass on your lambda handler.\nCheck the example below where we have the contract class `FooContract`. Keep in mind that your contract classes \nmust to have the decorator `dataclass`.\n\n```python\nfrom dataclasses import dataclass\nfrom typing import List\nfrom aws_lambda_context import LambdaContext\nfrom strong_aws_pkg import strong_aws_lambda\n\n\n@dataclass\nclass FooContract:\n    field1: str\n    field2: int\n    items: List[str]\n\n\n@strong_aws_lambda(contract_class=FooContract)\ndef lambda_handler(event: FooContract, context: LambdaContext):\n    print(f\'The field is for sure in event object and its type is a str. The value is {event.field1}\')\n    print(f\'The field is for sure in event object and its type is an int. The value is {event.field2}\')\n    print(f\'And there are {len(event.items)} in the items object\')\n    [print(f\'And the value of the item is {item}\') for item in event.items]\n    \n# Just mocking a call the way AWS might to do to the function in order to check its behave.\nif __name__ == "__main__":\n    input = dict(field1=\'test1\', field2=1, items=[\'value1\', \'value2\', \'value3\'])\n    lambda_handler(input, LambdaContext())\n\n    invalid_input = dict(unknown_field=\'test1\', unknown_field2=1, other_items=[\'value1\', \'value2\', \'value3\'])\n    lambda_handler(invalid_input, LambdaContext())\n```\n\nThe console output for this code will be:\n```text\nThe field is for sure in event object and its type is a str. The value is test1\nThe field is for sure in event object and its type is an int. The value is 1\nAnd there are 3 objects in the items object\nAnd the value of the item is value1\nAnd the value of the item is value2\nAnd the value of the item is value3\nKeys [\'field1\', \'field2\', \'items\'] not found in event\n```\n\n### Custom Resources\nCustom resources have a bit more complicated situation as they need to communicate back to AWS in order to give the \ninformation about the CloudFormation Stack its changing.\nHere is where you have more gain using this library, as it will ensure that all the information needed will exist\nin the in and out contract.\n\nFor example, even if you forget to add the `Status` in your return, this this library will wrap it into a understandable \nobject where AWS can act accordingly without blocking the finalization of the action.\n\nFor this decorator you need to set to parameters:\n1. `contract_class`: You need to pass your defined contract class which must to have the decorator `@dataclass(frozen=True)`, \nand inherit from `BaseResourceProperties`.\n1. `handle_untreated_exceptions` (default value is `true`): Tell to the decorator function what to do to untreated exceptions. If it\'s `true` it will\nwrap the exception message into a expected AWS format. If `false` it won\'t change the result and you will have problems to \nexecute further iterations in stack this custom resource have been created.\n\nThe reason the `dataclass` decorator has its attribute `frozen` se to `true` is due to the fact we want to have \nimmutability in our contract objects.  \n\nGiven the python code example:\n```python\nfrom dataclasses import dataclass\nfrom typing import List\n\nfrom aws_lambda_context import LambdaContext\nfrom cfn_lambda_handler import Handler\n\nfrom strong_aws_pkg import AwsRequestContract, BaseResourceProperties, BaseResultContract, StatusResult, \\\n    strong_aws_lambda_custom_resource\n\nhandler = Handler()\n\n\n###########################\n# Example of handler create\n###########################\n\n@dataclass(frozen=True)\nclass HandlerCreateContract(BaseResourceProperties):\n    CustomParam1: str\n    CustomParam2: List[int]\n\n\n@dataclass(frozen=True)\nclass HandlerCreateResultContract(BaseResultContract):\n    CustomParams1: str\n\n\n@handler.create\n@strong_aws_lambda_custom_resource(contract_class=HandlerCreateContract, handle_untreated_exceptions=True)\ndef handler_create(custom_params: HandlerCreateContract, context: LambdaContext,\n                   aws_params: AwsRequestContract) -> HandlerCreateResultContract:\n    print(custom_params)\n    print(context)\n    print(aws_params)\n    return HandlerCreateResultContract(Status=StatusResult.Success, CustomParams1=\'Everything went fine :) Cheers!\')\n\n\n###########################\n# Example of handler update\n###########################\n\n@dataclass(frozen=True)\nclass HandlerUpdateContract(BaseResourceProperties):\n    Field1: str\n\n\n@handler.update\n@strong_aws_lambda_custom_resource(HandlerUpdateContract)\ndef handler_update(custom_params: HandlerUpdateContract, context: LambdaContext,\n                   aws_params: AwsRequestContract) -> BaseResultContract:\n    raise Exception(\'Unexpected error\')\n\n\n###########################\n# Example of handler delete\n###########################\n\n@dataclass(frozen=True)\nclass HandlerDeleteContract(BaseResourceProperties):\n    Reason: str\n\n\n@handler.delete\n@strong_aws_lambda_custom_resource(HandlerDeleteContract)\ndef handler_delete(event: HandlerDeleteContract, context: LambdaContext,\n                   aws_params: AwsRequestContract) -> BaseResultContract:\n    if event.Reason:\n        print(f\'Deleting stack because {event.Reason}\')\n    else:\n        print(f\'Deleting stack\')\n\n    return BaseResultContract(StatusResult.Success)\n\n\n# Just mocking a call the way AWS might to do to the function in order to check its behave.\nif __name__ == "__main__":\n    print(\'-------  Calling handler_create\')\n    # Input example got from https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/template-custom-resources.html\n    aws_input_param = {\n        "RequestType": "Create",\n        "ResponseURL": "http://pre-signed-S3-url-for-response",\n        "StackId": "arn:aws:cloudformation:us-west-2:123456789012:stack/stack-name/guid",\n        "RequestId": "unique id for this create request",\n        "ResourceType": "Custom::TestResource",\n        "LogicalResourceId": "MyTestResource",\n        "ResourceProperties": {\n            "CustomParam1": "Value",\n            "CustomParam2": [1, 2, 3]\n        }\n    }\n    result = handler_create(aws_input_param, LambdaContext())\n    print(result)\n\n    print(\'-------  Calling handler_update\')\n    aws_update_param = {\n        "RequestType": "Update",\n        "ResponseURL": "http://pre-signed-S3-url-for-response",\n        "StackId": "arn:aws:cloudformation:us-west-2:123456789012:stack/stack-name/guid",\n        "RequestId": "unique id for this create request",\n        "ResourceType": "Custom::TestResource",\n        "LogicalResourceId": "MyTestResource",\n        "ResourceProperties": {\n            "Field1": "Value"\n        }\n    }\n    result = handler_update(aws_update_param, LambdaContext())\n    print(result)\n\n    print(\'-------  Calling handler_delete\')\n    aws_delete_param = {\n        "RequestType": "Delete",\n        "ResponseURL": "http://pre-signed-S3-url-for-response",\n        "StackId": "arn:aws:cloudformation:us-west-2:123456789012:stack/stack-name/guid",\n        "RequestId": "unique id for this create request",\n        "ResourceType": "Custom::TestResource",\n        "LogicalResourceId": "MyTestResource",\n        "ResourceProperties": {\n            "Reason": "All work done"\n        }\n    }\n    result = handler_delete(aws_delete_param, LambdaContext())\n    print(result)\n\n```\n\nYou will get this output in your console:\n```text\n-------  Calling handler_create\nHandlerCreateContract(CustomParam1=\'Value\', CustomParam2=[1, 2, 3])\n<aws_lambda_context.LambdaContext object at 0x107faec18>\nAwsRequestContract(RequestType=\'Create\', ResponseURL=\'http://pre-signed-S3-url-for-response\', StackId=\'arn:aws:cloudformation:us-west-2:123456789012:stack/stack-name/guid\', ResourceType=\'Custom::TestResource\', LogicalResourceId=\'MyTestResource\')\n{"Status": "SUCCESS", "CustomParams1": "Everything went fine :) Cheers!"}\n-------  Calling handler_update\n{"Status": "FAILED", "Reason": "Unexpected error"}\n-------  Calling handler_delete\nDeleting stack because All work done\n{"Status": "SUCCESS"}\n```\n\nAs you my have noticed the `handler_update` was raising and not treating an exception. This is bad because AWS \nexpects an answer in a specific way. A dictionary with at least a key `Status`, with value `FAILED` or `SUCCESS`. \nAs in this case the `handle_untreated_exceptions` param was set to `true`, the result is a well formatted object:\n\n `{"Status": "FAILED", "Reason": "Unexpected error"}`\n\n```python\n@handler.update\n@strong_aws_lambda_custom_resource(HandlerUpdateContract, handle_untreated_exceptions=False)\ndef handler_update(custom_params: HandlerUpdateContract, context: LambdaContext,\n                   aws_params: AwsRequestContract) -> BaseResultContract:\n    ...\n    ...\n    ...\n```\n\n\n## Further Reading\nIf you are not very familiar with the terms I mentioned above, I put some links together in order to bring more clarity \nto the topics. \n1. [Static vs Dynamic Typing](https://hackernoon.com/i-finally-understand-static-vs-dynamic-typing-and-you-will-too-ad0c2bd0acc7)\n1. [The benefits of static typing without static typing in Python](https://pawelmhm.github.io/python/static/typing/type/annotations/2016/01/23/typing-python3.html\n) \n1. [AWS Lambda](https://aws.amazon.com/lambda/)\n1. [AWS Custom Resources](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/template-custom-resources.html)\n1. [typing Python â€” Support for type hints](https://docs.python.org/3/library/typing.html)\n1. [Immutable objects](https://en.wikipedia.org/wiki/Immutable_object)\n1. [Why Immutability Matters](https://pasztor.at/blog/why-immutability-matters)\n',
    'author': 'Rodrigo Farias Rezino',
    'author_email': 'rodrigofrezino@gmail.com',
    'url': None,
    'package_dir': package_dir,
    'packages': packages,
    'package_data': package_data,
    'install_requires': install_requires,
    'python_requires': '>=3.6,<4.0',
}


setup(**setup_kwargs)
