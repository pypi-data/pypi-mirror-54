{"version":3,"sources":["webpack:///./src/cast/cast_framework.ts","webpack:///./src/cast/cast_manager.ts"],"names":["loadedPromise","managerProm","__webpack_require__","d","__webpack_exports__","cast_manager_CastManager","getCastManager","CastManager","auth","_this","this","_eventListeners","context","castContext","setOptions","receiverApplicationId","cast_const","autoJoinPolicy","chrome","cast","AutoJoinPolicy","ORIGIN_SCOPED","addEventListener","framework","CastContextEventType","SESSION_STATE_CHANGED","ev","_sessionStateChanged","CAST_STATE_CHANGED","_castStateChanged","prototype","event","listener","push","splice","indexOf","Object","defineProperty","undefined","status","connected","hassUrl","data","dev_const","sendMessage","msg","castSession","getCastState","CastContext","getInstance","getCurrentSession","requestSession","_fireEvent","_i","_a","length","_receiveMessage","type","sessionState","receiver_messages","_attachMessageListener","addMessageListener","_ns","JSON","parse","Promise","resolve","window","__onGCastApiAvailable","el","document","createElement","id","body","append","load_resource","castApiAvailable","then","isAvailable","Error"],"mappings":"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","file":"chunk.ff962f078ee1bdd47ded.js","sourcesContent":["import { loadJS } from \"../common/dom/load_resource\";\n\nlet loadedPromise: Promise<boolean> | undefined;\n\nexport const castApiAvailable = () => {\n  if (loadedPromise) {\n    return loadedPromise;\n  }\n\n  loadedPromise = new Promise((resolve) => {\n    (window as any).__onGCastApiAvailable = resolve;\n  });\n  // Any element with a specific ID will get set as a JS variable on window\n  // This will override the cast SDK if the iconset is loaded afterwards.\n  // Conflicting IDs will no longer mess with window, so we'll just append one.\n  const el = document.createElement(\"div\");\n  el.id = \"cast\";\n  document.body.append(el);\n\n  loadJS(\n    \"https://www.gstatic.com/cv/js/sender/v1/cast_sender.js?loadCastFramework=1\"\n  );\n  return loadedPromise;\n};\n","import { castApiAvailable } from \"./cast_framework\";\nimport { CAST_APP_ID, CAST_NS, CAST_DEV } from \"./const\";\nimport { CAST_DEV_HASS_URL } from \"./dev_const\";\nimport {\n  castSendAuth,\n  HassMessage as ReceiverMessage,\n} from \"./receiver_messages\";\nimport {\n  SessionStateEventData,\n  CastStateEventData,\n  // tslint:disable-next-line: no-implicit-dependencies\n} from \"chromecast-caf-receiver/cast.framework\";\nimport { SenderMessage, ReceiverStatusMessage } from \"./sender_messages\";\nimport { Auth } from \"home-assistant-js-websocket\";\n\nlet managerProm: Promise<CastManager> | undefined;\n\ntype CastEventListener = () => void;\n\n/*\nGeneral flow of Chromecast:\n\nChromecast sessions are started via the Chromecast button. When clicked, session\nstate changes to started. We then send authentication, which will cause the\nreceiver app to send a status update.\n\nIf a session is already active, we query the status to see what it is up to. If\na user presses the cast button we send auth if not connected yet, then send\ncommand as usual.\n*/\n\n/* tslint:disable:no-console */\n\ntype CastEvent = \"connection-changed\" | \"state-changed\";\n\nexport class CastManager {\n  public auth?: Auth;\n  // If the cast connection is connected to our Hass.\n  public status?: ReceiverStatusMessage;\n  private _eventListeners: { [event: string]: CastEventListener[] } = {};\n\n  constructor(auth?: Auth) {\n    this.auth = auth;\n    const context = this.castContext;\n    context.setOptions({\n      receiverApplicationId: CAST_APP_ID,\n      // @ts-ignore\n      autoJoinPolicy: chrome.cast.AutoJoinPolicy.ORIGIN_SCOPED,\n    });\n    context.addEventListener(\n      cast.framework.CastContextEventType.SESSION_STATE_CHANGED,\n      (ev) => this._sessionStateChanged(ev)\n    );\n    context.addEventListener(\n      cast.framework.CastContextEventType.CAST_STATE_CHANGED,\n      (ev) => this._castStateChanged(ev)\n    );\n  }\n\n  public addEventListener(event: CastEvent, listener: CastEventListener) {\n    if (!(event in this._eventListeners)) {\n      this._eventListeners[event] = [];\n    }\n    this._eventListeners[event].push(listener);\n\n    return () => {\n      this._eventListeners[event].splice(\n        this._eventListeners[event].indexOf(listener)\n      );\n    };\n  }\n\n  public get castConnectedToOurHass(): boolean {\n    return (\n      this.status !== undefined &&\n      this.auth !== undefined &&\n      this.status.connected &&\n      (this.status.hassUrl === this.auth.data.hassUrl ||\n        (CAST_DEV && this.status.hassUrl === CAST_DEV_HASS_URL))\n    );\n  }\n\n  public sendMessage(msg: ReceiverMessage) {\n    if (__DEV__) {\n      console.log(\"Sending cast message\", msg);\n    }\n    this.castSession.sendMessage(CAST_NS, msg);\n  }\n\n  public get castState() {\n    return this.castContext.getCastState();\n  }\n\n  public get castContext() {\n    return cast.framework.CastContext.getInstance();\n  }\n\n  public get castSession() {\n    return this.castContext.getCurrentSession()!;\n  }\n\n  public requestSession() {\n    return this.castContext.requestSession();\n  }\n\n  private _fireEvent(event: CastEvent) {\n    for (const listener of this._eventListeners[event] || []) {\n      listener();\n    }\n  }\n\n  private _receiveMessage(msg: SenderMessage) {\n    if (__DEV__) {\n      console.log(\"Received cast message\", msg);\n    }\n    if (msg.type === \"receiver_status\") {\n      this.status = msg;\n      this._fireEvent(\"connection-changed\");\n    }\n  }\n\n  private _sessionStateChanged(ev: SessionStateEventData) {\n    if (__DEV__) {\n      console.log(\"Cast session state changed\", ev.sessionState);\n    }\n    // On Android, opening a new session always results in SESSION_RESUMED.\n    // So treat both as the same.\n    if (\n      ev.sessionState === \"SESSION_STARTED\" ||\n      ev.sessionState === \"SESSION_RESUMED\"\n    ) {\n      if (this.auth) {\n        castSendAuth(this, this.auth);\n      } else {\n        // Only do if no auth, as this is done as part of sendAuth.\n        this.sendMessage({ type: \"get_status\" });\n      }\n      this._attachMessageListener();\n    } else if (ev.sessionState === \"SESSION_ENDED\") {\n      this.status = undefined;\n      this._fireEvent(\"connection-changed\");\n    }\n  }\n\n  private _castStateChanged(ev: CastStateEventData) {\n    if (__DEV__) {\n      console.log(\"Cast state changed\", ev.castState);\n    }\n    this._fireEvent(\"state-changed\");\n  }\n\n  private _attachMessageListener() {\n    const session = this.castSession;\n    session.addMessageListener(CAST_NS, (_ns, msg) =>\n      this._receiveMessage(JSON.parse(msg))\n    );\n  }\n}\n\nexport const getCastManager = (auth?: Auth) => {\n  if (!managerProm) {\n    managerProm = castApiAvailable().then((isAvailable) => {\n      if (!isAvailable) {\n        throw new Error(\"No Cast API available\");\n      }\n      return new CastManager(auth);\n    });\n  }\n  return managerProm;\n};\n"],"sourceRoot":""}