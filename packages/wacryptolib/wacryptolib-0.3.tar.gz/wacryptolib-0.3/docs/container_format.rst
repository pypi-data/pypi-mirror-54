
Encrypted container format
==========================

The data recorded by a Witness Angel data is processed and stored into a flexible container format. The idea is to allow each payload (media data, metadata, symmetric and asymmetric keys...) to be encrypted/signed by several entities, one after the other.

A configuration tree, with a structure similar to the container tree, is used to specify which algorithms and escrows the encryption/signing process must use.

The final serialization is done using Pymongo's Extended Json dialect; bson might eventually be used as a replacement.

While the `container_uid` value uniquely identifies the container, its `keychain_uid` value can be shared by several containers, which thus end up using a common set of keypairs generated by escrows for them.

**Beware, this format is not stable and specified yet.**

.. OBSOLETE STUFFS - TO BE RESPECIFIED LATER

    NOPE not yet - UUID overrides can exist at different levels of container data, to change the identifier used in transactions with third-party entities.

    WRONG - A global `keychain_uid` value is available to identify all containers related to a single Witness Angel device.

    Root dict:

        {
            data_ciphertext: <opaque multi-encrypted data bytestring>,
            data_encryption_strata: <list of Stratum Objects targeting ciphertext, in order of application>,
            data_uid: <optional uuid of this specific data container>,
        }

    Stratum Object:

        {
            signatures: <optional list of Signature objects for the parent ciphertext at this stratum of encryption>,

            encryption_algorithm: <encryption type label>,

            key_uid: <optional uuid of this specific encryption stratum>,

            # Then we have either:
            key_ciphertext: <opaque multi-encrypted key bytestring>,
            key_encryption_strata: <(optional) list of Stratum Objects targeting key_ciphertext, in order of application>,
            # or:
            key_escrow: <Escrow Entity object able to decrypt the parent data/key ciphertext at this stratum of encryption>,
        }

    Signature object:

        {
            signature_algorithm: <signature type label>,
            signature_payload: <opaque signature bytestring>,
            signature_escrow: <Escrow Entity object which signed the parent data/key ciphertext>,
            signature_uid: <optional uuid of this specific signature object>,
        }

    Escrow Entity:

        {
            escrow_type: <"standalone", "shared_secret" or other special values>,

            escrow_identity: <Public UUID or list of public UUIDs of escrow(s)>,

            escrow_operation_uid: <optional uuid of this specific escrow operation>,
        }


Example
---------

A minimal container configuration in python, with a single encryption layer and its single signature, both backed by the "local" escrow service of the device; this format can't be used in real life of course, since the data is not protected against illegal reads::

    from wacryptolib.escrow import LOCAL_ESCROW_PLACEHOLDER

    CONFIG = dict(
        data_encryption_strata=[
            dict(
                data_encryption_algo="AES_CBC",
                key_encryption_strata=[
                    dict(
                        escrow_key_type="RSA",
                        key_encryption_algo="RSA_OAEP",
                        key_escrow=LOCAL_ESCROW_PLACEHOLDER,
                    )
                ],
                data_signatures=[
                    dict(
                        signature_key_type="DSA",
                        signature_algo="DSS",
                        signature_escrow=LOCAL_ESCROW_PLACEHOLDER,
                    )
                ],
            )
        ]
    )


The corresponding container content, in Pymongo's Extended Json format::


  {
      "container_format": "WA_0.1a",
      "container_uid": {
          "$binary": {
              "base64": "UEpBPq23RMagS9aTDa5I1g==",
              "subType": "03"
          }
      },
      "data_ciphertext": {
          "$binary": {
              "base64": "eyJjaXBoZXJuYXJ5IjogeyJiY...jQiOiA1YlRiMDAifX19",
              "subType": "00"
          }
      },
      "data_encryption_strata": [
          {
              "data_encryption_algo": "AES_CBC",
              "data_signatures": [
                  {
                      "signature_algo": "DSS",
                      "signature_escrow": "_local_",
                      "signature_key_type": "DSA",
                      "signature_value": {
                          "digest": {
                              "$binary": {
                                  "base64": "uJm8Zis/fNI...u9Zy36aeOOOmiXvk=",
                                  "subType": "00"
                              }
                          },
                          "timestamp_utc": {
                              "$numberInt": "1570722817"
                          }
                      }
                  }
              ],
              "key_ciphertext": {
                  "$binary": {
                      "base64": "eyJkaWdlc3RfbGlzdCI6I...UeXBlIjogIjAwIn19XX0=",
                      "subType": "00"
                  }
              },
              "key_encryption_strata": [
                  {
                      "escrow_key_type": "RSA",
                      "key_encryption_algo": "RSA_OAEP",
                      "key_escrow": "_local_"
                  }
              ]
          }
      ],
      "keychain_uid": {
          "$binary": {
              "base64": "OvJb4C/oSke+/QG5Im0Mng==",
              "subType": "03"
          }
      }
  }
