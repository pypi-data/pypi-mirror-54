# Generated from ES.g4 by ANTLR 4.7.2
# encoding: utf-8
from antlr4 import *
from io import StringIO
from typing.io import TextIO
import sys

def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3\30")
        buf.write("|\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7\4\b")
        buf.write("\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\3\2\3\2")
        buf.write("\3\2\3\2\3\3\3\3\3\3\5\3\"\n\3\3\3\3\3\3\3\5\3\'\n\3\3")
        buf.write("\3\3\3\3\3\5\3,\n\3\3\4\3\4\3\4\3\4\3\4\3\4\3\4\3\4\3")
        buf.write("\4\5\4\67\n\4\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\5\5")
        buf.write("B\n\5\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\5\6M\n\6\3\7")
        buf.write("\3\7\3\7\3\7\3\7\3\7\5\7U\n\7\3\7\3\7\3\7\3\7\3\7\3\7")
        buf.write("\5\7]\n\7\3\7\3\7\3\7\5\7b\n\7\3\b\3\b\3\b\3\b\3\t\3\t")
        buf.write("\3\t\3\t\3\n\3\n\3\n\3\n\3\13\3\13\3\13\3\13\3\f\3\f\3")
        buf.write("\f\3\f\3\r\3\r\3\r\3\r\3\r\2\2\16\2\4\6\b\n\f\16\20\22")
        buf.write("\24\26\30\2\2\2\u0085\2\32\3\2\2\2\4+\3\2\2\2\6\66\3\2")
        buf.write("\2\2\bA\3\2\2\2\nL\3\2\2\2\fa\3\2\2\2\16c\3\2\2\2\20g")
        buf.write("\3\2\2\2\22k\3\2\2\2\24o\3\2\2\2\26s\3\2\2\2\30w\3\2\2")
        buf.write("\2\32\33\7\3\2\2\33\34\5\4\3\2\34\35\7\4\2\2\35\3\3\2")
        buf.write("\2\2\36\"\5\6\4\2\37\"\5\n\6\2 \"\5\b\5\2!\36\3\2\2\2")
        buf.write("!\37\3\2\2\2! \3\2\2\2\",\3\2\2\2#\'\5\6\4\2$\'\5\n\6")
        buf.write("\2%\'\5\b\5\2&#\3\2\2\2&$\3\2\2\2&%\3\2\2\2\'(\3\2\2\2")
        buf.write("()\7\5\2\2)*\5\4\3\2*,\3\2\2\2+!\3\2\2\2+&\3\2\2\2,\5")
        buf.write("\3\2\2\2-.\7\6\2\2./\5\f\7\2/\60\7\7\2\2\60\67\3\2\2\2")
        buf.write("\61\67\7\b\2\2\62\63\7\6\2\2\63\64\5\2\2\2\64\65\7\7\2")
        buf.write("\2\65\67\3\2\2\2\66-\3\2\2\2\66\61\3\2\2\2\66\62\3\2\2")
        buf.write("\2\67\7\3\2\2\289\7\t\2\29:\5\f\7\2:;\7\7\2\2;B\3\2\2")
        buf.write("\2<B\7\n\2\2=>\7\t\2\2>?\5\2\2\2?@\7\7\2\2@B\3\2\2\2A")
        buf.write("8\3\2\2\2A<\3\2\2\2A=\3\2\2\2B\t\3\2\2\2CD\7\13\2\2DE")
        buf.write("\5\f\7\2EF\7\7\2\2FM\3\2\2\2GM\7\f\2\2HI\7\13\2\2IJ\5")
        buf.write("\2\2\2JK\7\7\2\2KM\3\2\2\2LC\3\2\2\2LG\3\2\2\2LH\3\2\2")
        buf.write("\2M\13\3\2\2\2NU\5\26\f\2OU\5\24\13\2PU\5\20\t\2QU\5\22")
        buf.write("\n\2RU\5\16\b\2SU\5\30\r\2TN\3\2\2\2TO\3\2\2\2TP\3\2\2")
        buf.write("\2TQ\3\2\2\2TR\3\2\2\2TS\3\2\2\2Ub\3\2\2\2V]\5\26\f\2")
        buf.write("W]\5\24\13\2X]\5\20\t\2Y]\5\22\n\2Z]\5\16\b\2[]\5\30\r")
        buf.write("\2\\V\3\2\2\2\\W\3\2\2\2\\X\3\2\2\2\\Y\3\2\2\2\\Z\3\2")
        buf.write("\2\2\\[\3\2\2\2]^\3\2\2\2^_\7\5\2\2_`\5\f\7\2`b\3\2\2")
        buf.write("\2aT\3\2\2\2a\\\3\2\2\2b\r\3\2\2\2cd\7\r\2\2de\7\23\2")
        buf.write("\2ef\7\4\2\2f\17\3\2\2\2gh\7\16\2\2hi\7\23\2\2ij\7\4\2")
        buf.write("\2j\21\3\2\2\2kl\7\17\2\2lm\7\23\2\2mn\7\4\2\2n\23\3\2")
        buf.write("\2\2op\7\20\2\2pq\7\23\2\2qr\7\4\2\2r\25\3\2\2\2st\7\21")
        buf.write("\2\2tu\7\23\2\2uv\7\4\2\2v\27\3\2\2\2wx\7\22\2\2xy\7\23")
        buf.write("\2\2yz\7\4\2\2z\31\3\2\2\2\13!&+\66ALT\\a")
        return buf.getvalue()


class ESParser ( Parser ):

    grammarFileName = "ES.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'{\"bool\":{'", "'}}'", "','", "'\"must_not\":['", 
                     "']'", "'\"must_not\":[]'", "'\"should\":['", "'\"should\":[]'", 
                     "'\"must\":['", "'\"must\":[]'", "'{\"match\":{'", 
                     "'{\"not_exists\":{'", "'{\"exists\":{'", "'{\"range\":{'", 
                     "'{\"term\":{'", "'{\"query_string\":{'", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "':'" ]

    symbolicNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "KVPAIR", "DICT", "KEY", "VALUE", "EQ", 
                      "WS" ]

    RULE_boolean = 0
    RULE_boolfilter = 1
    RULE_mustnot = 2
    RULE_should = 3
    RULE_must = 4
    RULE_filterrule = 5
    RULE_matchfilter = 6
    RULE_notexists = 7
    RULE_exists = 8
    RULE_rangerule = 9
    RULE_term = 10
    RULE_querystring = 11

    ruleNames =  [ "boolean", "boolfilter", "mustnot", "should", "must", 
                   "filterrule", "matchfilter", "notexists", "exists", "rangerule", 
                   "term", "querystring" ]

    EOF = Token.EOF
    T__0=1
    T__1=2
    T__2=3
    T__3=4
    T__4=5
    T__5=6
    T__6=7
    T__7=8
    T__8=9
    T__9=10
    T__10=11
    T__11=12
    T__12=13
    T__13=14
    T__14=15
    T__15=16
    KVPAIR=17
    DICT=18
    KEY=19
    VALUE=20
    EQ=21
    WS=22

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.7.2")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None



    class BooleanContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def boolfilter(self):
            return self.getTypedRuleContext(ESParser.BoolfilterContext,0)


        def getRuleIndex(self):
            return ESParser.RULE_boolean

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBoolean" ):
                listener.enterBoolean(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBoolean" ):
                listener.exitBoolean(self)




    def boolean(self):

        localctx = ESParser.BooleanContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_boolean)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 24
            self.match(ESParser.T__0)
            self.state = 25
            self.boolfilter()
            self.state = 26
            self.match(ESParser.T__1)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class BoolfilterContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def mustnot(self):
            return self.getTypedRuleContext(ESParser.MustnotContext,0)


        def must(self):
            return self.getTypedRuleContext(ESParser.MustContext,0)


        def should(self):
            return self.getTypedRuleContext(ESParser.ShouldContext,0)


        def boolfilter(self):
            return self.getTypedRuleContext(ESParser.BoolfilterContext,0)


        def getRuleIndex(self):
            return ESParser.RULE_boolfilter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBoolfilter" ):
                listener.enterBoolfilter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBoolfilter" ):
                listener.exitBoolfilter(self)




    def boolfilter(self):

        localctx = ESParser.BoolfilterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_boolfilter)
        try:
            self.state = 41
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,2,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 31
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [ESParser.T__3, ESParser.T__5]:
                    self.state = 28
                    self.mustnot()
                    pass
                elif token in [ESParser.T__8, ESParser.T__9]:
                    self.state = 29
                    self.must()
                    pass
                elif token in [ESParser.T__6, ESParser.T__7]:
                    self.state = 30
                    self.should()
                    pass
                else:
                    raise NoViableAltException(self)

                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 36
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [ESParser.T__3, ESParser.T__5]:
                    self.state = 33
                    self.mustnot()
                    pass
                elif token in [ESParser.T__8, ESParser.T__9]:
                    self.state = 34
                    self.must()
                    pass
                elif token in [ESParser.T__6, ESParser.T__7]:
                    self.state = 35
                    self.should()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 38
                self.match(ESParser.T__2)
                self.state = 39
                self.boolfilter()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class MustnotContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def filterrule(self):
            return self.getTypedRuleContext(ESParser.FilterruleContext,0)


        def boolean(self):
            return self.getTypedRuleContext(ESParser.BooleanContext,0)


        def getRuleIndex(self):
            return ESParser.RULE_mustnot

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMustnot" ):
                listener.enterMustnot(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMustnot" ):
                listener.exitMustnot(self)




    def mustnot(self):

        localctx = ESParser.MustnotContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_mustnot)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 52
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,3,self._ctx)
            if la_ == 1:
                self.state = 43
                self.match(ESParser.T__3)
                self.state = 44
                self.filterrule()
                self.state = 45
                self.match(ESParser.T__4)
                pass

            elif la_ == 2:
                self.state = 47
                self.match(ESParser.T__5)
                pass

            elif la_ == 3:
                self.state = 48
                self.match(ESParser.T__3)
                self.state = 49
                self.boolean()
                self.state = 50
                self.match(ESParser.T__4)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ShouldContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def filterrule(self):
            return self.getTypedRuleContext(ESParser.FilterruleContext,0)


        def boolean(self):
            return self.getTypedRuleContext(ESParser.BooleanContext,0)


        def getRuleIndex(self):
            return ESParser.RULE_should

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterShould" ):
                listener.enterShould(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitShould" ):
                listener.exitShould(self)




    def should(self):

        localctx = ESParser.ShouldContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_should)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 63
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,4,self._ctx)
            if la_ == 1:
                self.state = 54
                self.match(ESParser.T__6)
                self.state = 55
                self.filterrule()
                self.state = 56
                self.match(ESParser.T__4)
                pass

            elif la_ == 2:
                self.state = 58
                self.match(ESParser.T__7)
                pass

            elif la_ == 3:
                self.state = 59
                self.match(ESParser.T__6)
                self.state = 60
                self.boolean()
                self.state = 61
                self.match(ESParser.T__4)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class MustContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def filterrule(self):
            return self.getTypedRuleContext(ESParser.FilterruleContext,0)


        def boolean(self):
            return self.getTypedRuleContext(ESParser.BooleanContext,0)


        def getRuleIndex(self):
            return ESParser.RULE_must

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMust" ):
                listener.enterMust(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMust" ):
                listener.exitMust(self)




    def must(self):

        localctx = ESParser.MustContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_must)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 74
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,5,self._ctx)
            if la_ == 1:
                self.state = 65
                self.match(ESParser.T__8)
                self.state = 66
                self.filterrule()
                self.state = 67
                self.match(ESParser.T__4)
                pass

            elif la_ == 2:
                self.state = 69
                self.match(ESParser.T__9)
                pass

            elif la_ == 3:
                self.state = 70
                self.match(ESParser.T__8)
                self.state = 71
                self.boolean()
                self.state = 72
                self.match(ESParser.T__4)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class FilterruleContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def term(self):
            return self.getTypedRuleContext(ESParser.TermContext,0)


        def rangerule(self):
            return self.getTypedRuleContext(ESParser.RangeruleContext,0)


        def notexists(self):
            return self.getTypedRuleContext(ESParser.NotexistsContext,0)


        def exists(self):
            return self.getTypedRuleContext(ESParser.ExistsContext,0)


        def matchfilter(self):
            return self.getTypedRuleContext(ESParser.MatchfilterContext,0)


        def querystring(self):
            return self.getTypedRuleContext(ESParser.QuerystringContext,0)


        def filterrule(self):
            return self.getTypedRuleContext(ESParser.FilterruleContext,0)


        def getRuleIndex(self):
            return ESParser.RULE_filterrule

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFilterrule" ):
                listener.enterFilterrule(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFilterrule" ):
                listener.exitFilterrule(self)




    def filterrule(self):

        localctx = ESParser.FilterruleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_filterrule)
        try:
            self.state = 95
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,8,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 82
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [ESParser.T__14]:
                    self.state = 76
                    self.term()
                    pass
                elif token in [ESParser.T__13]:
                    self.state = 77
                    self.rangerule()
                    pass
                elif token in [ESParser.T__11]:
                    self.state = 78
                    self.notexists()
                    pass
                elif token in [ESParser.T__12]:
                    self.state = 79
                    self.exists()
                    pass
                elif token in [ESParser.T__10]:
                    self.state = 80
                    self.matchfilter()
                    pass
                elif token in [ESParser.T__15]:
                    self.state = 81
                    self.querystring()
                    pass
                else:
                    raise NoViableAltException(self)

                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 90
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [ESParser.T__14]:
                    self.state = 84
                    self.term()
                    pass
                elif token in [ESParser.T__13]:
                    self.state = 85
                    self.rangerule()
                    pass
                elif token in [ESParser.T__11]:
                    self.state = 86
                    self.notexists()
                    pass
                elif token in [ESParser.T__12]:
                    self.state = 87
                    self.exists()
                    pass
                elif token in [ESParser.T__10]:
                    self.state = 88
                    self.matchfilter()
                    pass
                elif token in [ESParser.T__15]:
                    self.state = 89
                    self.querystring()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 92
                self.match(ESParser.T__2)
                self.state = 93
                self.filterrule()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class MatchfilterContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KVPAIR(self):
            return self.getToken(ESParser.KVPAIR, 0)

        def getRuleIndex(self):
            return ESParser.RULE_matchfilter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMatchfilter" ):
                listener.enterMatchfilter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMatchfilter" ):
                listener.exitMatchfilter(self)




    def matchfilter(self):

        localctx = ESParser.MatchfilterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_matchfilter)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 97
            self.match(ESParser.T__10)
            self.state = 98
            self.match(ESParser.KVPAIR)
            self.state = 99
            self.match(ESParser.T__1)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class NotexistsContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KVPAIR(self):
            return self.getToken(ESParser.KVPAIR, 0)

        def getRuleIndex(self):
            return ESParser.RULE_notexists

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNotexists" ):
                listener.enterNotexists(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNotexists" ):
                listener.exitNotexists(self)




    def notexists(self):

        localctx = ESParser.NotexistsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_notexists)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 101
            self.match(ESParser.T__11)
            self.state = 102
            self.match(ESParser.KVPAIR)
            self.state = 103
            self.match(ESParser.T__1)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ExistsContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KVPAIR(self):
            return self.getToken(ESParser.KVPAIR, 0)

        def getRuleIndex(self):
            return ESParser.RULE_exists

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExists" ):
                listener.enterExists(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExists" ):
                listener.exitExists(self)




    def exists(self):

        localctx = ESParser.ExistsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_exists)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 105
            self.match(ESParser.T__12)
            self.state = 106
            self.match(ESParser.KVPAIR)
            self.state = 107
            self.match(ESParser.T__1)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class RangeruleContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KVPAIR(self):
            return self.getToken(ESParser.KVPAIR, 0)

        def getRuleIndex(self):
            return ESParser.RULE_rangerule

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRangerule" ):
                listener.enterRangerule(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRangerule" ):
                listener.exitRangerule(self)




    def rangerule(self):

        localctx = ESParser.RangeruleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_rangerule)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 109
            self.match(ESParser.T__13)
            self.state = 110
            self.match(ESParser.KVPAIR)
            self.state = 111
            self.match(ESParser.T__1)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class TermContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KVPAIR(self):
            return self.getToken(ESParser.KVPAIR, 0)

        def getRuleIndex(self):
            return ESParser.RULE_term

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTerm" ):
                listener.enterTerm(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTerm" ):
                listener.exitTerm(self)




    def term(self):

        localctx = ESParser.TermContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_term)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 113
            self.match(ESParser.T__14)
            self.state = 114
            self.match(ESParser.KVPAIR)
            self.state = 115
            self.match(ESParser.T__1)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class QuerystringContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KVPAIR(self):
            return self.getToken(ESParser.KVPAIR, 0)

        def getRuleIndex(self):
            return ESParser.RULE_querystring

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterQuerystring" ):
                listener.enterQuerystring(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitQuerystring" ):
                listener.exitQuerystring(self)




    def querystring(self):

        localctx = ESParser.QuerystringContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_querystring)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 117
            self.match(ESParser.T__15)
            self.state = 118
            self.match(ESParser.KVPAIR)
            self.state = 119
            self.match(ESParser.T__1)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





