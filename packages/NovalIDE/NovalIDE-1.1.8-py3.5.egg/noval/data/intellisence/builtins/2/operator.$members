(dp0
S'doc'
p1
S"Operator interface.\n\nThis module exports a set of functions implemented in C corresponding\nto the intrinsic operators of Python.  For example, operator.add(x, y)\nis equivalent to the expression x+y.  The function names are those\nused for special methods; variants without leading and trailing\n'__' are also provided for convenience."
p2
sS'is_builtin'
p3
I01
sS'childs'
p4
(lp5
(dp6
g1
S'abs(a) -- Same as abs(a).'
p7
sg3
I01
sS'type'
p8
I2
sS'name'
p9
S'__abs__'
p10
sa(dp11
g1
S'add(a, b) -- Same as a + b.'
p12
sg3
I01
sg8
I2
sg9
S'__add__'
p13
sa(dp14
g1
S'and_(a, b) -- Same as a & b.'
p15
sg3
I01
sg8
I2
sg9
S'__and__'
p16
sa(dp17
g1
S'concat(a, b) -- Same as a + b, for a and b sequences.'
p18
sg3
I01
sg8
I2
sg9
S'__concat__'
p19
sa(dp20
g1
S'contains(a, b) -- Same as b in a (note reversed operands).'
p21
sg3
I01
sg8
I2
sg9
S'__contains__'
p22
sa(dp23
g1
S'delitem(a, b) -- Same as del a[b].'
p24
sg3
I01
sg8
I2
sg9
S'__delitem__'
p25
sa(dp26
g1
S'delslice(a, b, c) -- Same as del a[b:c].'
p27
sg3
I01
sg8
I2
sg9
S'__delslice__'
p28
sa(dp29
g1
S'div(a, b) -- Same as a / b when __future__.division is not in effect.'
p30
sg3
I01
sg8
I2
sg9
S'__div__'
p31
sa(dp32
g3
I01
sg8
I5
sg9
S'__doc__'
p33
sa(dp34
g1
S'eq(a, b) -- Same as a==b.'
p35
sg3
I01
sg8
I2
sg9
S'__eq__'
p36
sa(dp37
g1
S'floordiv(a, b) -- Same as a // b.'
p38
sg3
I01
sg8
I2
sg9
S'__floordiv__'
p39
sa(dp40
g1
S'ge(a, b) -- Same as a>=b.'
p41
sg3
I01
sg8
I2
sg9
S'__ge__'
p42
sa(dp43
g1
S'getitem(a, b) -- Same as a[b].'
p44
sg3
I01
sg8
I2
sg9
S'__getitem__'
p45
sa(dp46
g1
S'getslice(a, b, c) -- Same as a[b:c].'
p47
sg3
I01
sg8
I2
sg9
S'__getslice__'
p48
sa(dp49
g1
S'gt(a, b) -- Same as a>b.'
p50
sg3
I01
sg8
I2
sg9
S'__gt__'
p51
sa(dp52
g1
S'a = iadd(a, b) -- Same as a += b.'
p53
sg3
I01
sg8
I2
sg9
S'__iadd__'
p54
sa(dp55
g1
S'a = iand(a, b) -- Same as a &= b.'
p56
sg3
I01
sg8
I2
sg9
S'__iand__'
p57
sa(dp58
g1
S'a = iconcat(a, b) -- Same as a += b, for a and b sequences.'
p59
sg3
I01
sg8
I2
sg9
S'__iconcat__'
p60
sa(dp61
g1
S'a = idiv(a, b) -- Same as a /= b when __future__.division is not in effect.'
p62
sg3
I01
sg8
I2
sg9
S'__idiv__'
p63
sa(dp64
g1
S'a = ifloordiv(a, b) -- Same as a //= b.'
p65
sg3
I01
sg8
I2
sg9
S'__ifloordiv__'
p66
sa(dp67
g1
S'a = ilshift(a, b) -- Same as a <<= b.'
p68
sg3
I01
sg8
I2
sg9
S'__ilshift__'
p69
sa(dp70
g1
S'a = imod(a, b) -- Same as a %= b.'
p71
sg3
I01
sg8
I2
sg9
S'__imod__'
p72
sa(dp73
g1
S'a = imul(a, b) -- Same as a *= b.'
p74
sg3
I01
sg8
I2
sg9
S'__imul__'
p75
sa(dp76
g1
S'index(a) -- Same as a.__index__()'
p77
sg3
I01
sg8
I2
sg9
S'__index__'
p78
sa(dp79
g1
S'inv(a) -- Same as ~a.'
p80
sg3
I01
sg8
I2
sg9
S'__inv__'
p81
sa(dp82
g1
S'invert(a) -- Same as ~a.'
p83
sg3
I01
sg8
I2
sg9
S'__invert__'
p84
sa(dp85
g1
S'a = ior(a, b) -- Same as a |= b.'
p86
sg3
I01
sg8
I2
sg9
S'__ior__'
p87
sa(dp88
g1
S'a = ipow(a, b) -- Same as a **= b.'
p89
sg3
I01
sg8
I2
sg9
S'__ipow__'
p90
sa(dp91
g1
S'a = irepeat(a, b) -- Same as a *= b, where a is a sequence, and b is an integer.'
p92
sg3
I01
sg8
I2
sg9
S'__irepeat__'
p93
sa(dp94
g1
S'a = irshift(a, b) -- Same as a >>= b.'
p95
sg3
I01
sg8
I2
sg9
S'__irshift__'
p96
sa(dp97
g1
S'a = isub(a, b) -- Same as a -= b.'
p98
sg3
I01
sg8
I2
sg9
S'__isub__'
p99
sa(dp100
g1
S'a = itruediv(a, b) -- Same as a /= b when __future__.division is in effect.'
p101
sg3
I01
sg8
I2
sg9
S'__itruediv__'
p102
sa(dp103
g1
S'a = ixor(a, b) -- Same as a ^= b.'
p104
sg3
I01
sg8
I2
sg9
S'__ixor__'
p105
sa(dp106
g1
S'le(a, b) -- Same as a<=b.'
p107
sg3
I01
sg8
I2
sg9
S'__le__'
p108
sa(dp109
g1
S'lshift(a, b) -- Same as a << b.'
p110
sg3
I01
sg8
I2
sg9
S'__lshift__'
p111
sa(dp112
g1
S'lt(a, b) -- Same as a<b.'
p113
sg3
I01
sg8
I2
sg9
S'__lt__'
p114
sa(dp115
g1
S'mod(a, b) -- Same as a % b.'
p116
sg3
I01
sg8
I2
sg9
S'__mod__'
p117
sa(dp118
g1
S'mul(a, b) -- Same as a * b.'
p119
sg3
I01
sg8
I2
sg9
S'__mul__'
p120
sa(dp121
g3
I01
sg8
I5
sg9
S'__name__'
p122
sa(dp123
g1
S'ne(a, b) -- Same as a!=b.'
p124
sg3
I01
sg8
I2
sg9
S'__ne__'
p125
sa(dp126
g1
S'neg(a) -- Same as -a.'
p127
sg3
I01
sg8
I2
sg9
S'__neg__'
p128
sa(dp129
g1
S'not_(a) -- Same as not a.'
p130
sg3
I01
sg8
I2
sg9
S'__not__'
p131
sa(dp132
g1
S'or_(a, b) -- Same as a | b.'
p133
sg3
I01
sg8
I2
sg9
S'__or__'
p134
sa(dp135
g3
I01
sg8
I5
sg9
S'__package__'
p136
sa(dp137
g1
S'pos(a) -- Same as +a.'
p138
sg3
I01
sg8
I2
sg9
S'__pos__'
p139
sa(dp140
g1
S'pow(a, b) -- Same as a ** b.'
p141
sg3
I01
sg8
I2
sg9
S'__pow__'
p142
sa(dp143
g1
S'repeat(a, b) -- Return a * b, where a is a sequence, and b is an integer.'
p144
sg3
I01
sg8
I2
sg9
S'__repeat__'
p145
sa(dp146
g1
S'rshift(a, b) -- Same as a >> b.'
p147
sg3
I01
sg8
I2
sg9
S'__rshift__'
p148
sa(dp149
g1
S'setitem(a, b, c) -- Same as a[b] = c.'
p150
sg3
I01
sg8
I2
sg9
S'__setitem__'
p151
sa(dp152
g1
S'setslice(a, b, c, d) -- Same as a[b:c] = d.'
p153
sg3
I01
sg8
I2
sg9
S'__setslice__'
p154
sa(dp155
g1
S'sub(a, b) -- Same as a - b.'
p156
sg3
I01
sg8
I2
sg9
S'__sub__'
p157
sa(dp158
g1
S'truediv(a, b) -- Same as a / b when __future__.division is in effect.'
p159
sg3
I01
sg8
I2
sg9
S'__truediv__'
p160
sa(dp161
g1
S'xor(a, b) -- Same as a ^ b.'
p162
sg3
I01
sg8
I2
sg9
S'__xor__'
p163
sa(dp164
g1
S"compare_digest(a, b) -> bool\n\nReturn 'a == b'.  This function uses an approach designed to prevent\ntiming analysis, making it appropriate for cryptography.\na and b must both be of the same type: either str (ASCII only),\nor any type that supports the buffer protocol (e.g. bytes).\n\nNote: If a and b are of different lengths, or if an error occurs,\na timing attack could theoretically reveal information about the\ntypes and lengths of a and b--but not their values.\n"
p165
sg3
I01
sg8
I2
sg9
S'_compare_digest'
p166
sa(dp167
g1
S'abs(a) -- Same as abs(a).'
p168
sg3
I01
sg8
I2
sg9
S'abs'
p169
sa(dp170
g1
S'add(a, b) -- Same as a + b.'
p171
sg3
I01
sg8
I2
sg9
S'add'
p172
sa(dp173
g1
S'and_(a, b) -- Same as a & b.'
p174
sg3
I01
sg8
I2
sg9
S'and_'
p175
sa(dp176
g1
S"attrgetter(attr, ...) --> attrgetter object\n\nReturn a callable object that fetches the given attribute(s) from its operand.\nAfter f = attrgetter('name'), the call f(r) returns r.name.\nAfter g = attrgetter('name', 'date'), the call g(r) returns (r.name, r.date).\nAfter h = attrgetter('name.first', 'name.last'), the call h(r) returns\n(r.name.first, r.name.last)."
p177
sg3
I01
sg4
(lp178
(dp179
g3
I01
sg8
I5
sg9
S'__call__'
p180
sa(dp181
g3
I01
sg8
I5
sg9
S'__delattr__'
p182
sa(dp183
g3
I01
sg8
I5
sg9
g33
sa(dp184
g1
S'default object formatter'
p185
sg3
I01
sg8
I2
sg9
S'__format__'
p186
sa(dp187
g3
I01
sg8
I5
sg9
S'__getattribute__'
p188
sa(dp189
g3
I01
sg8
I5
sg9
S'__hash__'
p190
sa(dp191
g3
I01
sg8
I5
sg9
S'__init__'
p192
sa(dp193
g1
S'T.__new__(S, ...) -> a new object with type S, a subtype of T'
p194
sg3
I01
sg8
I2
sg9
S'__new__'
p195
sa(dp196
g1
S'helper for pickle'
p197
sg3
I01
sg8
I2
sg9
S'__reduce__'
p198
sa(dp199
g1
S'helper for pickle'
p200
sg3
I01
sg8
I2
sg9
S'__reduce_ex__'
p201
sa(dp202
g3
I01
sg8
I5
sg9
S'__repr__'
p203
sa(dp204
g3
I01
sg8
I5
sg9
S'__setattr__'
p205
sa(dp206
g1
S'__sizeof__() -> int\nsize of object in memory, in bytes'
p207
sg3
I01
sg8
I2
sg9
S'__sizeof__'
p208
sa(dp209
g3
I01
sg8
I5
sg9
S'__str__'
p210
sa(dp211
g1
S'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
p212
sg3
I01
sg8
I2
sg9
S'__subclasshook__'
p213
sasg8
I3
sg9
S'attrgetter'
p214
sa(dp215
g1
S'concat(a, b) -- Same as a + b, for a and b sequences.'
p216
sg3
I01
sg8
I2
sg9
S'concat'
p217
sa(dp218
g1
S'contains(a, b) -- Same as b in a (note reversed operands).'
p219
sg3
I01
sg8
I2
sg9
S'contains'
p220
sa(dp221
g1
S'countOf(a, b) -- Return the number of times b occurs in a.'
p222
sg3
I01
sg8
I2
sg9
S'countOf'
p223
sa(dp224
g1
S'delitem(a, b) -- Same as del a[b].'
p225
sg3
I01
sg8
I2
sg9
S'delitem'
p226
sa(dp227
g1
S'delslice(a, b, c) -- Same as del a[b:c].'
p228
sg3
I01
sg8
I2
sg9
S'delslice'
p229
sa(dp230
g1
S'div(a, b) -- Same as a / b when __future__.division is not in effect.'
p231
sg3
I01
sg8
I2
sg9
S'div'
p232
sa(dp233
g1
S'eq(a, b) -- Same as a==b.'
p234
sg3
I01
sg8
I2
sg9
S'eq'
p235
sa(dp236
g1
S'floordiv(a, b) -- Same as a // b.'
p237
sg3
I01
sg8
I2
sg9
S'floordiv'
p238
sa(dp239
g1
S'ge(a, b) -- Same as a>=b.'
p240
sg3
I01
sg8
I2
sg9
S'ge'
p241
sa(dp242
g1
S'getitem(a, b) -- Same as a[b].'
p243
sg3
I01
sg8
I2
sg9
S'getitem'
p244
sa(dp245
g1
S'getslice(a, b, c) -- Same as a[b:c].'
p246
sg3
I01
sg8
I2
sg9
S'getslice'
p247
sa(dp248
g1
S'gt(a, b) -- Same as a>b.'
p249
sg3
I01
sg8
I2
sg9
S'gt'
p250
sa(dp251
g1
S'a = iadd(a, b) -- Same as a += b.'
p252
sg3
I01
sg8
I2
sg9
S'iadd'
p253
sa(dp254
g1
S'a = iand(a, b) -- Same as a &= b.'
p255
sg3
I01
sg8
I2
sg9
S'iand'
p256
sa(dp257
g1
S'a = iconcat(a, b) -- Same as a += b, for a and b sequences.'
p258
sg3
I01
sg8
I2
sg9
S'iconcat'
p259
sa(dp260
g1
S'a = idiv(a, b) -- Same as a /= b when __future__.division is not in effect.'
p261
sg3
I01
sg8
I2
sg9
S'idiv'
p262
sa(dp263
g1
S'a = ifloordiv(a, b) -- Same as a //= b.'
p264
sg3
I01
sg8
I2
sg9
S'ifloordiv'
p265
sa(dp266
g1
S'a = ilshift(a, b) -- Same as a <<= b.'
p267
sg3
I01
sg8
I2
sg9
S'ilshift'
p268
sa(dp269
g1
S'a = imod(a, b) -- Same as a %= b.'
p270
sg3
I01
sg8
I2
sg9
S'imod'
p271
sa(dp272
g1
S'a = imul(a, b) -- Same as a *= b.'
p273
sg3
I01
sg8
I2
sg9
S'imul'
p274
sa(dp275
g1
S'index(a) -- Same as a.__index__()'
p276
sg3
I01
sg8
I2
sg9
S'index'
p277
sa(dp278
g1
S'indexOf(a, b) -- Return the first index of b in a.'
p279
sg3
I01
sg8
I2
sg9
S'indexOf'
p280
sa(dp281
g1
S'inv(a) -- Same as ~a.'
p282
sg3
I01
sg8
I2
sg9
S'inv'
p283
sa(dp284
g1
S'invert(a) -- Same as ~a.'
p285
sg3
I01
sg8
I2
sg9
S'invert'
p286
sa(dp287
g1
S'a = ior(a, b) -- Same as a |= b.'
p288
sg3
I01
sg8
I2
sg9
S'ior'
p289
sa(dp290
g1
S'a = ipow(a, b) -- Same as a **= b.'
p291
sg3
I01
sg8
I2
sg9
S'ipow'
p292
sa(dp293
g1
S'a = irepeat(a, b) -- Same as a *= b, where a is a sequence, and b is an integer.'
p294
sg3
I01
sg8
I2
sg9
S'irepeat'
p295
sa(dp296
g1
S'a = irshift(a, b) -- Same as a >>= b.'
p297
sg3
I01
sg8
I2
sg9
S'irshift'
p298
sa(dp299
g1
S'isCallable(a) -- Same as callable(a).'
p300
sg3
I01
sg8
I2
sg9
S'isCallable'
p301
sa(dp302
g1
S'isMappingType(a) -- Return True if a has a mapping type, False otherwise.'
p303
sg3
I01
sg8
I2
sg9
S'isMappingType'
p304
sa(dp305
g1
S'isNumberType(a) -- Return True if a has a numeric type, False otherwise.'
p306
sg3
I01
sg8
I2
sg9
S'isNumberType'
p307
sa(dp308
g1
S'isSequenceType(a) -- Return True if a has a sequence type, False otherwise.'
p309
sg3
I01
sg8
I2
sg9
S'isSequenceType'
p310
sa(dp311
g1
S'is_(a, b) -- Same as a is b.'
p312
sg3
I01
sg8
I2
sg9
S'is_'
p313
sa(dp314
g1
S'is_not(a, b) -- Same as a is not b.'
p315
sg3
I01
sg8
I2
sg9
S'is_not'
p316
sa(dp317
g1
S'a = isub(a, b) -- Same as a -= b.'
p318
sg3
I01
sg8
I2
sg9
S'isub'
p319
sa(dp320
g1
S'itemgetter(item, ...) --> itemgetter object\n\nReturn a callable object that fetches the given item(s) from its operand.\nAfter f = itemgetter(2), the call f(r) returns r[2].\nAfter g = itemgetter(2, 5, 3), the call g(r) returns (r[2], r[5], r[3])'
p321
sg3
I01
sg4
(lp322
(dp323
g3
I01
sg8
I5
sg9
g180
sa(dp324
g3
I01
sg8
I5
sg9
g182
sa(dp325
g3
I01
sg8
I5
sg9
g33
sa(dp326
g1
S'default object formatter'
p327
sg3
I01
sg8
I2
sg9
g186
sa(dp328
g3
I01
sg8
I5
sg9
g188
sa(dp329
g3
I01
sg8
I5
sg9
g190
sa(dp330
g3
I01
sg8
I5
sg9
g192
sa(dp331
g1
S'T.__new__(S, ...) -> a new object with type S, a subtype of T'
p332
sg3
I01
sg8
I2
sg9
g195
sa(dp333
g1
S'helper for pickle'
p334
sg3
I01
sg8
I2
sg9
g198
sa(dp335
g1
S'helper for pickle'
p336
sg3
I01
sg8
I2
sg9
g201
sa(dp337
g3
I01
sg8
I5
sg9
g203
sa(dp338
g3
I01
sg8
I5
sg9
g205
sa(dp339
g1
S'__sizeof__() -> int\nsize of object in memory, in bytes'
p340
sg3
I01
sg8
I2
sg9
g208
sa(dp341
g3
I01
sg8
I5
sg9
g210
sa(dp342
g1
S'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
p343
sg3
I01
sg8
I2
sg9
g213
sasg8
I3
sg9
S'itemgetter'
p344
sa(dp345
g1
S'a = itruediv(a, b) -- Same as a /= b when __future__.division is in effect.'
p346
sg3
I01
sg8
I2
sg9
S'itruediv'
p347
sa(dp348
g1
S'a = ixor(a, b) -- Same as a ^= b.'
p349
sg3
I01
sg8
I2
sg9
S'ixor'
p350
sa(dp351
g1
S'le(a, b) -- Same as a<=b.'
p352
sg3
I01
sg8
I2
sg9
S'le'
p353
sa(dp354
g1
S'lshift(a, b) -- Same as a << b.'
p355
sg3
I01
sg8
I2
sg9
S'lshift'
p356
sa(dp357
g1
S'lt(a, b) -- Same as a<b.'
p358
sg3
I01
sg8
I2
sg9
S'lt'
p359
sa(dp360
g1
S"methodcaller(name, ...) --> methodcaller object\n\nReturn a callable object that calls the given method on its operand.\nAfter f = methodcaller('name'), the call f(r) returns r.name().\nAfter g = methodcaller('name', 'date', foo=1), the call g(r) returns\nr.name('date', foo=1)."
p361
sg3
I01
sg4
(lp362
(dp363
g3
I01
sg8
I5
sg9
g180
sa(dp364
g3
I01
sg8
I5
sg9
g182
sa(dp365
g3
I01
sg8
I5
sg9
g33
sa(dp366
g1
S'default object formatter'
p367
sg3
I01
sg8
I2
sg9
g186
sa(dp368
g3
I01
sg8
I5
sg9
g188
sa(dp369
g3
I01
sg8
I5
sg9
g190
sa(dp370
g3
I01
sg8
I5
sg9
g192
sa(dp371
g1
S'T.__new__(S, ...) -> a new object with type S, a subtype of T'
p372
sg3
I01
sg8
I2
sg9
g195
sa(dp373
g1
S'helper for pickle'
p374
sg3
I01
sg8
I2
sg9
g198
sa(dp375
g1
S'helper for pickle'
p376
sg3
I01
sg8
I2
sg9
g201
sa(dp377
g3
I01
sg8
I5
sg9
g203
sa(dp378
g3
I01
sg8
I5
sg9
g205
sa(dp379
g1
S'__sizeof__() -> int\nsize of object in memory, in bytes'
p380
sg3
I01
sg8
I2
sg9
g208
sa(dp381
g3
I01
sg8
I5
sg9
g210
sa(dp382
g1
S'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
p383
sg3
I01
sg8
I2
sg9
g213
sasg8
I3
sg9
S'methodcaller'
p384
sa(dp385
g1
S'mod(a, b) -- Same as a % b.'
p386
sg3
I01
sg8
I2
sg9
S'mod'
p387
sa(dp388
g1
S'mul(a, b) -- Same as a * b.'
p389
sg3
I01
sg8
I2
sg9
S'mul'
p390
sa(dp391
g1
S'ne(a, b) -- Same as a!=b.'
p392
sg3
I01
sg8
I2
sg9
S'ne'
p393
sa(dp394
g1
S'neg(a) -- Same as -a.'
p395
sg3
I01
sg8
I2
sg9
S'neg'
p396
sa(dp397
g1
S'not_(a) -- Same as not a.'
p398
sg3
I01
sg8
I2
sg9
S'not_'
p399
sa(dp400
g1
S'or_(a, b) -- Same as a | b.'
p401
sg3
I01
sg8
I2
sg9
S'or_'
p402
sa(dp403
g1
S'pos(a) -- Same as +a.'
p404
sg3
I01
sg8
I2
sg9
S'pos'
p405
sa(dp406
g1
S'pow(a, b) -- Same as a ** b.'
p407
sg3
I01
sg8
I2
sg9
S'pow'
p408
sa(dp409
g1
S'repeat(a, b) -- Return a * b, where a is a sequence, and b is an integer.'
p410
sg3
I01
sg8
I2
sg9
S'repeat'
p411
sa(dp412
g1
S'rshift(a, b) -- Same as a >> b.'
p413
sg3
I01
sg8
I2
sg9
S'rshift'
p414
sa(dp415
g1
S'sequenceIncludes(a, b) -- Same as b in a (note reversed operands; deprecated).'
p416
sg3
I01
sg8
I2
sg9
S'sequenceIncludes'
p417
sa(dp418
g1
S'setitem(a, b, c) -- Same as a[b] = c.'
p419
sg3
I01
sg8
I2
sg9
S'setitem'
p420
sa(dp421
g1
S'setslice(a, b, c, d) -- Same as a[b:c] = d.'
p422
sg3
I01
sg8
I2
sg9
S'setslice'
p423
sa(dp424
g1
S'sub(a, b) -- Same as a - b.'
p425
sg3
I01
sg8
I2
sg9
S'sub'
p426
sa(dp427
g1
S'truediv(a, b) -- Same as a / b when __future__.division is in effect.'
p428
sg3
I01
sg8
I2
sg9
S'truediv'
p429
sa(dp430
g1
S'truth(a) -- Return True if a is true, False otherwise.'
p431
sg3
I01
sg8
I2
sg9
S'truth'
p432
sa(dp433
g1
S'xor(a, b) -- Same as a ^ b.'
p434
sg3
I01
sg8
I2
sg9
S'xor'
p435
sasg8
I1
sg9
S'operator'
p436
s.