(dp0
Vis_builtin
p1
I01
sVchilds
p2
(lp3
(dp4
g1
I01
sVname
p5
VDN_ACCESS
p6
sVtype
p7
L5L
sa(dp8
g1
I01
sg5
VDN_ATTRIB
p9
sg7
L5L
sa(dp10
g1
I01
sg5
VDN_CREATE
p11
sg7
L5L
sa(dp12
g1
I01
sg5
VDN_DELETE
p13
sg7
L5L
sa(dp14
g1
I01
sg5
VDN_MODIFY
p15
sg7
L5L
sa(dp16
g1
I01
sg5
VDN_MULTISHOT
p17
sg7
L5L
sa(dp18
g1
I01
sg5
VDN_RENAME
p19
sg7
L5L
sa(dp20
g1
I01
sg5
VFASYNC
p21
sg7
L5L
sa(dp22
g1
I01
sg5
VFD_CLOEXEC
p23
sg7
L5L
sa(dp24
g1
I01
sg5
VF_DUPFD
p25
sg7
L5L
sa(dp26
g1
I01
sg5
VF_DUPFD_CLOEXEC
p27
sg7
L5L
sa(dp28
g1
I01
sg5
VF_EXLCK
p29
sg7
L5L
sa(dp30
g1
I01
sg5
VF_GETFD
p31
sg7
L5L
sa(dp32
g1
I01
sg5
VF_GETFL
p33
sg7
L5L
sa(dp34
g1
I01
sg5
VF_GETLEASE
p35
sg7
L5L
sa(dp36
g1
I01
sg5
VF_GETLK
p37
sg7
L5L
sa(dp38
g1
I01
sg5
VF_GETLK64
p39
sg7
L5L
sa(dp40
g1
I01
sg5
VF_GETOWN
p41
sg7
L5L
sa(dp42
g1
I01
sg5
VF_GETSIG
p43
sg7
L5L
sa(dp44
g1
I01
sg5
VF_NOTIFY
p45
sg7
L5L
sa(dp46
g1
I01
sg5
VF_RDLCK
p47
sg7
L5L
sa(dp48
g1
I01
sg5
VF_SETFD
p49
sg7
L5L
sa(dp50
g1
I01
sg5
VF_SETFL
p51
sg7
L5L
sa(dp52
g1
I01
sg5
VF_SETLEASE
p53
sg7
L5L
sa(dp54
g1
I01
sg5
VF_SETLK
p55
sg7
L5L
sa(dp56
g1
I01
sg5
VF_SETLK64
p57
sg7
L5L
sa(dp58
g1
I01
sg5
VF_SETLKW
p59
sg7
L5L
sa(dp60
g1
I01
sg5
VF_SETLKW64
p61
sg7
L5L
sa(dp62
g1
I01
sg5
VF_SETOWN
p63
sg7
L5L
sa(dp64
g1
I01
sg5
VF_SETSIG
p65
sg7
L5L
sa(dp66
g1
I01
sg5
VF_SHLCK
p67
sg7
L5L
sa(dp68
g1
I01
sg5
VF_UNLCK
p69
sg7
L5L
sa(dp70
g1
I01
sg5
VF_WRLCK
p71
sg7
L5L
sa(dp72
g1
I01
sg5
VI_ATMARK
p73
sg7
L5L
sa(dp74
g1
I01
sg5
VI_CANPUT
p75
sg7
L5L
sa(dp76
g1
I01
sg5
VI_CKBAND
p77
sg7
L5L
sa(dp78
g1
I01
sg5
VI_FDINSERT
p79
sg7
L5L
sa(dp80
g1
I01
sg5
VI_FIND
p81
sg7
L5L
sa(dp82
g1
I01
sg5
VI_FLUSH
p83
sg7
L5L
sa(dp84
g1
I01
sg5
VI_FLUSHBAND
p85
sg7
L5L
sa(dp86
g1
I01
sg5
VI_GETBAND
p87
sg7
L5L
sa(dp88
g1
I01
sg5
VI_GETCLTIME
p89
sg7
L5L
sa(dp90
g1
I01
sg5
VI_GETSIG
p91
sg7
L5L
sa(dp92
g1
I01
sg5
VI_GRDOPT
p93
sg7
L5L
sa(dp94
g1
I01
sg5
VI_GWROPT
p95
sg7
L5L
sa(dp96
g1
I01
sg5
VI_LINK
p97
sg7
L5L
sa(dp98
g1
I01
sg5
VI_LIST
p99
sg7
L5L
sa(dp100
g1
I01
sg5
VI_LOOK
p101
sg7
L5L
sa(dp102
g1
I01
sg5
VI_NREAD
p103
sg7
L5L
sa(dp104
g1
I01
sg5
VI_PEEK
p105
sg7
L5L
sa(dp106
g1
I01
sg5
VI_PLINK
p107
sg7
L5L
sa(dp108
g1
I01
sg5
VI_POP
p109
sg7
L5L
sa(dp110
g1
I01
sg5
VI_PUNLINK
p111
sg7
L5L
sa(dp112
g1
I01
sg5
VI_PUSH
p113
sg7
L5L
sa(dp114
g1
I01
sg5
VI_RECVFD
p115
sg7
L5L
sa(dp116
g1
I01
sg5
VI_SENDFD
p117
sg7
L5L
sa(dp118
g1
I01
sg5
VI_SETCLTIME
p119
sg7
L5L
sa(dp120
g1
I01
sg5
VI_SETSIG
p121
sg7
L5L
sa(dp122
g1
I01
sg5
VI_SRDOPT
p123
sg7
L5L
sa(dp124
g1
I01
sg5
VI_STR
p125
sg7
L5L
sa(dp126
g1
I01
sg5
VI_SWROPT
p127
sg7
L5L
sa(dp128
g1
I01
sg5
VI_UNLINK
p129
sg7
L5L
sa(dp130
g1
I01
sg5
VLOCK_EX
p131
sg7
L5L
sa(dp132
g1
I01
sg5
VLOCK_MAND
p133
sg7
L5L
sa(dp134
g1
I01
sg5
VLOCK_NB
p135
sg7
L5L
sa(dp136
g1
I01
sg5
VLOCK_READ
p137
sg7
L5L
sa(dp138
g1
I01
sg5
VLOCK_RW
p139
sg7
L5L
sa(dp140
g1
I01
sg5
VLOCK_SH
p141
sg7
L5L
sa(dp142
g1
I01
sg5
VLOCK_UN
p143
sg7
L5L
sa(dp144
g1
I01
sg5
VLOCK_WRITE
p145
sg7
L5L
sa(dp146
g1
I01
sg5
V__doc__
p147
sg7
L5L
sa(dp148
g1
I01
sg2
(lp149
(dp150
g1
I01
sg5
V__delattr__
p151
sg7
L5L
sa(dp152
g1
I01
sg5
V__dict__
p153
sg7
L5L
sa(dp154
g1
I01
sVdoc
p155
V__dir__() -> list\u000adefault dir() implementation
p156
sg5
V__dir__
p157
sg7
L2L
sa(dp158
g1
I01
sg5
g147
sg7
L5L
sa(dp159
g1
I01
sg5
V__eq__
p160
sg7
L5L
sa(dp161
g1
I01
sg155
Vdefault object formatter
p162
sg5
V__format__
p163
sg7
L2L
sa(dp164
g1
I01
sg5
V__ge__
p165
sg7
L5L
sa(dp166
g1
I01
sg5
V__getattribute__
p167
sg7
L5L
sa(dp168
g1
I01
sg5
V__gt__
p169
sg7
L5L
sa(dp170
g1
I01
sg5
V__hash__
p171
sg7
L5L
sa(dp172
g1
I01
sg5
V__init__
p173
sg7
L5L
sa(dp174
g1
I01
sg5
V__le__
p175
sg7
L5L
sa(dp176
g1
I01
sg5
V__lt__
p177
sg7
L5L
sa(dp178
g1
I01
sg5
V__module__
p179
sg7
L5L
sa(dp180
g1
I01
sg5
V__ne__
p181
sg7
L5L
sa(dp182
g1
I01
sg155
VCreate and return a new object.  See help(type) for accurate signature.
p183
sg5
V__new__
p184
sg7
L2L
sa(dp185
g1
I01
sg155
Vhelper for pickle
p186
sg5
V__reduce__
p187
sg7
L2L
sa(dp188
g1
I01
sg155
Vhelper for pickle
p189
sg5
V__reduce_ex__
p190
sg7
L2L
sa(dp191
g1
I01
sg5
V__repr__
p192
sg7
L5L
sa(dp193
g1
I01
sg5
V__setattr__
p194
sg7
L5L
sa(dp195
g1
I01
sg155
V__sizeof__() -> int\u000asize of object in memory, in bytes
p196
sg5
V__sizeof__
p197
sg7
L2L
sa(dp198
g1
I01
sg5
V__str__
p199
sg7
L5L
sa(dp200
g1
I01
sg155
VAbstract classes can override this to customize issubclass().\u000a\u000aThis is invoked early on by abc.ABCMeta.__subclasscheck__().\u000aIt should return True, False or NotImplemented.  If it returns\u000aNotImplemented, the normal algorithm is used.  Otherwise, it\u000aoverrides the normal algorithm (and the outcome is cached).\u000a
p201
sg5
V__subclasshook__
p202
sg7
L2L
sa(dp203
g1
I01
sg5
V__weakref__
p204
sg7
L5L
sa(dp205
g1
I01
sg5
Vcreate_module
p206
sg7
L5L
sa(dp207
g1
I01
sg5
Vexec_module
p208
sg7
L5L
sa(dp209
g1
I01
sg5
Vfind_module
p210
sg7
L5L
sa(dp211
g1
I01
sg5
Vfind_spec
p212
sg7
L5L
sa(dp213
g1
I01
sg5
Vget_code
p214
sg7
L5L
sa(dp215
g1
I01
sg5
Vget_source
p216
sg7
L5L
sa(dp217
g1
I01
sg5
Vis_package
p218
sg7
L5L
sa(dp219
g1
I01
sg5
Vload_module
p220
sg7
L5L
sa(dp221
g1
I01
sg5
Vmodule_repr
p222
sg7
L5L
sasg155
VMeta path import for built-in modules.\u000a\u000a    All methods are either class or static methods to avoid the need to\u000a    instantiate the class.\u000a\u000a    
p223
sg5
V__loader__
p224
sg7
L3L
sa(dp225
g1
I01
sg5
V__name__
p226
sg7
L5L
sa(dp227
g1
I01
sg5
V__package__
p228
sg7
L5L
sa(dp229
g1
I01
sg5
V__spec__
p230
sg7
L5L
sa(dp231
g1
I01
sg155
VPerform the operation `cmd` on file descriptor fd.\u000a\u000aThe values used for `cmd` are operating system dependent, and are available\u000aas constants in the fcntl module, using the same names as used in\u000athe relevant C header files.  The argument arg is optional, and\u000adefaults to 0; it may be an int or a string.  If arg is given as a string,\u000athe return value of fcntl is a string of that length, containing the\u000aresulting value put in the arg buffer by the operating system.  The length\u000aof the arg string is not allowed to exceed 1024 bytes.  If the arg given\u000ais an integer or if none is specified, the result value is an integer\u000acorresponding to the return value of the fcntl call in the C code.
p232
sg5
Vfcntl
p233
sg7
L2L
sa(dp234
g1
I01
sg155
VPerform the lock operation `operation` on file descriptor `fd`.\u000a\u000aSee the Unix manual page for flock(2) for details (On some systems, this\u000afunction is emulated using fcntl()).
p235
sg5
Vflock
p236
sg7
L2L
sa(dp237
g1
I01
sg155
VPerform the operation `request` on file descriptor `fd`.\u000a\u000aThe values used for `request` are operating system dependent, and are available\u000aas constants in the fcntl or termios library modules, using the same names as\u000aused in the relevant C header files.\u000a\u000aThe argument `arg` is optional, and defaults to 0; it may be an int or a\u000abuffer containing character data (most likely a string or an array).\u000a\u000aIf the argument is a mutable buffer (such as an array) and if the\u000amutate_flag argument (which is only allowed in this case) is true then the\u000abuffer is (in effect) passed to the operating system and changes made by\u000athe OS will be reflected in the contents of the buffer after the call has\u000areturned.  The return value is the integer returned by the ioctl system\u000acall.\u000a\u000aIf the argument is a mutable buffer and the mutable_flag argument is false,\u000athe behavior is as if a string had been passed.\u000a\u000aIf the argument is an immutable buffer (most likely a string) then a copy\u000aof the buffer is passed to the operating system and the return value is a\u000astring of the same length containing whatever the operating system put in\u000athe buffer.  The length of the arg buffer in this case is not allowed to\u000aexceed 1024 bytes.\u000a\u000aIf the arg given is an integer or if none is specified, the result value is\u000aan integer corresponding to the return value of the ioctl call in the C\u000acode.
p238
sg5
Vioctl
p239
sg7
L2L
sa(dp240
g1
I01
sg155
VA wrapper around the fcntl() locking calls.\u000a\u000a`fd` is the file descriptor of the file to lock or unlock, and operation is one\u000aof the following values:\u000a\u000a    LOCK_UN - unlock\u000a    LOCK_SH - acquire a shared lock\u000a    LOCK_EX - acquire an exclusive lock\u000a\u000aWhen operation is LOCK_SH or LOCK_EX, it can also be bitwise ORed with\u000aLOCK_NB to avoid blocking on lock acquisition.  If LOCK_NB is used and the\u000alock cannot be acquired, an OSError will be raised and the exception will\u000ahave an errno attribute set to EACCES or EAGAIN (depending on the operating\u000asystem -- for portability, check for either value).\u000a\u000a`len` is the number of bytes to lock, with the default meaning to lock to\u000aEOF.  `start` is the byte offset, relative to `whence`, to that the lock\u000astarts.  `whence` is as with fileobj.seek(), specifically:\u000a\u000a    0 - relative to the start of the file (SEEK_SET)\u000a    1 - relative to the current buffer position (SEEK_CUR)\u000a    2 - relative to the end of the file (SEEK_END)
p241
sg5
Vlockf
p242
sg7
L2L
sasg155
VThis module performs file control and I/O control on file \u000adescriptors.  It is an interface to the fcntl() and ioctl() Unix\u000aroutines.  File descriptors can be obtained with the fileno() method of\u000aa file or socket object.
p243
sg5
Vfcntl
p244
sg7
L1L
s.