(dp0
Vis_builtin
p1
I01
sVchilds
p2
(lp3
(dp4
g1
I01
sVname
p5
V__doc__
p6
sVtype
p7
L5L
sa(dp8
g1
I01
sg2
(lp9
(dp10
g1
I01
sg5
V__delattr__
p11
sg7
L5L
sa(dp12
g1
I01
sg5
V__dict__
p13
sg7
L5L
sa(dp14
g1
I01
sVdoc
p15
V__dir__() -> list\u000adefault dir() implementation
p16
sg5
V__dir__
p17
sg7
L2L
sa(dp18
g1
I01
sg5
g6
sg7
L5L
sa(dp19
g1
I01
sg5
V__eq__
p20
sg7
L5L
sa(dp21
g1
I01
sg15
Vdefault object formatter
p22
sg5
V__format__
p23
sg7
L2L
sa(dp24
g1
I01
sg5
V__ge__
p25
sg7
L5L
sa(dp26
g1
I01
sg5
V__getattribute__
p27
sg7
L5L
sa(dp28
g1
I01
sg5
V__gt__
p29
sg7
L5L
sa(dp30
g1
I01
sg5
V__hash__
p31
sg7
L5L
sa(dp32
g1
I01
sg5
V__init__
p33
sg7
L5L
sa(dp34
g1
I01
sg5
V__le__
p35
sg7
L5L
sa(dp36
g1
I01
sg5
V__lt__
p37
sg7
L5L
sa(dp38
g1
I01
sg5
V__module__
p39
sg7
L5L
sa(dp40
g1
I01
sg5
V__ne__
p41
sg7
L5L
sa(dp42
g1
I01
sg15
VCreate and return a new object.  See help(type) for accurate signature.
p43
sg5
V__new__
p44
sg7
L2L
sa(dp45
g1
I01
sg15
Vhelper for pickle
p46
sg5
V__reduce__
p47
sg7
L2L
sa(dp48
g1
I01
sg15
Vhelper for pickle
p49
sg5
V__reduce_ex__
p50
sg7
L2L
sa(dp51
g1
I01
sg5
V__repr__
p52
sg7
L5L
sa(dp53
g1
I01
sg5
V__setattr__
p54
sg7
L5L
sa(dp55
g1
I01
sg15
V__sizeof__() -> int\u000asize of object in memory, in bytes
p56
sg5
V__sizeof__
p57
sg7
L2L
sa(dp58
g1
I01
sg5
V__str__
p59
sg7
L5L
sa(dp60
g1
I01
sg15
VAbstract classes can override this to customize issubclass().\u000a\u000aThis is invoked early on by abc.ABCMeta.__subclasscheck__().\u000aIt should return True, False or NotImplemented.  If it returns\u000aNotImplemented, the normal algorithm is used.  Otherwise, it\u000aoverrides the normal algorithm (and the outcome is cached).\u000a
p61
sg5
V__subclasshook__
p62
sg7
L2L
sa(dp63
g1
I01
sg5
V__weakref__
p64
sg7
L5L
sa(dp65
g1
I01
sg5
Vcreate_module
p66
sg7
L5L
sa(dp67
g1
I01
sg5
Vexec_module
p68
sg7
L5L
sa(dp69
g1
I01
sg5
Vfind_module
p70
sg7
L5L
sa(dp71
g1
I01
sg5
Vfind_spec
p72
sg7
L5L
sa(dp73
g1
I01
sg5
Vget_code
p74
sg7
L5L
sa(dp75
g1
I01
sg5
Vget_source
p76
sg7
L5L
sa(dp77
g1
I01
sg5
Vis_package
p78
sg7
L5L
sa(dp79
g1
I01
sg5
Vload_module
p80
sg7
L5L
sa(dp81
g1
I01
sg5
Vmodule_repr
p82
sg7
L5L
sasg15
VMeta path import for built-in modules.\u000a\u000a    All methods are either class or static methods to avoid the need to\u000a    instantiate the class.\u000a\u000a    
p83
sg5
V__loader__
p84
sg7
L3L
sa(dp85
g1
I01
sg5
V__name__
p86
sg7
L5L
sa(dp87
g1
I01
sg5
V__package__
p88
sg7
L5L
sa(dp89
g1
I01
sg5
V__spec__
p90
sg7
L5L
sa(dp91
g1
I01
sg15
Vacos(x)\u000a\u000aReturn the arc cosine (measured in radians) of x.
p92
sg5
Vacos
p93
sg7
L2L
sa(dp94
g1
I01
sg15
Vacosh(x)\u000a\u000aReturn the inverse hyperbolic cosine of x.
p95
sg5
Vacosh
p96
sg7
L2L
sa(dp97
g1
I01
sg15
Vasin(x)\u000a\u000aReturn the arc sine (measured in radians) of x.
p98
sg5
Vasin
p99
sg7
L2L
sa(dp100
g1
I01
sg15
Vasinh(x)\u000a\u000aReturn the inverse hyperbolic sine of x.
p101
sg5
Vasinh
p102
sg7
L2L
sa(dp103
g1
I01
sg15
Vatan(x)\u000a\u000aReturn the arc tangent (measured in radians) of x.
p104
sg5
Vatan
p105
sg7
L2L
sa(dp106
g1
I01
sg15
Vatan2(y, x)\u000a\u000aReturn the arc tangent (measured in radians) of y/x.\u000aUnlike atan(y/x), the signs of both x and y are considered.
p107
sg5
Vatan2
p108
sg7
L2L
sa(dp109
g1
I01
sg15
Vatanh(x)\u000a\u000aReturn the inverse hyperbolic tangent of x.
p110
sg5
Vatanh
p111
sg7
L2L
sa(dp112
g1
I01
sg15
Vceil(x)\u000a\u000aReturn the ceiling of x as an Integral.\u000aThis is the smallest integer >= x.
p113
sg5
Vceil
p114
sg7
L2L
sa(dp115
g1
I01
sg15
Vcopysign(x, y)\u000a\u000aReturn a float with the magnitude (absolute value) of x but the sign \u000aof y. On platforms that support signed zeros, copysign(1.0, -0.0) \u000areturns -1.0.\u000a
p116
sg5
Vcopysign
p117
sg7
L2L
sa(dp118
g1
I01
sg15
Vcos(x)\u000a\u000aReturn the cosine of x (measured in radians).
p119
sg5
Vcos
p120
sg7
L2L
sa(dp121
g1
I01
sg15
Vcosh(x)\u000a\u000aReturn the hyperbolic cosine of x.
p122
sg5
Vcosh
p123
sg7
L2L
sa(dp124
g1
I01
sg15
Vdegrees(x)\u000a\u000aConvert angle x from radians to degrees.
p125
sg5
Vdegrees
p126
sg7
L2L
sa(dp127
g1
I01
sg5
Ve
p128
sg7
L5L
sa(dp129
g1
I01
sg15
Verf(x)\u000a\u000aError function at x.
p130
sg5
Verf
p131
sg7
L2L
sa(dp132
g1
I01
sg15
Verfc(x)\u000a\u000aComplementary error function at x.
p133
sg5
Verfc
p134
sg7
L2L
sa(dp135
g1
I01
sg15
Vexp(x)\u000a\u000aReturn e raised to the power of x.
p136
sg5
Vexp
p137
sg7
L2L
sa(dp138
g1
I01
sg15
Vexpm1(x)\u000a\u000aReturn exp(x)-1.\u000aThis function avoids the loss of precision involved in the direct evaluation of exp(x)-1 for small x.
p139
sg5
Vexpm1
p140
sg7
L2L
sa(dp141
g1
I01
sg15
Vfabs(x)\u000a\u000aReturn the absolute value of the float x.
p142
sg5
Vfabs
p143
sg7
L2L
sa(dp144
g1
I01
sg15
Vfactorial(x) -> Integral\u000a\u000aFind x!. Raise a ValueError if x is negative or non-integral.
p145
sg5
Vfactorial
p146
sg7
L2L
sa(dp147
g1
I01
sg15
Vfloor(x)\u000a\u000aReturn the floor of x as an Integral.\u000aThis is the largest integer <= x.
p148
sg5
Vfloor
p149
sg7
L2L
sa(dp150
g1
I01
sg15
Vfmod(x, y)\u000a\u000aReturn fmod(x, y), according to platform C.  x % y may differ.
p151
sg5
Vfmod
p152
sg7
L2L
sa(dp153
g1
I01
sg15
Vfrexp(x)\u000a\u000aReturn the mantissa and exponent of x, as pair (m, e).\u000am is a float and e is an int, such that x = m * 2.**e.\u000aIf x is 0, m and e are both 0.  Else 0.5 <= abs(m) < 1.0.
p154
sg5
Vfrexp
p155
sg7
L2L
sa(dp156
g1
I01
sg15
Vfsum(iterable)\u000a\u000aReturn an accurate floating point sum of values in the iterable.\u000aAssumes IEEE-754 floating point arithmetic.
p157
sg5
Vfsum
p158
sg7
L2L
sa(dp159
g1
I01
sg15
Vgamma(x)\u000a\u000aGamma function at x.
p160
sg5
Vgamma
p161
sg7
L2L
sa(dp162
g1
I01
sg15
Vgcd(x, y) -> int\u000agreatest common divisor of x and y
p163
sg5
Vgcd
p164
sg7
L2L
sa(dp165
g1
I01
sg15
Vhypot(x, y)\u000a\u000aReturn the Euclidean distance, sqrt(x*x + y*y).
p166
sg5
Vhypot
p167
sg7
L2L
sa(dp168
g1
I01
sg5
Vinf
p169
sg7
L5L
sa(dp170
g1
I01
sg15
Visclose(a, b, *, rel_tol=1e-09, abs_tol=0.0) -> bool\u000a\u000aDetermine whether two floating point numbers are close in value.\u000a\u000a   rel_tol\u000a       maximum difference for being considered "close", relative to the\u000a       magnitude of the input values\u000a    abs_tol\u000a       maximum difference for being considered "close", regardless of the\u000a       magnitude of the input values\u000a\u000aReturn True if a is close in value to b, and False otherwise.\u000a\u000aFor the values to be considered close, the difference between them\u000amust be smaller than at least one of the tolerances.\u000a\u000a-inf, inf and NaN behave similarly to the IEEE 754 Standard.  That\u000ais, NaN is not close to anything, even itself.  inf and -inf are\u000aonly close to themselves.
p171
sg5
Visclose
p172
sg7
L2L
sa(dp173
g1
I01
sg15
Visfinite(x) -> bool\u000a\u000aReturn True if x is neither an infinity nor a NaN, and False otherwise.
p174
sg5
Visfinite
p175
sg7
L2L
sa(dp176
g1
I01
sg15
Visinf(x) -> bool\u000a\u000aReturn True if x is a positive or negative infinity, and False otherwise.
p177
sg5
Visinf
p178
sg7
L2L
sa(dp179
g1
I01
sg15
Visnan(x) -> bool\u000a\u000aReturn True if x is a NaN (not a number), and False otherwise.
p180
sg5
Visnan
p181
sg7
L2L
sa(dp182
g1
I01
sg15
Vldexp(x, i)\u000a\u000aReturn x * (2**i).
p183
sg5
Vldexp
p184
sg7
L2L
sa(dp185
g1
I01
sg15
Vlgamma(x)\u000a\u000aNatural logarithm of absolute value of Gamma function at x.
p186
sg5
Vlgamma
p187
sg7
L2L
sa(dp188
g1
I01
sg15
Vlog(x[, base])\u000a\u000aReturn the logarithm of x to the given base.\u000aIf the base not specified, returns the natural logarithm (base e) of x.
p189
sg5
Vlog
p190
sg7
L2L
sa(dp191
g1
I01
sg15
Vlog10(x)\u000a\u000aReturn the base 10 logarithm of x.
p192
sg5
Vlog10
p193
sg7
L2L
sa(dp194
g1
I01
sg15
Vlog1p(x)\u000a\u000aReturn the natural logarithm of 1+x (base e).\u000aThe result is computed in a way which is accurate for x near zero.
p195
sg5
Vlog1p
p196
sg7
L2L
sa(dp197
g1
I01
sg15
Vlog2(x)\u000a\u000aReturn the base 2 logarithm of x.
p198
sg5
Vlog2
p199
sg7
L2L
sa(dp200
g1
I01
sg15
Vmodf(x)\u000a\u000aReturn the fractional and integer parts of x.  Both results carry the sign\u000aof x and are floats.
p201
sg5
Vmodf
p202
sg7
L2L
sa(dp203
g1
I01
sg5
Vnan
p204
sg7
L5L
sa(dp205
g1
I01
sg5
Vpi
p206
sg7
L5L
sa(dp207
g1
I01
sg15
Vpow(x, y)\u000a\u000aReturn x**y (x to the power of y).
p208
sg5
Vpow
p209
sg7
L2L
sa(dp210
g1
I01
sg15
Vradians(x)\u000a\u000aConvert angle x from degrees to radians.
p211
sg5
Vradians
p212
sg7
L2L
sa(dp213
g1
I01
sg15
Vsin(x)\u000a\u000aReturn the sine of x (measured in radians).
p214
sg5
Vsin
p215
sg7
L2L
sa(dp216
g1
I01
sg15
Vsinh(x)\u000a\u000aReturn the hyperbolic sine of x.
p217
sg5
Vsinh
p218
sg7
L2L
sa(dp219
g1
I01
sg15
Vsqrt(x)\u000a\u000aReturn the square root of x.
p220
sg5
Vsqrt
p221
sg7
L2L
sa(dp222
g1
I01
sg15
Vtan(x)\u000a\u000aReturn the tangent of x (measured in radians).
p223
sg5
Vtan
p224
sg7
L2L
sa(dp225
g1
I01
sg15
Vtanh(x)\u000a\u000aReturn the hyperbolic tangent of x.
p226
sg5
Vtanh
p227
sg7
L2L
sa(dp228
g1
I01
sg15
Vtrunc(x:Real) -> Integral\u000a\u000aTruncates x to the nearest Integral toward 0. Uses the __trunc__ magic method.
p229
sg5
Vtrunc
p230
sg7
L2L
sasg15
VThis module is always available.  It provides access to the\u000amathematical functions defined by the C standard.
p231
sg5
Vmath
p232
sg7
L1L
s.