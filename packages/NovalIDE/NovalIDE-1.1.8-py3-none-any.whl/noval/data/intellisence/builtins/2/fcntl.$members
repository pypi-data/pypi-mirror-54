(dp0
S'doc'
p1
S'This module performs file control and I/O control on file \ndescriptors.  It is an interface to the fcntl() and ioctl() Unix\nroutines.  File descriptors can be obtained with the fileno() method of\na file or socket object.'
p2
sS'is_builtin'
p3
I01
sS'childs'
p4
(lp5
(dp6
g3
I01
sS'type'
p7
I5
sS'name'
p8
S'DN_ACCESS'
p9
sa(dp10
g3
I01
sg7
I5
sg8
S'DN_ATTRIB'
p11
sa(dp12
g3
I01
sg7
I5
sg8
S'DN_CREATE'
p13
sa(dp14
g3
I01
sg7
I5
sg8
S'DN_DELETE'
p15
sa(dp16
g3
I01
sg7
I5
sg8
S'DN_MODIFY'
p17
sa(dp18
g3
I01
sg7
I5
sg8
S'DN_MULTISHOT'
p19
sa(dp20
g3
I01
sg7
I5
sg8
S'DN_RENAME'
p21
sa(dp22
g3
I01
sg7
I5
sg8
S'FASYNC'
p23
sa(dp24
g3
I01
sg7
I5
sg8
S'FD_CLOEXEC'
p25
sa(dp26
g3
I01
sg7
I5
sg8
S'F_DUPFD'
p27
sa(dp28
g3
I01
sg7
I5
sg8
S'F_EXLCK'
p29
sa(dp30
g3
I01
sg7
I5
sg8
S'F_GETFD'
p31
sa(dp32
g3
I01
sg7
I5
sg8
S'F_GETFL'
p33
sa(dp34
g3
I01
sg7
I5
sg8
S'F_GETLEASE'
p35
sa(dp36
g3
I01
sg7
I5
sg8
S'F_GETLK'
p37
sa(dp38
g3
I01
sg7
I5
sg8
S'F_GETLK64'
p39
sa(dp40
g3
I01
sg7
I5
sg8
S'F_GETOWN'
p41
sa(dp42
g3
I01
sg7
I5
sg8
S'F_GETSIG'
p43
sa(dp44
g3
I01
sg7
I5
sg8
S'F_NOTIFY'
p45
sa(dp46
g3
I01
sg7
I5
sg8
S'F_RDLCK'
p47
sa(dp48
g3
I01
sg7
I5
sg8
S'F_SETFD'
p49
sa(dp50
g3
I01
sg7
I5
sg8
S'F_SETFL'
p51
sa(dp52
g3
I01
sg7
I5
sg8
S'F_SETLEASE'
p53
sa(dp54
g3
I01
sg7
I5
sg8
S'F_SETLK'
p55
sa(dp56
g3
I01
sg7
I5
sg8
S'F_SETLK64'
p57
sa(dp58
g3
I01
sg7
I5
sg8
S'F_SETLKW'
p59
sa(dp60
g3
I01
sg7
I5
sg8
S'F_SETLKW64'
p61
sa(dp62
g3
I01
sg7
I5
sg8
S'F_SETOWN'
p63
sa(dp64
g3
I01
sg7
I5
sg8
S'F_SETSIG'
p65
sa(dp66
g3
I01
sg7
I5
sg8
S'F_SHLCK'
p67
sa(dp68
g3
I01
sg7
I5
sg8
S'F_UNLCK'
p69
sa(dp70
g3
I01
sg7
I5
sg8
S'F_WRLCK'
p71
sa(dp72
g3
I01
sg7
I5
sg8
S'I_ATMARK'
p73
sa(dp74
g3
I01
sg7
I5
sg8
S'I_CANPUT'
p75
sa(dp76
g3
I01
sg7
I5
sg8
S'I_CKBAND'
p77
sa(dp78
g3
I01
sg7
I5
sg8
S'I_FDINSERT'
p79
sa(dp80
g3
I01
sg7
I5
sg8
S'I_FIND'
p81
sa(dp82
g3
I01
sg7
I5
sg8
S'I_FLUSH'
p83
sa(dp84
g3
I01
sg7
I5
sg8
S'I_FLUSHBAND'
p85
sa(dp86
g3
I01
sg7
I5
sg8
S'I_GETBAND'
p87
sa(dp88
g3
I01
sg7
I5
sg8
S'I_GETCLTIME'
p89
sa(dp90
g3
I01
sg7
I5
sg8
S'I_GETSIG'
p91
sa(dp92
g3
I01
sg7
I5
sg8
S'I_GRDOPT'
p93
sa(dp94
g3
I01
sg7
I5
sg8
S'I_GWROPT'
p95
sa(dp96
g3
I01
sg7
I5
sg8
S'I_LINK'
p97
sa(dp98
g3
I01
sg7
I5
sg8
S'I_LIST'
p99
sa(dp100
g3
I01
sg7
I5
sg8
S'I_LOOK'
p101
sa(dp102
g3
I01
sg7
I5
sg8
S'I_NREAD'
p103
sa(dp104
g3
I01
sg7
I5
sg8
S'I_PEEK'
p105
sa(dp106
g3
I01
sg7
I5
sg8
S'I_PLINK'
p107
sa(dp108
g3
I01
sg7
I5
sg8
S'I_POP'
p109
sa(dp110
g3
I01
sg7
I5
sg8
S'I_PUNLINK'
p111
sa(dp112
g3
I01
sg7
I5
sg8
S'I_PUSH'
p113
sa(dp114
g3
I01
sg7
I5
sg8
S'I_RECVFD'
p115
sa(dp116
g3
I01
sg7
I5
sg8
S'I_SENDFD'
p117
sa(dp118
g3
I01
sg7
I5
sg8
S'I_SETCLTIME'
p119
sa(dp120
g3
I01
sg7
I5
sg8
S'I_SETSIG'
p121
sa(dp122
g3
I01
sg7
I5
sg8
S'I_SRDOPT'
p123
sa(dp124
g3
I01
sg7
I5
sg8
S'I_STR'
p125
sa(dp126
g3
I01
sg7
I5
sg8
S'I_SWROPT'
p127
sa(dp128
g3
I01
sg7
I5
sg8
S'I_UNLINK'
p129
sa(dp130
g3
I01
sg7
I5
sg8
S'LOCK_EX'
p131
sa(dp132
g3
I01
sg7
I5
sg8
S'LOCK_MAND'
p133
sa(dp134
g3
I01
sg7
I5
sg8
S'LOCK_NB'
p135
sa(dp136
g3
I01
sg7
I5
sg8
S'LOCK_READ'
p137
sa(dp138
g3
I01
sg7
I5
sg8
S'LOCK_RW'
p139
sa(dp140
g3
I01
sg7
I5
sg8
S'LOCK_SH'
p141
sa(dp142
g3
I01
sg7
I5
sg8
S'LOCK_UN'
p143
sa(dp144
g3
I01
sg7
I5
sg8
S'LOCK_WRITE'
p145
sa(dp146
g3
I01
sg7
I5
sg8
S'__doc__'
p147
sa(dp148
g3
I01
sg7
I5
sg8
S'__name__'
p149
sa(dp150
g3
I01
sg7
I5
sg8
S'__package__'
p151
sa(dp152
g1
S'fcntl(fd, op, [arg])\n\nPerform the operation op on file descriptor fd.  The values used\nfor op are operating system dependent, and are available\nas constants in the fcntl module, using the same names as used in\nthe relevant C header files.  The argument arg is optional, and\ndefaults to 0; it may be an int or a string.  If arg is given as a string,\nthe return value of fcntl is a string of that length, containing the\nresulting value put in the arg buffer by the operating system.  The length\nof the arg string is not allowed to exceed 1024 bytes.  If the arg given\nis an integer or if none is specified, the result value is an integer\ncorresponding to the return value of the fcntl call in the C code.'
p153
sg3
I01
sg7
I2
sg8
S'fcntl'
p154
sa(dp155
g1
S'flock(fd, operation)\n\nPerform the lock operation op on file descriptor fd.  See the Unix \nmanual page for flock(2) for details.  (On some systems, this function is\nemulated using fcntl().)'
p156
sg3
I01
sg7
I2
sg8
S'flock'
p157
sa(dp158
g1
S'ioctl(fd, op[, arg[, mutate_flag]])\n\nPerform the operation op on file descriptor fd.  The values used for op\nare operating system dependent, and are available as constants in the\nfcntl or termios library modules, using the same names as used in the\nrelevant C header files.\n\nThe argument arg is optional, and defaults to 0; it may be an int or a\nbuffer containing character data (most likely a string or an array). \n\nIf the argument is a mutable buffer (such as an array) and if the\nmutate_flag argument (which is only allowed in this case) is true then the\nbuffer is (in effect) passed to the operating system and changes made by\nthe OS will be reflected in the contents of the buffer after the call has\nreturned.  The return value is the integer returned by the ioctl system\ncall.\n\nIf the argument is a mutable buffer and the mutable_flag argument is not\npassed or is false, the behavior is as if a string had been passed.  This\nbehavior will change in future releases of Python.\n\nIf the argument is an immutable buffer (most likely a string) then a copy\nof the buffer is passed to the operating system and the return value is a\nstring of the same length containing whatever the operating system put in\nthe buffer.  The length of the arg buffer in this case is not allowed to\nexceed 1024 bytes.\n\nIf the arg given is an integer or if none is specified, the result value is\nan integer corresponding to the return value of the ioctl call in the C\ncode.'
p159
sg3
I01
sg7
I2
sg8
S'ioctl'
p160
sa(dp161
g1
S'lockf (fd, operation, length=0, start=0, whence=0)\n\nThis is essentially a wrapper around the fcntl() locking calls.  fd is the\nfile descriptor of the file to lock or unlock, and operation is one of the\nfollowing values:\n\n    LOCK_UN - unlock\n    LOCK_SH - acquire a shared lock\n    LOCK_EX - acquire an exclusive lock\n\nWhen operation is LOCK_SH or LOCK_EX, it can also be bitwise ORed with\nLOCK_NB to avoid blocking on lock acquisition.  If LOCK_NB is used and the\nlock cannot be acquired, an IOError will be raised and the exception will\nhave an errno attribute set to EACCES or EAGAIN (depending on the operating\nsystem -- for portability, check for either value).\n\nlength is the number of bytes to lock, with the default meaning to lock to\nEOF.  start is the byte offset, relative to whence, to that the lock\nstarts.  whence is as with fileobj.seek(), specifically:\n\n    0 - relative to the start of the file (SEEK_SET)\n    1 - relative to the current buffer position (SEEK_CUR)\n    2 - relative to the end of the file (SEEK_END)'
p162
sg3
I01
sg7
I2
sg8
S'lockf'
p163
sasg7
I1
sg8
S'fcntl'
p164
s.