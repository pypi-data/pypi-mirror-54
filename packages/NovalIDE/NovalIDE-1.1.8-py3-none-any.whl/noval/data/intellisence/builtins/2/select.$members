(dp0
S'doc'
p1
S'This module supports asynchronous I/O on multiple file descriptors.\n\n*** IMPORTANT NOTICE ***\nOn Windows and OpenVMS, only sockets are supported; on Unix, all file descriptors.'
p2
sS'is_builtin'
p3
I01
sS'childs'
p4
(lp5
(dp6
g3
I01
sS'type'
p7
I5
sS'name'
p8
S'EPOLLERR'
p9
sa(dp10
g3
I01
sg7
I5
sg8
S'EPOLLET'
p11
sa(dp12
g3
I01
sg7
I5
sg8
S'EPOLLHUP'
p13
sa(dp14
g3
I01
sg7
I5
sg8
S'EPOLLIN'
p15
sa(dp16
g3
I01
sg7
I5
sg8
S'EPOLLMSG'
p17
sa(dp18
g3
I01
sg7
I5
sg8
S'EPOLLONESHOT'
p19
sa(dp20
g3
I01
sg7
I5
sg8
S'EPOLLOUT'
p21
sa(dp22
g3
I01
sg7
I5
sg8
S'EPOLLPRI'
p23
sa(dp24
g3
I01
sg7
I5
sg8
S'EPOLLRDBAND'
p25
sa(dp26
g3
I01
sg7
I5
sg8
S'EPOLLRDNORM'
p27
sa(dp28
g3
I01
sg7
I5
sg8
S'EPOLLWRBAND'
p29
sa(dp30
g3
I01
sg7
I5
sg8
S'EPOLLWRNORM'
p31
sa(dp32
g3
I01
sg7
I5
sg8
S'PIPE_BUF'
p33
sa(dp34
g3
I01
sg7
I5
sg8
S'POLLERR'
p35
sa(dp36
g3
I01
sg7
I5
sg8
S'POLLHUP'
p37
sa(dp38
g3
I01
sg7
I5
sg8
S'POLLIN'
p39
sa(dp40
g3
I01
sg7
I5
sg8
S'POLLMSG'
p41
sa(dp42
g3
I01
sg7
I5
sg8
S'POLLNVAL'
p43
sa(dp44
g3
I01
sg7
I5
sg8
S'POLLOUT'
p45
sa(dp46
g3
I01
sg7
I5
sg8
S'POLLPRI'
p47
sa(dp48
g3
I01
sg7
I5
sg8
S'POLLRDBAND'
p49
sa(dp50
g3
I01
sg7
I5
sg8
S'POLLRDNORM'
p51
sa(dp52
g3
I01
sg7
I5
sg8
S'POLLWRBAND'
p53
sa(dp54
g3
I01
sg7
I5
sg8
S'POLLWRNORM'
p55
sa(dp56
g3
I01
sg7
I5
sg8
S'__doc__'
p57
sa(dp58
g3
I01
sg7
I5
sg8
S'__name__'
p59
sa(dp60
g3
I01
sg7
I5
sg8
S'__package__'
p61
sa(dp62
g1
S"select.epoll([sizehint=-1])\n\nReturns an epolling object\n\nsizehint must be a positive integer or -1 for the default size. The\nsizehint is used to optimize internal data structures. It doesn't limit\nthe maximum number of monitored events."
p63
sg3
I01
sg4
(lp64
(dp65
g3
I01
sg7
I5
sg8
S'__delattr__'
p66
sa(dp67
g3
I01
sg7
I5
sg8
g57
sa(dp68
g1
S'default object formatter'
p69
sg3
I01
sg7
I2
sg8
S'__format__'
p70
sa(dp71
g3
I01
sg7
I5
sg8
S'__getattribute__'
p72
sa(dp73
g3
I01
sg7
I5
sg8
S'__hash__'
p74
sa(dp75
g3
I01
sg7
I5
sg8
S'__init__'
p76
sa(dp77
g1
S'T.__new__(S, ...) -> a new object with type S, a subtype of T'
p78
sg3
I01
sg7
I2
sg8
S'__new__'
p79
sa(dp80
g1
S'helper for pickle'
p81
sg3
I01
sg7
I2
sg8
S'__reduce__'
p82
sa(dp83
g1
S'helper for pickle'
p84
sg3
I01
sg7
I2
sg8
S'__reduce_ex__'
p85
sa(dp86
g3
I01
sg7
I5
sg8
S'__repr__'
p87
sa(dp88
g3
I01
sg7
I5
sg8
S'__setattr__'
p89
sa(dp90
g1
S'__sizeof__() -> int\nsize of object in memory, in bytes'
p91
sg3
I01
sg7
I2
sg8
S'__sizeof__'
p92
sa(dp93
g3
I01
sg7
I5
sg8
S'__str__'
p94
sa(dp95
g1
S'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
p96
sg3
I01
sg7
I2
sg8
S'__subclasshook__'
p97
sa(dp98
g1
S'close() -> None\n\nClose the epoll control file descriptor. Further operations on the epoll\nobject will raise an exception.'
p99
sg3
I01
sg7
I2
sg8
S'close'
p100
sa(dp101
g3
I01
sg7
I5
sg8
S'closed'
p102
sa(dp103
g1
S'fileno() -> int\n\nReturn the epoll control file descriptor.'
p104
sg3
I01
sg7
I2
sg8
S'fileno'
p105
sa(dp106
g1
S'fromfd(fd) -> epoll\n\nCreate an epoll object from a given control fd.'
p107
sg3
I01
sg7
I2
sg8
S'fromfd'
p108
sa(dp109
g1
S'modify(fd, eventmask) -> None\n\nfd is the target file descriptor of the operation\nevents is a bit set composed of the various EPOLL constants'
p110
sg3
I01
sg7
I2
sg8
S'modify'
p111
sa(dp112
g1
S'poll([timeout=-1[, maxevents=-1]]) -> [(fd, events), (...)]\n\nWait for events on the epoll file descriptor for a maximum time of timeout\nin seconds (as float). -1 makes poll wait indefinitely.\nUp to maxevents are returned to the caller.'
p113
sg3
I01
sg7
I2
sg8
S'poll'
p114
sa(dp115
g1
S'register(fd[, eventmask]) -> None\n\nRegisters a new fd or raises an IOError if the fd is already registered.\nfd is the target file descriptor of the operation.\nevents is a bit set composed of the various EPOLL constants; the default\nis EPOLL_IN | EPOLL_OUT | EPOLL_PRI.\n\nThe epoll interface supports all file descriptors that support poll.'
p116
sg3
I01
sg7
I2
sg8
S'register'
p117
sa(dp118
g1
S'unregister(fd) -> None\n\nfd is the target file descriptor of the operation.'
p119
sg3
I01
sg7
I2
sg8
S'unregister'
p120
sasg7
I3
sg8
S'epoll'
p121
sa(dp122
g1
Nsg3
I01
sg4
(lp123
(dp124
g3
I01
sg7
I5
sg8
g66
sa(dp125
g3
I01
sg7
I5
sg8
S'__dict__'
p126
sa(dp127
g3
I01
sg7
I5
sg8
g57
sa(dp128
g1
S'default object formatter'
p129
sg3
I01
sg7
I2
sg8
g70
sa(dp130
g3
I01
sg7
I5
sg8
g72
sa(dp131
g3
I01
sg7
I5
sg8
S'__getitem__'
p132
sa(dp133
g3
I01
sg7
I5
sg8
S'__getslice__'
p134
sa(dp135
g3
I01
sg7
I5
sg8
g74
sa(dp136
g3
I01
sg7
I5
sg8
g76
sa(dp137
g3
I01
sg7
I5
sg8
S'__module__'
p138
sa(dp139
g1
S'T.__new__(S, ...) -> a new object with type S, a subtype of T'
p140
sg3
I01
sg7
I2
sg8
g79
sa(dp141
g1
Nsg3
I01
sg7
I2
sg8
g82
sa(dp142
g1
S'helper for pickle'
p143
sg3
I01
sg7
I2
sg8
g85
sa(dp144
g3
I01
sg7
I5
sg8
g87
sa(dp145
g3
I01
sg7
I5
sg8
g89
sa(dp146
g1
Nsg3
I01
sg7
I2
sg8
S'__setstate__'
p147
sa(dp148
g1
S'__sizeof__() -> int\nsize of object in memory, in bytes'
p149
sg3
I01
sg7
I2
sg8
g92
sa(dp150
g3
I01
sg7
I5
sg8
g94
sa(dp151
g1
S'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
p152
sg3
I01
sg7
I2
sg8
g97
sa(dp153
g1
Nsg3
I01
sg7
I2
sg8
S'__unicode__'
p154
sa(dp155
g3
I01
sg7
I5
sg8
S'__weakref__'
p156
sa(dp157
g3
I01
sg7
I5
sg8
S'args'
p158
sa(dp159
g3
I01
sg7
I5
sg8
S'message'
p160
sasg7
I3
sg8
S'error'
p161
sa(dp162
g1
S'Returns a polling object, which supports registering and\nunregistering file descriptors, and then polling them for I/O events.'
p163
sg3
I01
sg7
I2
sg8
g114
sa(dp164
g1
S"select(rlist, wlist, xlist[, timeout]) -> (rlist, wlist, xlist)\n\nWait until one or more file descriptors are ready for some kind of I/O.\nThe first three arguments are sequences of file descriptors to be waited for:\nrlist -- wait until ready for reading\nwlist -- wait until ready for writing\nxlist -- wait for an ``exceptional condition''\nIf only one kind of condition is required, pass [] for the other lists.\nA file descriptor is either a socket or file object, or a small integer\ngotten from a fileno() method call on one of those.\n\nThe optional 4th argument specifies a timeout in seconds; it may be\na floating point number to specify fractions of seconds.  If it is absent\nor None, the call will never time out.\n\nThe return value is a tuple of three lists corresponding to the first three\narguments; each contains the subset of the corresponding file descriptors\nthat are ready.\n\n*** IMPORTANT NOTICE ***\nOn Windows and OpenVMS, only sockets are supported; on Unix, all file\ndescriptors can be used."
p165
sg3
I01
sg7
I2
sg8
S'select'
p166
sasg7
I1
sg8
S'select'
p167
s.