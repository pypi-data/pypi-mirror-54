(dp0
Vis_builtin
p1
I01
sVchilds
p2
(lp3
(dp4
g1
I01
sVname
p5
V__doc__
p6
sVtype
p7
L5L
sa(dp8
g1
I01
sg2
(lp9
(dp10
g1
I01
sg5
V__delattr__
p11
sg7
L5L
sa(dp12
g1
I01
sg5
V__dict__
p13
sg7
L5L
sa(dp14
g1
I01
sVdoc
p15
V__dir__() -> list\u000adefault dir() implementation
p16
sg5
V__dir__
p17
sg7
L2L
sa(dp18
g1
I01
sg5
g6
sg7
L5L
sa(dp19
g1
I01
sg5
V__eq__
p20
sg7
L5L
sa(dp21
g1
I01
sg15
Vdefault object formatter
p22
sg5
V__format__
p23
sg7
L2L
sa(dp24
g1
I01
sg5
V__ge__
p25
sg7
L5L
sa(dp26
g1
I01
sg5
V__getattribute__
p27
sg7
L5L
sa(dp28
g1
I01
sg5
V__gt__
p29
sg7
L5L
sa(dp30
g1
I01
sg5
V__hash__
p31
sg7
L5L
sa(dp32
g1
I01
sg5
V__init__
p33
sg7
L5L
sa(dp34
g1
I01
sg5
V__le__
p35
sg7
L5L
sa(dp36
g1
I01
sg5
V__lt__
p37
sg7
L5L
sa(dp38
g1
I01
sg5
V__module__
p39
sg7
L5L
sa(dp40
g1
I01
sg5
V__ne__
p41
sg7
L5L
sa(dp42
g1
I01
sg15
VCreate and return a new object.  See help(type) for accurate signature.
p43
sg5
V__new__
p44
sg7
L2L
sa(dp45
g1
I01
sg15
Vhelper for pickle
p46
sg5
V__reduce__
p47
sg7
L2L
sa(dp48
g1
I01
sg15
Vhelper for pickle
p49
sg5
V__reduce_ex__
p50
sg7
L2L
sa(dp51
g1
I01
sg5
V__repr__
p52
sg7
L5L
sa(dp53
g1
I01
sg5
V__setattr__
p54
sg7
L5L
sa(dp55
g1
I01
sg15
V__sizeof__() -> int\u000asize of object in memory, in bytes
p56
sg5
V__sizeof__
p57
sg7
L2L
sa(dp58
g1
I01
sg5
V__str__
p59
sg7
L5L
sa(dp60
g1
I01
sg15
VAbstract classes can override this to customize issubclass().\u000a\u000aThis is invoked early on by abc.ABCMeta.__subclasscheck__().\u000aIt should return True, False or NotImplemented.  If it returns\u000aNotImplemented, the normal algorithm is used.  Otherwise, it\u000aoverrides the normal algorithm (and the outcome is cached).\u000a
p61
sg5
V__subclasshook__
p62
sg7
L2L
sa(dp63
g1
I01
sg5
V__weakref__
p64
sg7
L5L
sa(dp65
g1
I01
sg5
Vcreate_module
p66
sg7
L5L
sa(dp67
g1
I01
sg5
Vexec_module
p68
sg7
L5L
sa(dp69
g1
I01
sg5
Vfind_module
p70
sg7
L5L
sa(dp71
g1
I01
sg5
Vfind_spec
p72
sg7
L5L
sa(dp73
g1
I01
sg5
Vget_code
p74
sg7
L5L
sa(dp75
g1
I01
sg5
Vget_source
p76
sg7
L5L
sa(dp77
g1
I01
sg5
Vis_package
p78
sg7
L5L
sa(dp79
g1
I01
sg5
Vload_module
p80
sg7
L5L
sa(dp81
g1
I01
sg5
Vmodule_repr
p82
sg7
L5L
sasg15
VMeta path import for built-in modules.\u000a\u000a    All methods are either class or static methods to avoid the need to\u000a    instantiate the class.\u000a\u000a    
p83
sg5
V__loader__
p84
sg7
L3L
sa(dp85
g1
I01
sg5
V__name__
p86
sg7
L5L
sa(dp87
g1
I01
sg5
V__package__
p88
sg7
L5L
sa(dp89
g1
I01
sg5
V__spec__
p90
sg7
L5L
sa(dp91
g1
I01
sg15
Vdump(value, file[, version])\u000a\u000aWrite the value on the open file. The value must be a supported type.\u000aThe file must be an open file object such as sys.stdout or returned by\u000aopen() or os.popen(). It must be opened in binary mode ('wb' or 'w+b').\u000a\u000aIf the value has (or contains an object that has) an unsupported type, a\u000aValueError exception is raised - but garbage data will also be written\u000ato the file. The object will not be properly read back by load()\u000a\u000aThe version argument indicates the data format that dump should use.
p92
sg5
Vdump
p93
sg7
L2L
sa(dp94
g1
I01
sg15
Vdumps(value[, version])\u000a\u000aReturn the string that would be written to a file by dump(value, file).\u000aThe value must be a supported type. Raise a ValueError exception if\u000avalue has (or contains an object that has) an unsupported type.\u000a\u000aThe version argument indicates the data format that dumps should use.
p95
sg5
Vdumps
p96
sg7
L2L
sa(dp97
g1
I01
sg15
Vload(file)\u000a\u000aRead one value from the open file and return it. If no valid value is\u000aread (e.g. because the data has a different Python version's\u000aincompatible marshal format), raise EOFError, ValueError or TypeError.\u000aThe file must be an open file object opened in binary mode ('rb' or\u000a'r+b').\u000a\u000aNote: If an object containing an unsupported type was marshalled with\u000adump(), load() will substitute None for the unmarshallable type.
p98
sg5
Vload
p99
sg7
L2L
sa(dp100
g1
I01
sg15
Vloads(bytes)\u000a\u000aConvert the bytes object to a value. If no valid value is found, raise\u000aEOFError, ValueError or TypeError. Extra characters in the input are\u000aignored.
p101
sg5
Vloads
p102
sg7
L2L
sa(dp103
g1
I01
sg5
Vversion
p104
sg7
L5L
sasg15
VThis module contains functions that can read and write Python values in\u000aa binary format. The format is specific to Python, but independent of\u000amachine architecture issues.\u000a\u000aNot all Python object types are supported; in general, only objects\u000awhose value is independent from a particular invocation of Python can be\u000awritten and read by this module. The following types are supported:\u000aNone, integers, floating point numbers, strings, bytes, bytearrays,\u000atuples, lists, sets, dictionaries, and code objects, where it\u000ashould be understood that tuples, lists and dictionaries are only\u000asupported as long as the values contained therein are themselves\u000asupported; and recursive lists and dictionaries should not be written\u000a(they will cause infinite loops).\u000a\u000aVariables:\u000a\u000aversion -- indicates the format that the module uses. Version 0 is the\u000a    historical format, version 1 shares interned strings and version 2\u000a    uses a binary format for floating point numbers.\u000a    Version 3 shares common object references (New in version 3.4).\u000a\u000aFunctions:\u000a\u000adump() -- write value to a file\u000aload() -- read value from a file\u000adumps() -- write value to a string\u000aloads() -- read value from a string
p105
sg5
Vmarshal
p106
sg7
L1L
s.