(dp0
Vis_builtin
p1
I01
sVchilds
p2
(lp3
(dp4
g1
I01
sVname
p5
V__about__
p6
sVtype
p7
L5L
sa(dp8
g1
I01
sg5
V__doc__
p9
sg7
L5L
sa(dp10
g1
I01
sg2
(lp11
(dp12
g1
I01
sg5
V__delattr__
p13
sg7
L5L
sa(dp14
g1
I01
sg5
V__dict__
p15
sg7
L5L
sa(dp16
g1
I01
sVdoc
p17
V__dir__() -> list\u000adefault dir() implementation
p18
sg5
V__dir__
p19
sg7
L2L
sa(dp20
g1
I01
sg5
g9
sg7
L5L
sa(dp21
g1
I01
sg5
V__eq__
p22
sg7
L5L
sa(dp23
g1
I01
sg17
Vdefault object formatter
p24
sg5
V__format__
p25
sg7
L2L
sa(dp26
g1
I01
sg5
V__ge__
p27
sg7
L5L
sa(dp28
g1
I01
sg5
V__getattribute__
p29
sg7
L5L
sa(dp30
g1
I01
sg5
V__gt__
p31
sg7
L5L
sa(dp32
g1
I01
sg5
V__hash__
p33
sg7
L5L
sa(dp34
g1
I01
sg5
V__init__
p35
sg7
L5L
sa(dp36
g1
I01
sg5
V__le__
p37
sg7
L5L
sa(dp38
g1
I01
sg5
V__lt__
p39
sg7
L5L
sa(dp40
g1
I01
sg5
V__module__
p41
sg7
L5L
sa(dp42
g1
I01
sg5
V__ne__
p43
sg7
L5L
sa(dp44
g1
I01
sg17
VCreate and return a new object.  See help(type) for accurate signature.
p45
sg5
V__new__
p46
sg7
L2L
sa(dp47
g1
I01
sg17
Vhelper for pickle
p48
sg5
V__reduce__
p49
sg7
L2L
sa(dp50
g1
I01
sg17
Vhelper for pickle
p51
sg5
V__reduce_ex__
p52
sg7
L2L
sa(dp53
g1
I01
sg5
V__repr__
p54
sg7
L5L
sa(dp55
g1
I01
sg5
V__setattr__
p56
sg7
L5L
sa(dp57
g1
I01
sg17
V__sizeof__() -> int\u000asize of object in memory, in bytes
p58
sg5
V__sizeof__
p59
sg7
L2L
sa(dp60
g1
I01
sg5
V__str__
p61
sg7
L5L
sa(dp62
g1
I01
sg17
VAbstract classes can override this to customize issubclass().\u000a\u000aThis is invoked early on by abc.ABCMeta.__subclasscheck__().\u000aIt should return True, False or NotImplemented.  If it returns\u000aNotImplemented, the normal algorithm is used.  Otherwise, it\u000aoverrides the normal algorithm (and the outcome is cached).\u000a
p63
sg5
V__subclasshook__
p64
sg7
L2L
sa(dp65
g1
I01
sg5
V__weakref__
p66
sg7
L5L
sa(dp67
g1
I01
sg5
Vcreate_module
p68
sg7
L5L
sa(dp69
g1
I01
sg5
Vexec_module
p70
sg7
L5L
sa(dp71
g1
I01
sg5
Vfind_module
p72
sg7
L5L
sa(dp73
g1
I01
sg5
Vfind_spec
p74
sg7
L5L
sa(dp75
g1
I01
sg5
Vget_code
p76
sg7
L5L
sa(dp77
g1
I01
sg5
Vget_source
p78
sg7
L5L
sa(dp79
g1
I01
sg5
Vis_package
p80
sg7
L5L
sa(dp81
g1
I01
sg5
Vload_module
p82
sg7
L5L
sa(dp83
g1
I01
sg5
Vmodule_repr
p84
sg7
L5L
sasg17
VMeta path import for built-in modules.\u000a\u000a    All methods are either class or static methods to avoid the need to\u000a    instantiate the class.\u000a\u000a    
p85
sg5
V__loader__
p86
sg7
L3L
sa(dp87
g1
I01
sg5
V__name__
p88
sg7
L5L
sa(dp89
g1
I01
sg5
V__package__
p90
sg7
L5L
sa(dp91
g1
I01
sg5
V__spec__
p92
sg7
L5L
sa(dp93
g1
I01
sg17
VMaxheap variant of heapify.
p94
sg5
V_heapify_max
p95
sg7
L2L
sa(dp96
g1
I01
sg17
VMaxheap variant of heappop.
p97
sg5
V_heappop_max
p98
sg7
L2L
sa(dp99
g1
I01
sg17
VMaxheap variant of heapreplace
p100
sg5
V_heapreplace_max
p101
sg7
L2L
sa(dp102
g1
I01
sg17
VTransform list into a heap, in-place, in O(len(heap)) time.
p103
sg5
Vheapify
p104
sg7
L2L
sa(dp105
g1
I01
sg17
VPop the smallest item off the heap, maintaining the heap invariant.
p106
sg5
Vheappop
p107
sg7
L2L
sa(dp108
g1
I01
sg17
Vheappush(heap, item) -> None. Push item onto heap, maintaining the heap invariant.
p109
sg5
Vheappush
p110
sg7
L2L
sa(dp111
g1
I01
sg17
Vheappushpop(heap, item) -> value. Push item on the heap, then pop and return the smallest item\u000afrom the heap. The combined action runs more efficiently than\u000aheappush() followed by a separate call to heappop().
p112
sg5
Vheappushpop
p113
sg7
L2L
sa(dp114
g1
I01
sg17
Vheapreplace(heap, item) -> value. Pop and return the current smallest value, and add the new item.\u000a\u000aThis is more efficient than heappop() followed by heappush(), and can be\u000amore appropriate when using a fixed-size heap.  Note that the value\u000areturned may be larger than item!  That constrains reasonable uses of\u000athis routine unless written as part of a conditional replacement:\u000a\u000a    if item > heap[0]:\u000a        item = heapreplace(heap, item)\u000a
p115
sg5
Vheapreplace
p116
sg7
L2L
sasg17
VHeap queue algorithm (a.k.a. priority queue).\u000a\u000aHeaps are arrays for which a[k] <= a[2*k+1] and a[k] <= a[2*k+2] for\u000aall k, counting elements from 0.  For the sake of comparison,\u000anon-existing elements are considered to be infinite.  The interesting\u000aproperty of a heap is that a[0] is always its smallest element.\u000a\u000aUsage:\u000a\u000aheap = []            # creates an empty heap\u000aheappush(heap, item) # pushes a new item on the heap\u000aitem = heappop(heap) # pops the smallest item from the heap\u000aitem = heap[0]       # smallest item on the heap without popping it\u000aheapify(x)           # transforms list into a heap, in-place, in linear time\u000aitem = heapreplace(heap, item) # pops and returns smallest item, and adds\u000a                               # new item; the heap size is unchanged\u000a\u000aOur API differs from textbook heap algorithms as follows:\u000a\u000a- We use 0-based indexing.  This makes the relationship between the\u000a  index for a node and the indexes for its children slightly less\u000a  obvious, but is more suitable since Python uses 0-based indexing.\u000a\u000a- Our heappop() method returns the smallest item, not the largest.\u000a\u000aThese two make it possible to view the heap as a regular Python list\u000awithout surprises: heap[0] is the smallest item, and heap.sort()\u000amaintains the heap invariant!\u000a
p117
sg5
V_heapq
p118
sg7
L1L
s.