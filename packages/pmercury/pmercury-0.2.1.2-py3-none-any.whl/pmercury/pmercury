#!/usr/bin/env python3

"""
 Copyright (c) 2019 Cisco Systems, Inc. All rights reserved.
 License at https://github.com/cisco/mercury/blob/master/LICENSE
"""

import os
import sys
import pcap
import time
import optparse
import ujson as json
from socket import AF_INET, AF_INET6, inet_ntop

sys.path.append(os.path.dirname(os.path.abspath(__file__)))
sys.path.append(os.path.dirname(os.path.abspath(__file__))+'/../')
from pmercury.protocols.tcp import TCP
from pmercury.protocols.tls import TLS
from pmercury.protocols.http import HTTP
from pmercury.protocols.tls_server import TLS_Server
from pmercury.protocols.http_server import HTTP_Server
from pmercury.utils.config_parser import parse_config



class Fingerprinter:

    def __init__(self, database, output=None, analyze=False, num_procs=0,
                 human_readable=False, group=False, experimental=False, sslkeylog=None):
        self.analyze        = analyze
        self.num_procs      = num_procs
        self.human_readable = human_readable
        self.group          = group
        self.FLOW_TIMEOUT   = 150
        self.FLOW_UPDATE    = 15
        self.flow_timer     = None

        if output == None:
            self.out_file_pointer = None
        elif output == sys.stdout:
            self.out_file_pointer = sys.stdout
        else:
            self.out_file_pointer = open(output, 'w', buffering=4096*256)

        config = parse_config('../config.txt')

        # register parsers
        self.parsers = {}
        self.parsers['tcp']         = TCP()
        self.parsers['tls']         = TLS(database)
        self.parsers['tls_server']  = TLS_Server()
        self.parsers['http']        = HTTP(None, config)
        self.parsers['http_server'] = HTTP_Server(None, config)

        self.flow_parsers  = []
        self.experimental = False
        if experimental == True:
            self.experimental = True
            from pmercury.protocols.ssh import SSH
            from pmercury.protocols.tls_decrypt import TLS_Decrypt
            from pmercury.protocols.tls_certificate import TLS_Certificate
            self.parsers['tls_certificate'] = TLS_Certificate()
            self.parsers['ssh'] = SSH()
            self.flow_parsers.extend([('tls_certificate', TLS_Certificate()), ('ssh', SSH())])
            if sslkeylog != None:
                self.parsers['tls_decrypt'] = TLS_Decrypt(sslkeylog)
                self.flow_parsers.append(('tls_decrypt', TLS_Decrypt(sslkeylog)))

        # data
        self.flow_cache = {}


    def process(self, input_files):
        if len(input_files) == 0:
            print('error: need a pcap/interface')
            return 1

        for input_file in input_files:
            if '.pcap' in input_file:
                self.process_pcap(input_file)
            else:
                self.process_capture(input_file)


    def process_pcap(self, pcap_file):
        p = pcap.pcap(pcap_file)
        p.setfilter('ip proto 6 or ip6 proto 6')

        p.dispatch(-1, self.process_packet)

        if self.group:
            self.write_flows(active=False)


    def process_capture(self, iface):
        import signal
        def signal_handler(signal, frame):
            if self.group:
                self.write_flows(active=False)
            sys.exit(0)
        signal.signal(signal.SIGINT, signal_handler)

        p = pcap.pcap(iface)
        p.setfilter('ip proto 6 or ip6 proto 6')
        self.flow_timer = time.time()
        while 1:
            p.dispatch(-1, self.process_packet)

            if self.group and time.time()-self.flow_timer > self.FLOW_UPDATE:
                self.flow_timer = time.time()
                self.write_flows(active=True)

        if self.group:
            self.write_flows(active=False)


    def process_packet(self, ts, buf):
        ip_offset = 14

        high = buf[ip_offset] >> 4
        protocol = 6 # currently only handling TCP
        if high == 4:
            ip_type = 'ipv4'
            ip_length = (buf[ip_offset] & 15)*4
        elif high == 6:
            ip_type = 'ipv6'
            ip_length = 40
        else:
            return -1

        data_len   = len(buf)
        tcp_offset = ip_offset+ip_length
        tcp_length = (buf[tcp_offset+12] >> 4)*4
        app_offset = tcp_offset + tcp_length

        fp_str_ = None
        if buf[tcp_offset+13] == 2:
            fp_str_, context_ = TCP.fingerprint(buf, tcp_offset, tcp_length)
            fp_type = 'tcp'
        elif data_len - app_offset < 16:
            pass
        elif (buf[app_offset] == 22 and buf[app_offset+1] == 3 and buf[app_offset+9] == 3):
            if buf[app_offset+5]  ==  1:
                fp_str_, context_ = TLS.fingerprint(buf, app_offset, data_len)
                fp_type = 'tls'
            if buf[app_offset+5]  ==  2:
                fp_str_, context_ = TLS_Server.fingerprint(buf, app_offset, data_len)
                fp_type = 'tls_server'
        elif buf[app_offset+2] == 84:
            if (buf[app_offset] == 71 and buf[app_offset+3] == 32):
                fp_str_, context_ = HTTP.fingerprint(buf, app_offset, data_len)
                fp_type = 'http'
            if (buf[app_offset] == 72 and buf[app_offset+5] == 49):
                fp_str_, context_ = HTTP_Server.fingerprint(buf, app_offset, data_len)
                fp_type = 'http_server'


        if fp_str_ != None:
            src_port = int.from_bytes(buf[tcp_offset:tcp_offset+2], byteorder='big')
            dst_port = int.from_bytes(buf[tcp_offset+2:tcp_offset+4], byteorder='big')
            if ip_type == 'ipv4':
                o_ = tcp_offset-8
                src_ip = inet_ntop(AF_INET, buf[o_:o_+4])
                o_ += 4
                dst_ip = inet_ntop(AF_INET, buf[o_:o_+4])
            else:
                o_ = tcp_offset-32
                src_ip = inet_ntop(AF_INET6, buf[o_:o_+16])
                o_ += 16
                dst_ip = inet_ntop(AF_INET6, buf[o_:o_+16])

            flow = {'src_ip':src_ip,
                    'dst_ip':dst_ip,
                    'src_port':src_port,
                    'dst_port':dst_port,
                    'protocol':protocol,
                    'event_start':ts,
                    'fingerprints':{fp_type: fp_str_}}
            if context_ != None:
                if fp_type not in flow:
                    flow[fp_type] = {}
                for x_ in context_:
                    flow[fp_type][x_['name']]  = x_['data']
            if self.human_readable:
                desc_ = self.parsers[fp_type].get_human_readable(fp_str_)
                if desc_ != None:
                    if 'readable' not in flow:
                        flow['readable'] = {}
                    flow['readable'][fp_type] = desc_
            if self.analyze:
                proc_info = self.parsers[fp_type].proc_identify(fp_str_, context_, dst_ip, dst_port, self.num_procs)
                if proc_info != None:
                    flow['analysis'] = proc_info

            if self.group:
                self.update_flow_cache(flow)
            else:
                self.write_record(flow)


        if self.experimental:
            for _,fparser_ in self.flow_parsers:
                ffp_type, ffp_str_, fcontext_ = fparser_.fingerprint(buf, ip_offset, tcp_offset, app_offset,
                                                                     ip_type, ip_length, data_len)
                if ffp_str_ != None:
                    self.process_result(buf, ffp_type, ffp_str_, fcontext_, tcp_offset,
                                        ip_type, ip_offset, ip_length, protocol, ts)

        return 0


    def process_result(self, buf, fp_type, fp_str_, context_, tcp_offset, ip_type, ip_offset, ip_length, protocol, ts):
        src_port = int.from_bytes(buf[tcp_offset:tcp_offset+2], byteorder='big')
        dst_port = int.from_bytes(buf[tcp_offset+2:tcp_offset+4], byteorder='big')
        if ip_type == 'ipv4':
            o_ = ip_offset+ip_length-8
            src_ip = inet_ntop(AF_INET, buf[o_:o_+4])
            o_ += 4
            dst_ip = inet_ntop(AF_INET, buf[o_:o_+4])
        else:
            o_ = ip_offset+ip_length-32
            src_ip = inet_ntop(AF_INET6, buf[o_:o_+16])
            o_ += 16
            dst_ip = inet_ntop(AF_INET6, buf[o_:o_+16])

        flow = {'src_ip':src_ip,
                'dst_ip':dst_ip,
                'src_port':src_port,
                'dst_port':dst_port,
                'protocol':protocol,
                'event_start':ts,
                'fingerprints':{fp_type: fp_str_}}
        if context_ != None:
            for x_ in context_:
                if x_['data'] != None:
                    if fp_type not in flow:
                        flow[fp_type] = {}
                    flow[fp_type][x_['name']]  = x_['data']
        if self.human_readable:
            hr_fp_type = fp_type
            if 'tls_decrypt' in hr_fp_type:
                hr_fp_type = 'tls_decrypt'
            desc_ = self.parsers[hr_fp_type].get_human_readable(fp_str_)
            if desc_ != None:
                if 'readable' not in flow:
                    flow['readable'] = {}
                flow['readable'][fp_type] = desc_
        if self.analyze:
            proc_info = self.parsers[fp_type].proc_identify(fp_str_, context_, dst_ip, dst_port, self.num_procs)
            if proc_info != None:
                flow['analysis'] = proc_info

        if self.group:
            self.update_flow_cache(flow)
        else:
            self.write_record(flow)


    def update_flow_cache(self, flow):
        t_flow_key, t_r_flow_key = self.get_flow_keys(flow)
        if t_flow_key in self.flow_cache:
            flow_key = t_flow_key
        elif t_r_flow_key in self.flow_cache:
            flow_key = t_r_flow_key
        else:
            flow_key = t_flow_key
            self.init_flow_cache(flow, flow_key)

        # update end time
        self.flow_cache[flow_key]['event_end'] = flow['event_start']

        # add fingerprint
        for k in flow['fingerprints']:
            packet_fp = {}
            packet_fp['event_start'] = flow['event_start']
            packet_fp[k] = flow['fingerprints'][k]
            if k in flow:
                if k not in self.flow_cache[flow_key]:
                    self.flow_cache[flow_key][k] = {}
                for k1 in flow[k]:
                    self.flow_cache[flow_key][k][k1] = flow[k][k1]
            if 'readable' in flow and k in flow['readable']:
                packet_fp['readable'] = flow['readable'][k]
            if 'analysis' in flow:
                packet_fp['analysis'] = flow['analysis']
            self.flow_cache[flow_key]['fingerprints'].append(packet_fp)


    def init_flow_cache(self, flow, flow_key):
        self.flow_cache[flow_key] = {}
        self.flow_cache[flow_key]['src_ip']       = flow['src_ip']
        self.flow_cache[flow_key]['dst_ip']       = flow['dst_ip']
        self.flow_cache[flow_key]['src_port']     = flow['src_port']
        self.flow_cache[flow_key]['dst_port']     = flow['dst_port']
        self.flow_cache[flow_key]['protocol']     = flow['protocol']
        self.flow_cache[flow_key]['event_start']  = flow['event_start']
        self.flow_cache[flow_key]['event_end']    = flow['event_start']
        self.flow_cache[flow_key]['fingerprints'] = []


    def get_flow_keys(self, flow):
        src_ip   = flow['src_ip']
        dst_ip   = flow['dst_ip']
        src_port = str(flow['src_port'])
        dst_port = str(flow['dst_port'])
        protocol = str(flow['protocol'])

        fk   = src_ip + ':' + dst_ip + ':' + src_port + ':' + dst_port + ':' + protocol
        r_fk = dst_ip + ':' + src_ip + ':' + dst_port + ':' + src_port + ':' + protocol

        return fk, r_fk


    def lookup_fingerprint_string(self, fp_str):
        for protocol_type, parser_ in self.all_parsers:
            fp_str_ = fp_str.encode()
            if fp_str_ in parser_.fp_db:
                fp_ = parser_.fp_db[fp_str_]
                self.write_record(fp_)


    def write_record(self, flow_repr):
        if self.out_file_pointer == None:
            return
        if flow_repr != None:
            self.out_file_pointer.write('%s\n' % json.dumps(flow_repr))


    def write_flows(self, active=False):
        curtime = time.time()
        flow_keys = [k for k in self.flow_cache.keys()
                     if not active or 
                     ((curtime - self.flow_cache[k]['event_start']) > self.FLOW_TIMEOUT)]

        for k in flow_keys:
            self.flow_cache[k]['event_start'] = self.flow_cache[k]['event_start']
            self.flow_cache[k]['event_end'] = self.flow_cache[k]['event_end']
            self.write_record(self.flow_cache[k])
            del self.flow_cache[k]



def main():
    start = time.time()

    parser = optparse.OptionParser()

    parser.add_option('-c','--capture',action='store',dest='capture_interface',
                      help='live packet capture',default=None)
    parser.add_option('-r','--read',action='store',dest='pcap_file',
                      help='read packets from file',default=None)
    parser.add_option('-d','--fp_db',action='store',dest='fp_db',
                      help='location of fingerprint database',default='resources/fingerprint_db.json.gz')
    parser.add_option('-f','--fingerprint',action='store',dest='output',
                      help='write fingerprints to file',default=sys.stdout)
    parser.add_option('-l','--lookup',action='store',dest='lookup',
                      help='lookup fingerprint string <fp_str>',default=None)
    parser.add_option('-a','--analysis',action='store_true',dest='analyze',
                      help='perform process identification',default=False)
    parser.add_option('-w','--human-readable',action='store_true',dest='human_readable',
                      help='return human readable fingerprint information',default=False)
    parser.add_option('-e','--experimental',action='store_true',dest='experimental',
                      help='turns on all experimental features',default=False)
    parser.add_option('-g','--group-flows',action='store_true',dest='group',
                      help='aggregate packet-based fingerprints to flow-based',default=False)
    parser.add_option('-n','--num-procs',action='store',dest='num_procs',type='int',
                      help='return the top-n most probable processes',default=0)
    parser.add_option('-s','--sslkeylogfile',action='store',dest='sslkeylog',
                      help='filename of sslkeylog output for decryption',default=None)

    options, args = parser.parse_args()

    input_files = []
    if options.pcap_file != None:
        input_files.append(options.pcap_file)
    for x in args:
        if '.pcap' in x:
            input_files.append(x)
    if options.capture_interface != None:
        input_files.append(options.capture_interface)

    fingerprinter = Fingerprinter(options.fp_db, options.output, options.analyze,
                                  options.num_procs, options.human_readable, options.group,
                                  options.experimental, options.sslkeylog)

    if options.lookup != None:
        fingerprinter.lookup_fingerprint_string(options.lookup)
    elif len(input_files) > 0:
        fingerprinter.process(input_files)
    else:
        print('error: need a pcap/interface or fingerprint string for lookup')



if __name__ == '__main__':
    sys.exit(main())


#        parser_ = 0
#        if buf[tcp_offset+13] == 2:
#            parser_ = TCP
#            offset = tcp_offset
#            fp_type = 'tcp'
#        elif app_length < 16:
#            pass
#        elif (buf[app_offset]    == 22 and
#            buf[app_offset+1]  ==  3 and
#            buf[app_offset+2]  <=  3 and
#            buf[app_offset+9]  ==  3 and
#            buf[app_offset+10] <=  3):
#            if buf[app_offset+5]  ==  1:
#                parser_ = TLS
#                offset = app_offset
#                fp_type = 'tls'
#            elif buf[app_offset+5]  ==  2:
#                parser_ = TLS_Server()
#                offset = app_offset
#                fp_type = 'tls_server'
#        elif buf[app_offset+2] == 84:
#            if (buf[app_offset]   == 71 and
#                buf[app_offset+1] == 69 and
#                buf[app_offset+3] == 32):
#                parser_ = HTTP
#                offset = app_offset
#                fp_type = 'http'
#            if (buf[app_offset]   == 72 and
#                buf[app_offset+1] == 84 and
#                buf[app_offset+3] == 80 and
#                buf[app_offset+4] == 47 and
#                buf[app_offset+5] == 49):
#                parser_ = HTTP_Server
#                offset = app_offset
#                fp_type = 'http_server'

