#
# Autogenerated by Thrift Compiler (0.9.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
from ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class Iface:
  def exists(self, table, tget, accessId, accessKey):
    """
    Test for the existence of columns in the table, as specified in the TGet.

    @return true if the specified TGet matches one or more keys, false if not

    Parameters:
     - table: the table to check on
     - tget: the TGet to check for
     - accessId: the accessId of bcid to support bdoc
     - accessKey: the accessId of bcid to support bdoc
    """
    pass

  def get(self, table, tget, accessId, accessKey):
    """
    Method for getting data from a row.

    If the row cannot be found an empty Result is returned.
    This can be checked by the empty field of the TResult

    @return the result

    Parameters:
     - table: the table to get from
     - tget: the TGet to fetch
     - accessId: the accessId of bcid to support bdoc
     - accessKey: the accessId of bcid to support bdoc
    """
    pass

  def getMultiple(self, table, tgets, accessId, accessKey):
    """
    Method for getting multiple rows.

    If a row cannot be found there will be a null
    value in the result list for that TGet at the
    same position.

    So the Results are in the same order as the TGets.

    Parameters:
     - table: the table to get from
     - tgets: a list of TGets to fetch, the Result list
    will have the Results at corresponding positions
    or null if there was an error
     - accessId: the accessId of bcid to support bdoc
     - accessKey: the accessId of bcid to support bdoc
    """
    pass

  def put(self, table, tput, accessId, accessKey):
    """
    Commit a TPut to a table.

    Parameters:
     - table: the table to put data in
     - tput: the TPut to put
     - accessId: the accessId of bcid to support bdoc
     - accessKey: the accessId of bcid to support bdoc
    """
    pass

  def checkAndPut(self, table, row, family, qualifier, value, tput, accessId, accessKey):
    """
    Atomically checks if a row/family/qualifier value matches the expected
    value. If it does, it adds the TPut.

    @return true if the new put was executed, false otherwise

    Parameters:
     - table: to check in and put to
     - row: row to check
     - family: column family to check
     - qualifier: column qualifier to check
     - value: the expected value, if not provided the
    check is for the non-existence of the
    column in question
     - tput: the TPut to put if the check succeeds
     - accessId: the accessId of bcid to support bdoc
     - accessKey: the accessId of bcid to support bdoc
    """
    pass

  def putMultiple(self, table, tputs, accessId, accessKey):
    """
    Commit a List of Puts to the table.

    Parameters:
     - table: the table to put data in
     - tputs: a list of TPuts to commit
     - accessId: the accessId of bcid to support bdoc
     - accessKey: the accessId of bcid to support bdoc
    """
    pass

  def deleteSingle(self, table, tdelete, accessId, accessKey):
    """
    Deletes as specified by the TDelete.

    Note: "delete" is a reserved keyword and cannot be used in Thrift
    thus the inconsistent naming scheme from the other functions.

    Parameters:
     - table: the table to delete from
     - tdelete: the TDelete to delete
     - accessId: the accessId of bcid to support bdoc
     - accessKey: the accessId of bcid to support bdoc
    """
    pass

  def deleteMultiple(self, table, tdeletes, accessId, accessKey):
    """
    Bulk commit a List of TDeletes to the table.

    Throws a TIOError if any of the deletes fail.

    Always returns an empty list for backwards compatibility.

    Parameters:
     - table: the table to delete from
     - tdeletes: list of TDeletes to delete
     - accessId: the accessId of bcid to support bdoc
     - accessKey: the accessId of bcid to support bdoc
    """
    pass

  def checkAndDelete(self, table, row, family, qualifier, value, tdelete, accessId, accessKey):
    """
    Atomically checks if a row/family/qualifier value matches the expected
    value. If it does, it adds the delete.

    @return true if the new delete was executed, false otherwise

    Parameters:
     - table: to check in and delete from
     - row: row to check
     - family: column family to check
     - qualifier: column qualifier to check
     - value: the expected value, if not provided the
    check is for the non-existence of the
    column in question
     - tdelete: the TDelete to execute if the check succeeds
     - accessId: the accessId of bcid to support bdoc
     - accessKey: the accessId of bcid to support bdoc
    """
    pass

  def increment(self, table, tincrement, accessId, accessKey):
    """
    Parameters:
     - table: the table to increment the value on
     - tincrement: the TIncrement to increment
     - accessId: the accessId of bcid to support bdoc
     - accessKey: the accessId of bcid to support bdoc
    """
    pass

  def append(self, table, tappend, accessId, accessKey):
    """
    Parameters:
     - table: the table to append the value on
     - tappend: the TAppend to append
     - accessId: the accessId of bcid to support bdoc
     - accessKey: the accessId of bcid to support bdoc
    """
    pass

  def openScanner(self, table, tscan, accessId, accessKey):
    """
    Get a Scanner for the provided TScan object.

    @return Scanner Id to be used with other scanner procedures

    Parameters:
     - table: the table to get the Scanner for
     - tscan: the scan object to get a Scanner for
     - accessId: the accessId of bcid to support bdoc
     - accessKey: the accessId of bcid to support bdoc
    """
    pass

  def getScannerRows(self, scannerId, numRows, accessId, accessKey):
    """
    Grabs multiple rows from a Scanner.

    @return Between zero and numRows TResults

    Parameters:
     - scannerId: the Id of the Scanner to return rows from. This is an Id returned from the openScanner function.
     - numRows: number of rows to return
     - accessId: the accessId of bcid to support bdoc
     - accessKey: the accessId of bcid to support bdoc
    """
    pass

  def closeScanner(self, scannerId, accessId, accessKey):
    """
    Closes the scanner. Should be called to free server side resources timely.
    Typically close once the scanner is not needed anymore, i.e. after looping
    over it to get all the required rows.

    Parameters:
     - scannerId: the Id of the Scanner to close *
     - accessId: the accessId of bcid to support bdoc
     - accessKey: the accessId of bcid to support bdoc
    """
    pass

  def mutateRow(self, table, trowMutations, accessId, accessKey):
    """
    mutateRow performs multiple mutations atomically on a single row.

    Parameters:
     - table: table to apply the mutations
     - trowMutations: mutations to apply
     - accessId: the accessId of bcid to support bdoc
     - accessKey: the accessId of bcid to support bdoc
    """
    pass

  def getScannerResults(self, table, tscan, numRows, accessId, accessKey):
    """
    Get results for the provided TScan object.
    This helper function opens a scanner, get the results and close the scanner.

    @return between zero and numRows TResults

    Parameters:
     - table: the table to get the Scanner for
     - tscan: the scan object to get a Scanner for
     - numRows: number of rows to return
     - accessId: the accessId of bcid to support bdoc
     - accessKey: the accessId of bcid to support bdoc
    """
    pass


class Client(Iface):
  def __init__(self, iprot, oprot=None):
    self._iprot = self._oprot = iprot
    if oprot is not None:
      self._oprot = oprot
    self._seqid = 0

  def exists(self, table, tget, accessId, accessKey):
    """
    Test for the existence of columns in the table, as specified in the TGet.

    @return true if the specified TGet matches one or more keys, false if not

    Parameters:
     - table: the table to check on
     - tget: the TGet to check for
     - accessId: the accessId of bcid to support bdoc
     - accessKey: the accessId of bcid to support bdoc
    """
    self.send_exists(table, tget, accessId, accessKey)
    return self.recv_exists()

  def send_exists(self, table, tget, accessId, accessKey):
    self._oprot.writeMessageBegin('exists', TMessageType.CALL, self._seqid)
    args = exists_args()
    args.table = table
    args.tget = tget
    args.accessId = accessId
    args.accessKey = accessKey
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_exists(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = exists_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.io is not None:
      raise result.io
    raise TApplicationException(TApplicationException.MISSING_RESULT, "exists failed: unknown result");

  def get(self, table, tget, accessId, accessKey):
    """
    Method for getting data from a row.

    If the row cannot be found an empty Result is returned.
    This can be checked by the empty field of the TResult

    @return the result

    Parameters:
     - table: the table to get from
     - tget: the TGet to fetch
     - accessId: the accessId of bcid to support bdoc
     - accessKey: the accessId of bcid to support bdoc
    """
    self.send_get(table, tget, accessId, accessKey)
    return self.recv_get()

  def send_get(self, table, tget, accessId, accessKey):
    self._oprot.writeMessageBegin('get', TMessageType.CALL, self._seqid)
    args = get_args()
    args.table = table
    args.tget = tget
    args.accessId = accessId
    args.accessKey = accessKey
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.io is not None:
      raise result.io
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get failed: unknown result");

  def getMultiple(self, table, tgets, accessId, accessKey):
    """
    Method for getting multiple rows.

    If a row cannot be found there will be a null
    value in the result list for that TGet at the
    same position.

    So the Results are in the same order as the TGets.

    Parameters:
     - table: the table to get from
     - tgets: a list of TGets to fetch, the Result list
    will have the Results at corresponding positions
    or null if there was an error
     - accessId: the accessId of bcid to support bdoc
     - accessKey: the accessId of bcid to support bdoc
    """
    self.send_getMultiple(table, tgets, accessId, accessKey)
    return self.recv_getMultiple()

  def send_getMultiple(self, table, tgets, accessId, accessKey):
    self._oprot.writeMessageBegin('getMultiple', TMessageType.CALL, self._seqid)
    args = getMultiple_args()
    args.table = table
    args.tgets = tgets
    args.accessId = accessId
    args.accessKey = accessKey
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getMultiple(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getMultiple_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.io is not None:
      raise result.io
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getMultiple failed: unknown result");

  def put(self, table, tput, accessId, accessKey):
    """
    Commit a TPut to a table.

    Parameters:
     - table: the table to put data in
     - tput: the TPut to put
     - accessId: the accessId of bcid to support bdoc
     - accessKey: the accessId of bcid to support bdoc
    """
    self.send_put(table, tput, accessId, accessKey)
    self.recv_put()

  def send_put(self, table, tput, accessId, accessKey):
    self._oprot.writeMessageBegin('put', TMessageType.CALL, self._seqid)
    args = put_args()
    args.table = table
    args.tput = tput
    args.accessId = accessId
    args.accessKey = accessKey
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_put(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = put_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.io is not None:
      raise result.io
    return

  def checkAndPut(self, table, row, family, qualifier, value, tput, accessId, accessKey):
    """
    Atomically checks if a row/family/qualifier value matches the expected
    value. If it does, it adds the TPut.

    @return true if the new put was executed, false otherwise

    Parameters:
     - table: to check in and put to
     - row: row to check
     - family: column family to check
     - qualifier: column qualifier to check
     - value: the expected value, if not provided the
    check is for the non-existence of the
    column in question
     - tput: the TPut to put if the check succeeds
     - accessId: the accessId of bcid to support bdoc
     - accessKey: the accessId of bcid to support bdoc
    """
    self.send_checkAndPut(table, row, family, qualifier, value, tput, accessId, accessKey)
    return self.recv_checkAndPut()

  def send_checkAndPut(self, table, row, family, qualifier, value, tput, accessId, accessKey):
    self._oprot.writeMessageBegin('checkAndPut', TMessageType.CALL, self._seqid)
    args = checkAndPut_args()
    args.table = table
    args.row = row
    args.family = family
    args.qualifier = qualifier
    args.value = value
    args.tput = tput
    args.accessId = accessId
    args.accessKey = accessKey
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_checkAndPut(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = checkAndPut_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.io is not None:
      raise result.io
    raise TApplicationException(TApplicationException.MISSING_RESULT, "checkAndPut failed: unknown result");

  def putMultiple(self, table, tputs, accessId, accessKey):
    """
    Commit a List of Puts to the table.

    Parameters:
     - table: the table to put data in
     - tputs: a list of TPuts to commit
     - accessId: the accessId of bcid to support bdoc
     - accessKey: the accessId of bcid to support bdoc
    """
    self.send_putMultiple(table, tputs, accessId, accessKey)
    self.recv_putMultiple()

  def send_putMultiple(self, table, tputs, accessId, accessKey):
    self._oprot.writeMessageBegin('putMultiple', TMessageType.CALL, self._seqid)
    args = putMultiple_args()
    args.table = table
    args.tputs = tputs
    args.accessId = accessId
    args.accessKey = accessKey
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_putMultiple(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = putMultiple_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.io is not None:
      raise result.io
    return

  def deleteSingle(self, table, tdelete, accessId, accessKey):
    """
    Deletes as specified by the TDelete.

    Note: "delete" is a reserved keyword and cannot be used in Thrift
    thus the inconsistent naming scheme from the other functions.

    Parameters:
     - table: the table to delete from
     - tdelete: the TDelete to delete
     - accessId: the accessId of bcid to support bdoc
     - accessKey: the accessId of bcid to support bdoc
    """
    self.send_deleteSingle(table, tdelete, accessId, accessKey)
    self.recv_deleteSingle()

  def send_deleteSingle(self, table, tdelete, accessId, accessKey):
    self._oprot.writeMessageBegin('deleteSingle', TMessageType.CALL, self._seqid)
    args = deleteSingle_args()
    args.table = table
    args.tdelete = tdelete
    args.accessId = accessId
    args.accessKey = accessKey
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_deleteSingle(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = deleteSingle_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.io is not None:
      raise result.io
    return

  def deleteMultiple(self, table, tdeletes, accessId, accessKey):
    """
    Bulk commit a List of TDeletes to the table.

    Throws a TIOError if any of the deletes fail.

    Always returns an empty list for backwards compatibility.

    Parameters:
     - table: the table to delete from
     - tdeletes: list of TDeletes to delete
     - accessId: the accessId of bcid to support bdoc
     - accessKey: the accessId of bcid to support bdoc
    """
    self.send_deleteMultiple(table, tdeletes, accessId, accessKey)
    return self.recv_deleteMultiple()

  def send_deleteMultiple(self, table, tdeletes, accessId, accessKey):
    self._oprot.writeMessageBegin('deleteMultiple', TMessageType.CALL, self._seqid)
    args = deleteMultiple_args()
    args.table = table
    args.tdeletes = tdeletes
    args.accessId = accessId
    args.accessKey = accessKey
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_deleteMultiple(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = deleteMultiple_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.io is not None:
      raise result.io
    raise TApplicationException(TApplicationException.MISSING_RESULT, "deleteMultiple failed: unknown result");

  def checkAndDelete(self, table, row, family, qualifier, value, tdelete, accessId, accessKey):
    """
    Atomically checks if a row/family/qualifier value matches the expected
    value. If it does, it adds the delete.

    @return true if the new delete was executed, false otherwise

    Parameters:
     - table: to check in and delete from
     - row: row to check
     - family: column family to check
     - qualifier: column qualifier to check
     - value: the expected value, if not provided the
    check is for the non-existence of the
    column in question
     - tdelete: the TDelete to execute if the check succeeds
     - accessId: the accessId of bcid to support bdoc
     - accessKey: the accessId of bcid to support bdoc
    """
    self.send_checkAndDelete(table, row, family, qualifier, value, tdelete, accessId, accessKey)
    return self.recv_checkAndDelete()

  def send_checkAndDelete(self, table, row, family, qualifier, value, tdelete, accessId, accessKey):
    self._oprot.writeMessageBegin('checkAndDelete', TMessageType.CALL, self._seqid)
    args = checkAndDelete_args()
    args.table = table
    args.row = row
    args.family = family
    args.qualifier = qualifier
    args.value = value
    args.tdelete = tdelete
    args.accessId = accessId
    args.accessKey = accessKey
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_checkAndDelete(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = checkAndDelete_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.io is not None:
      raise result.io
    raise TApplicationException(TApplicationException.MISSING_RESULT, "checkAndDelete failed: unknown result");

  def increment(self, table, tincrement, accessId, accessKey):
    """
    Parameters:
     - table: the table to increment the value on
     - tincrement: the TIncrement to increment
     - accessId: the accessId of bcid to support bdoc
     - accessKey: the accessId of bcid to support bdoc
    """
    self.send_increment(table, tincrement, accessId, accessKey)
    return self.recv_increment()

  def send_increment(self, table, tincrement, accessId, accessKey):
    self._oprot.writeMessageBegin('increment', TMessageType.CALL, self._seqid)
    args = increment_args()
    args.table = table
    args.tincrement = tincrement
    args.accessId = accessId
    args.accessKey = accessKey
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_increment(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = increment_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.io is not None:
      raise result.io
    raise TApplicationException(TApplicationException.MISSING_RESULT, "increment failed: unknown result");

  def append(self, table, tappend, accessId, accessKey):
    """
    Parameters:
     - table: the table to append the value on
     - tappend: the TAppend to append
     - accessId: the accessId of bcid to support bdoc
     - accessKey: the accessId of bcid to support bdoc
    """
    self.send_append(table, tappend, accessId, accessKey)
    return self.recv_append()

  def send_append(self, table, tappend, accessId, accessKey):
    self._oprot.writeMessageBegin('append', TMessageType.CALL, self._seqid)
    args = append_args()
    args.table = table
    args.tappend = tappend
    args.accessId = accessId
    args.accessKey = accessKey
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_append(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = append_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.io is not None:
      raise result.io
    raise TApplicationException(TApplicationException.MISSING_RESULT, "append failed: unknown result");

  def openScanner(self, table, tscan, accessId, accessKey):
    """
    Get a Scanner for the provided TScan object.

    @return Scanner Id to be used with other scanner procedures

    Parameters:
     - table: the table to get the Scanner for
     - tscan: the scan object to get a Scanner for
     - accessId: the accessId of bcid to support bdoc
     - accessKey: the accessId of bcid to support bdoc
    """
    self.send_openScanner(table, tscan, accessId, accessKey)
    return self.recv_openScanner()

  def send_openScanner(self, table, tscan, accessId, accessKey):
    self._oprot.writeMessageBegin('openScanner', TMessageType.CALL, self._seqid)
    args = openScanner_args()
    args.table = table
    args.tscan = tscan
    args.accessId = accessId
    args.accessKey = accessKey
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_openScanner(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = openScanner_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.io is not None:
      raise result.io
    raise TApplicationException(TApplicationException.MISSING_RESULT, "openScanner failed: unknown result");

  def getScannerRows(self, scannerId, numRows, accessId, accessKey):
    """
    Grabs multiple rows from a Scanner.

    @return Between zero and numRows TResults

    Parameters:
     - scannerId: the Id of the Scanner to return rows from. This is an Id returned from the openScanner function.
     - numRows: number of rows to return
     - accessId: the accessId of bcid to support bdoc
     - accessKey: the accessId of bcid to support bdoc
    """
    self.send_getScannerRows(scannerId, numRows, accessId, accessKey)
    return self.recv_getScannerRows()

  def send_getScannerRows(self, scannerId, numRows, accessId, accessKey):
    self._oprot.writeMessageBegin('getScannerRows', TMessageType.CALL, self._seqid)
    args = getScannerRows_args()
    args.scannerId = scannerId
    args.numRows = numRows
    args.accessId = accessId
    args.accessKey = accessKey
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getScannerRows(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getScannerRows_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.io is not None:
      raise result.io
    if result.ia is not None:
      raise result.ia
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getScannerRows failed: unknown result");

  def closeScanner(self, scannerId, accessId, accessKey):
    """
    Closes the scanner. Should be called to free server side resources timely.
    Typically close once the scanner is not needed anymore, i.e. after looping
    over it to get all the required rows.

    Parameters:
     - scannerId: the Id of the Scanner to close *
     - accessId: the accessId of bcid to support bdoc
     - accessKey: the accessId of bcid to support bdoc
    """
    self.send_closeScanner(scannerId, accessId, accessKey)
    self.recv_closeScanner()

  def send_closeScanner(self, scannerId, accessId, accessKey):
    self._oprot.writeMessageBegin('closeScanner', TMessageType.CALL, self._seqid)
    args = closeScanner_args()
    args.scannerId = scannerId
    args.accessId = accessId
    args.accessKey = accessKey
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_closeScanner(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = closeScanner_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.io is not None:
      raise result.io
    if result.ia is not None:
      raise result.ia
    return

  def mutateRow(self, table, trowMutations, accessId, accessKey):
    """
    mutateRow performs multiple mutations atomically on a single row.

    Parameters:
     - table: table to apply the mutations
     - trowMutations: mutations to apply
     - accessId: the accessId of bcid to support bdoc
     - accessKey: the accessId of bcid to support bdoc
    """
    self.send_mutateRow(table, trowMutations, accessId, accessKey)
    self.recv_mutateRow()

  def send_mutateRow(self, table, trowMutations, accessId, accessKey):
    self._oprot.writeMessageBegin('mutateRow', TMessageType.CALL, self._seqid)
    args = mutateRow_args()
    args.table = table
    args.trowMutations = trowMutations
    args.accessId = accessId
    args.accessKey = accessKey
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_mutateRow(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = mutateRow_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.io is not None:
      raise result.io
    return

  def getScannerResults(self, table, tscan, numRows, accessId, accessKey):
    """
    Get results for the provided TScan object.
    This helper function opens a scanner, get the results and close the scanner.

    @return between zero and numRows TResults

    Parameters:
     - table: the table to get the Scanner for
     - tscan: the scan object to get a Scanner for
     - numRows: number of rows to return
     - accessId: the accessId of bcid to support bdoc
     - accessKey: the accessId of bcid to support bdoc
    """
    self.send_getScannerResults(table, tscan, numRows, accessId, accessKey)
    return self.recv_getScannerResults()

  def send_getScannerResults(self, table, tscan, numRows, accessId, accessKey):
    self._oprot.writeMessageBegin('getScannerResults', TMessageType.CALL, self._seqid)
    args = getScannerResults_args()
    args.table = table
    args.tscan = tscan
    args.numRows = numRows
    args.accessId = accessId
    args.accessKey = accessKey
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getScannerResults(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getScannerResults_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.io is not None:
      raise result.io
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getScannerResults failed: unknown result");


class Processor(Iface, TProcessor):
  def __init__(self, handler):
    self._handler = handler
    self._processMap = {}
    self._processMap["exists"] = Processor.process_exists
    self._processMap["get"] = Processor.process_get
    self._processMap["getMultiple"] = Processor.process_getMultiple
    self._processMap["put"] = Processor.process_put
    self._processMap["checkAndPut"] = Processor.process_checkAndPut
    self._processMap["putMultiple"] = Processor.process_putMultiple
    self._processMap["deleteSingle"] = Processor.process_deleteSingle
    self._processMap["deleteMultiple"] = Processor.process_deleteMultiple
    self._processMap["checkAndDelete"] = Processor.process_checkAndDelete
    self._processMap["increment"] = Processor.process_increment
    self._processMap["append"] = Processor.process_append
    self._processMap["openScanner"] = Processor.process_openScanner
    self._processMap["getScannerRows"] = Processor.process_getScannerRows
    self._processMap["closeScanner"] = Processor.process_closeScanner
    self._processMap["mutateRow"] = Processor.process_mutateRow
    self._processMap["getScannerResults"] = Processor.process_getScannerResults

  def process(self, iprot, oprot):
    (name, type, seqid) = iprot.readMessageBegin()
    if name not in self._processMap:
      iprot.skip(TType.STRUCT)
      iprot.readMessageEnd()
      x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
      oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
      x.write(oprot)
      oprot.writeMessageEnd()
      oprot.trans.flush()
      return
    else:
      self._processMap[name](self, seqid, iprot, oprot)
    return True

  def process_exists(self, seqid, iprot, oprot):
    args = exists_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = exists_result()
    try:
      result.success = self._handler.exists(args.table, args.tget, args.accessId, args.accessKey)
    except TIOError as io:
      result.io = io
    oprot.writeMessageBegin("exists", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get(self, seqid, iprot, oprot):
    args = get_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_result()
    try:
      result.success = self._handler.get(args.table, args.tget, args.accessId, args.accessKey)
    except TIOError as io:
      result.io = io
    oprot.writeMessageBegin("get", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getMultiple(self, seqid, iprot, oprot):
    args = getMultiple_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getMultiple_result()
    try:
      result.success = self._handler.getMultiple(args.table, args.tgets, args.accessId, args.accessKey)
    except TIOError as io:
      result.io = io
    oprot.writeMessageBegin("getMultiple", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_put(self, seqid, iprot, oprot):
    args = put_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = put_result()
    try:
      self._handler.put(args.table, args.tput, args.accessId, args.accessKey)
    except TIOError as io:
      result.io = io
    oprot.writeMessageBegin("put", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_checkAndPut(self, seqid, iprot, oprot):
    args = checkAndPut_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = checkAndPut_result()
    try:
      result.success = self._handler.checkAndPut(args.table, args.row, args.family, args.qualifier, args.value, args.tput, args.accessId, args.accessKey)
    except TIOError as io:
      result.io = io
    oprot.writeMessageBegin("checkAndPut", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_putMultiple(self, seqid, iprot, oprot):
    args = putMultiple_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = putMultiple_result()
    try:
      self._handler.putMultiple(args.table, args.tputs, args.accessId, args.accessKey)
    except TIOError as io:
      result.io = io
    oprot.writeMessageBegin("putMultiple", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_deleteSingle(self, seqid, iprot, oprot):
    args = deleteSingle_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = deleteSingle_result()
    try:
      self._handler.deleteSingle(args.table, args.tdelete, args.accessId, args.accessKey)
    except TIOError as io:
      result.io = io
    oprot.writeMessageBegin("deleteSingle", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_deleteMultiple(self, seqid, iprot, oprot):
    args = deleteMultiple_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = deleteMultiple_result()
    try:
      result.success = self._handler.deleteMultiple(args.table, args.tdeletes, args.accessId, args.accessKey)
    except TIOError as io:
      result.io = io
    oprot.writeMessageBegin("deleteMultiple", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_checkAndDelete(self, seqid, iprot, oprot):
    args = checkAndDelete_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = checkAndDelete_result()
    try:
      result.success = self._handler.checkAndDelete(args.table, args.row, args.family, args.qualifier, args.value, args.tdelete, args.accessId, args.accessKey)
    except TIOError as io:
      result.io = io
    oprot.writeMessageBegin("checkAndDelete", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_increment(self, seqid, iprot, oprot):
    args = increment_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = increment_result()
    try:
      result.success = self._handler.increment(args.table, args.tincrement, args.accessId, args.accessKey)
    except TIOError as io:
      result.io = io
    oprot.writeMessageBegin("increment", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_append(self, seqid, iprot, oprot):
    args = append_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = append_result()
    try:
      result.success = self._handler.append(args.table, args.tappend, args.accessId, args.accessKey)
    except TIOError as io:
      result.io = io
    oprot.writeMessageBegin("append", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_openScanner(self, seqid, iprot, oprot):
    args = openScanner_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = openScanner_result()
    try:
      result.success = self._handler.openScanner(args.table, args.tscan, args.accessId, args.accessKey)
    except TIOError as io:
      result.io = io
    oprot.writeMessageBegin("openScanner", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getScannerRows(self, seqid, iprot, oprot):
    args = getScannerRows_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getScannerRows_result()
    try:
      result.success = self._handler.getScannerRows(args.scannerId, args.numRows, args.accessId, args.accessKey)
    except TIOError as io:
      result.io = io
    except TIllegalArgument as ia:
      result.ia = ia
    oprot.writeMessageBegin("getScannerRows", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_closeScanner(self, seqid, iprot, oprot):
    args = closeScanner_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = closeScanner_result()
    try:
      self._handler.closeScanner(args.scannerId, args.accessId, args.accessKey)
    except TIOError as io:
      result.io = io
    except TIllegalArgument as ia:
      result.ia = ia
    oprot.writeMessageBegin("closeScanner", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_mutateRow(self, seqid, iprot, oprot):
    args = mutateRow_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = mutateRow_result()
    try:
      self._handler.mutateRow(args.table, args.trowMutations, args.accessId, args.accessKey)
    except TIOError as io:
      result.io = io
    oprot.writeMessageBegin("mutateRow", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getScannerResults(self, seqid, iprot, oprot):
    args = getScannerResults_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getScannerResults_result()
    try:
      result.success = self._handler.getScannerResults(args.table, args.tscan, args.numRows, args.accessId, args.accessKey)
    except TIOError as io:
      result.io = io
    oprot.writeMessageBegin("getScannerResults", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()


# HELPER FUNCTIONS AND STRUCTURES

class exists_args:
  """
  Attributes:
   - table: the table to check on
   - tget: the TGet to check for
   - accessId: the accessId of bcid to support bdoc
   - accessKey: the accessId of bcid to support bdoc
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'table', None, None, ), # 1
    (2, TType.STRUCT, 'tget', (TGet, TGet.thrift_spec), None, ), # 2
    (3, TType.STRING, 'accessId', None, None, ), # 3
    (4, TType.STRING, 'accessKey', None, None, ), # 4
  )

  def __init__(self, table=None, tget=None, accessId=None, accessKey=None,):
    self.table = table
    self.tget = tget
    self.accessId = accessId
    self.accessKey = accessKey

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.table = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.tget = TGet()
          self.tget.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.accessId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.accessKey = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('exists_args')
    if self.table is not None:
      oprot.writeFieldBegin('table', TType.STRING, 1)
      oprot.writeString(self.table)
      oprot.writeFieldEnd()
    if self.tget is not None:
      oprot.writeFieldBegin('tget', TType.STRUCT, 2)
      self.tget.write(oprot)
      oprot.writeFieldEnd()
    if self.accessId is not None:
      oprot.writeFieldBegin('accessId', TType.STRING, 3)
      oprot.writeString(self.accessId)
      oprot.writeFieldEnd()
    if self.accessKey is not None:
      oprot.writeFieldBegin('accessKey', TType.STRING, 4)
      oprot.writeString(self.accessKey)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.table is None:
      raise TProtocol.TProtocolException(message='Required field table is unset!')
    if self.tget is None:
      raise TProtocol.TProtocolException(message='Required field tget is unset!')
    if self.accessId is None:
      raise TProtocol.TProtocolException(message='Required field accessId is unset!')
    if self.accessKey is None:
      raise TProtocol.TProtocolException(message='Required field accessKey is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class exists_result:
  """
  Attributes:
   - success
   - io
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'io', (TIOError, TIOError.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, io=None,):
    self.success = success
    self.io = io

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.io = TIOError()
          self.io.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('exists_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.io is not None:
      oprot.writeFieldBegin('io', TType.STRUCT, 1)
      self.io.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_args:
  """
  Attributes:
   - table: the table to get from
   - tget: the TGet to fetch
   - accessId: the accessId of bcid to support bdoc
   - accessKey: the accessId of bcid to support bdoc
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'table', None, None, ), # 1
    (2, TType.STRUCT, 'tget', (TGet, TGet.thrift_spec), None, ), # 2
    (3, TType.STRING, 'accessId', None, None, ), # 3
    (4, TType.STRING, 'accessKey', None, None, ), # 4
  )

  def __init__(self, table=None, tget=None, accessId=None, accessKey=None,):
    self.table = table
    self.tget = tget
    self.accessId = accessId
    self.accessKey = accessKey

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.table = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.tget = TGet()
          self.tget.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.accessId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.accessKey = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_args')
    if self.table is not None:
      oprot.writeFieldBegin('table', TType.STRING, 1)
      oprot.writeString(self.table)
      oprot.writeFieldEnd()
    if self.tget is not None:
      oprot.writeFieldBegin('tget', TType.STRUCT, 2)
      self.tget.write(oprot)
      oprot.writeFieldEnd()
    if self.accessId is not None:
      oprot.writeFieldBegin('accessId', TType.STRING, 3)
      oprot.writeString(self.accessId)
      oprot.writeFieldEnd()
    if self.accessKey is not None:
      oprot.writeFieldBegin('accessKey', TType.STRING, 4)
      oprot.writeString(self.accessKey)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.table is None:
      raise TProtocol.TProtocolException(message='Required field table is unset!')
    if self.tget is None:
      raise TProtocol.TProtocolException(message='Required field tget is unset!')
    if self.accessId is None:
      raise TProtocol.TProtocolException(message='Required field accessId is unset!')
    if self.accessKey is None:
      raise TProtocol.TProtocolException(message='Required field accessKey is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_result:
  """
  Attributes:
   - success
   - io
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (TResult, TResult.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'io', (TIOError, TIOError.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, io=None,):
    self.success = success
    self.io = io

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = TResult()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.io = TIOError()
          self.io.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.io is not None:
      oprot.writeFieldBegin('io', TType.STRUCT, 1)
      self.io.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getMultiple_args:
  """
  Attributes:
   - table: the table to get from
   - tgets: a list of TGets to fetch, the Result list
  will have the Results at corresponding positions
  or null if there was an error
   - accessId: the accessId of bcid to support bdoc
   - accessKey: the accessId of bcid to support bdoc
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'table', None, None, ), # 1
    (2, TType.LIST, 'tgets', (TType.STRUCT,(TGet, TGet.thrift_spec)), None, ), # 2
    (3, TType.STRING, 'accessId', None, None, ), # 3
    (4, TType.STRING, 'accessKey', None, None, ), # 4
  )

  def __init__(self, table=None, tgets=None, accessId=None, accessKey=None,):
    self.table = table
    self.tgets = tgets
    self.accessId = accessId
    self.accessKey = accessKey

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.table = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.tgets = []
          (_etype169, _size166) = iprot.readListBegin()
          for _i170 in xrange(_size166):
            _elem171 = TGet()
            _elem171.read(iprot)
            self.tgets.append(_elem171)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.accessId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.accessKey = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getMultiple_args')
    if self.table is not None:
      oprot.writeFieldBegin('table', TType.STRING, 1)
      oprot.writeString(self.table)
      oprot.writeFieldEnd()
    if self.tgets is not None:
      oprot.writeFieldBegin('tgets', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.tgets))
      for iter172 in self.tgets:
        iter172.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.accessId is not None:
      oprot.writeFieldBegin('accessId', TType.STRING, 3)
      oprot.writeString(self.accessId)
      oprot.writeFieldEnd()
    if self.accessKey is not None:
      oprot.writeFieldBegin('accessKey', TType.STRING, 4)
      oprot.writeString(self.accessKey)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.table is None:
      raise TProtocol.TProtocolException(message='Required field table is unset!')
    if self.tgets is None:
      raise TProtocol.TProtocolException(message='Required field tgets is unset!')
    if self.accessId is None:
      raise TProtocol.TProtocolException(message='Required field accessId is unset!')
    if self.accessKey is None:
      raise TProtocol.TProtocolException(message='Required field accessKey is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getMultiple_result:
  """
  Attributes:
   - success
   - io
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(TResult, TResult.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'io', (TIOError, TIOError.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, io=None,):
    self.success = success
    self.io = io

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype176, _size173) = iprot.readListBegin()
          for _i177 in xrange(_size173):
            _elem178 = TResult()
            _elem178.read(iprot)
            self.success.append(_elem178)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.io = TIOError()
          self.io.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getMultiple_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter179 in self.success:
        iter179.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.io is not None:
      oprot.writeFieldBegin('io', TType.STRUCT, 1)
      self.io.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class put_args:
  """
  Attributes:
   - table: the table to put data in
   - tput: the TPut to put
   - accessId: the accessId of bcid to support bdoc
   - accessKey: the accessId of bcid to support bdoc
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'table', None, None, ), # 1
    (2, TType.STRUCT, 'tput', (TPut, TPut.thrift_spec), None, ), # 2
    (3, TType.STRING, 'accessId', None, None, ), # 3
    (4, TType.STRING, 'accessKey', None, None, ), # 4
  )

  def __init__(self, table=None, tput=None, accessId=None, accessKey=None,):
    self.table = table
    self.tput = tput
    self.accessId = accessId
    self.accessKey = accessKey

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.table = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.tput = TPut()
          self.tput.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.accessId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.accessKey = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('put_args')
    if self.table is not None:
      oprot.writeFieldBegin('table', TType.STRING, 1)
      oprot.writeString(self.table)
      oprot.writeFieldEnd()
    if self.tput is not None:
      oprot.writeFieldBegin('tput', TType.STRUCT, 2)
      self.tput.write(oprot)
      oprot.writeFieldEnd()
    if self.accessId is not None:
      oprot.writeFieldBegin('accessId', TType.STRING, 3)
      oprot.writeString(self.accessId)
      oprot.writeFieldEnd()
    if self.accessKey is not None:
      oprot.writeFieldBegin('accessKey', TType.STRING, 4)
      oprot.writeString(self.accessKey)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.table is None:
      raise TProtocol.TProtocolException(message='Required field table is unset!')
    if self.tput is None:
      raise TProtocol.TProtocolException(message='Required field tput is unset!')
    if self.accessId is None:
      raise TProtocol.TProtocolException(message='Required field accessId is unset!')
    if self.accessKey is None:
      raise TProtocol.TProtocolException(message='Required field accessKey is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class put_result:
  """
  Attributes:
   - io
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'io', (TIOError, TIOError.thrift_spec), None, ), # 1
  )

  def __init__(self, io=None,):
    self.io = io

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.io = TIOError()
          self.io.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('put_result')
    if self.io is not None:
      oprot.writeFieldBegin('io', TType.STRUCT, 1)
      self.io.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class checkAndPut_args:
  """
  Attributes:
   - table: to check in and put to
   - row: row to check
   - family: column family to check
   - qualifier: column qualifier to check
   - value: the expected value, if not provided the
  check is for the non-existence of the
  column in question
   - tput: the TPut to put if the check succeeds
   - accessId: the accessId of bcid to support bdoc
   - accessKey: the accessId of bcid to support bdoc
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'table', None, None, ), # 1
    (2, TType.STRING, 'row', None, None, ), # 2
    (3, TType.STRING, 'family', None, None, ), # 3
    (4, TType.STRING, 'qualifier', None, None, ), # 4
    (5, TType.STRING, 'value', None, None, ), # 5
    (6, TType.STRUCT, 'tput', (TPut, TPut.thrift_spec), None, ), # 6
    (7, TType.STRING, 'accessId', None, None, ), # 7
    (8, TType.STRING, 'accessKey', None, None, ), # 8
  )

  def __init__(self, table=None, row=None, family=None, qualifier=None, value=None, tput=None, accessId=None, accessKey=None,):
    self.table = table
    self.row = row
    self.family = family
    self.qualifier = qualifier
    self.value = value
    self.tput = tput
    self.accessId = accessId
    self.accessKey = accessKey

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.table = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.row = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.family = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.qualifier = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.value = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.tput = TPut()
          self.tput.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.accessId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRING:
          self.accessKey = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('checkAndPut_args')
    if self.table is not None:
      oprot.writeFieldBegin('table', TType.STRING, 1)
      oprot.writeString(self.table)
      oprot.writeFieldEnd()
    if self.row is not None:
      oprot.writeFieldBegin('row', TType.STRING, 2)
      oprot.writeString(self.row)
      oprot.writeFieldEnd()
    if self.family is not None:
      oprot.writeFieldBegin('family', TType.STRING, 3)
      oprot.writeString(self.family)
      oprot.writeFieldEnd()
    if self.qualifier is not None:
      oprot.writeFieldBegin('qualifier', TType.STRING, 4)
      oprot.writeString(self.qualifier)
      oprot.writeFieldEnd()
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.STRING, 5)
      oprot.writeString(self.value)
      oprot.writeFieldEnd()
    if self.tput is not None:
      oprot.writeFieldBegin('tput', TType.STRUCT, 6)
      self.tput.write(oprot)
      oprot.writeFieldEnd()
    if self.accessId is not None:
      oprot.writeFieldBegin('accessId', TType.STRING, 7)
      oprot.writeString(self.accessId)
      oprot.writeFieldEnd()
    if self.accessKey is not None:
      oprot.writeFieldBegin('accessKey', TType.STRING, 8)
      oprot.writeString(self.accessKey)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.table is None:
      raise TProtocol.TProtocolException(message='Required field table is unset!')
    if self.row is None:
      raise TProtocol.TProtocolException(message='Required field row is unset!')
    if self.family is None:
      raise TProtocol.TProtocolException(message='Required field family is unset!')
    if self.qualifier is None:
      raise TProtocol.TProtocolException(message='Required field qualifier is unset!')
    if self.tput is None:
      raise TProtocol.TProtocolException(message='Required field tput is unset!')
    if self.accessId is None:
      raise TProtocol.TProtocolException(message='Required field accessId is unset!')
    if self.accessKey is None:
      raise TProtocol.TProtocolException(message='Required field accessKey is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class checkAndPut_result:
  """
  Attributes:
   - success
   - io
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'io', (TIOError, TIOError.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, io=None,):
    self.success = success
    self.io = io

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.io = TIOError()
          self.io.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('checkAndPut_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.io is not None:
      oprot.writeFieldBegin('io', TType.STRUCT, 1)
      self.io.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class putMultiple_args:
  """
  Attributes:
   - table: the table to put data in
   - tputs: a list of TPuts to commit
   - accessId: the accessId of bcid to support bdoc
   - accessKey: the accessId of bcid to support bdoc
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'table', None, None, ), # 1
    (2, TType.LIST, 'tputs', (TType.STRUCT,(TPut, TPut.thrift_spec)), None, ), # 2
    (3, TType.STRING, 'accessId', None, None, ), # 3
    (4, TType.STRING, 'accessKey', None, None, ), # 4
  )

  def __init__(self, table=None, tputs=None, accessId=None, accessKey=None,):
    self.table = table
    self.tputs = tputs
    self.accessId = accessId
    self.accessKey = accessKey

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.table = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.tputs = []
          (_etype183, _size180) = iprot.readListBegin()
          for _i184 in xrange(_size180):
            _elem185 = TPut()
            _elem185.read(iprot)
            self.tputs.append(_elem185)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.accessId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.accessKey = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('putMultiple_args')
    if self.table is not None:
      oprot.writeFieldBegin('table', TType.STRING, 1)
      oprot.writeString(self.table)
      oprot.writeFieldEnd()
    if self.tputs is not None:
      oprot.writeFieldBegin('tputs', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.tputs))
      for iter186 in self.tputs:
        iter186.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.accessId is not None:
      oprot.writeFieldBegin('accessId', TType.STRING, 3)
      oprot.writeString(self.accessId)
      oprot.writeFieldEnd()
    if self.accessKey is not None:
      oprot.writeFieldBegin('accessKey', TType.STRING, 4)
      oprot.writeString(self.accessKey)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.table is None:
      raise TProtocol.TProtocolException(message='Required field table is unset!')
    if self.tputs is None:
      raise TProtocol.TProtocolException(message='Required field tputs is unset!')
    if self.accessId is None:
      raise TProtocol.TProtocolException(message='Required field accessId is unset!')
    if self.accessKey is None:
      raise TProtocol.TProtocolException(message='Required field accessKey is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class putMultiple_result:
  """
  Attributes:
   - io
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'io', (TIOError, TIOError.thrift_spec), None, ), # 1
  )

  def __init__(self, io=None,):
    self.io = io

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.io = TIOError()
          self.io.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('putMultiple_result')
    if self.io is not None:
      oprot.writeFieldBegin('io', TType.STRUCT, 1)
      self.io.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class deleteSingle_args:
  """
  Attributes:
   - table: the table to delete from
   - tdelete: the TDelete to delete
   - accessId: the accessId of bcid to support bdoc
   - accessKey: the accessId of bcid to support bdoc
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'table', None, None, ), # 1
    (2, TType.STRUCT, 'tdelete', (TDelete, TDelete.thrift_spec), None, ), # 2
    (3, TType.STRING, 'accessId', None, None, ), # 3
    (4, TType.STRING, 'accessKey', None, None, ), # 4
  )

  def __init__(self, table=None, tdelete=None, accessId=None, accessKey=None,):
    self.table = table
    self.tdelete = tdelete
    self.accessId = accessId
    self.accessKey = accessKey

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.table = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.tdelete = TDelete()
          self.tdelete.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.accessId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.accessKey = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('deleteSingle_args')
    if self.table is not None:
      oprot.writeFieldBegin('table', TType.STRING, 1)
      oprot.writeString(self.table)
      oprot.writeFieldEnd()
    if self.tdelete is not None:
      oprot.writeFieldBegin('tdelete', TType.STRUCT, 2)
      self.tdelete.write(oprot)
      oprot.writeFieldEnd()
    if self.accessId is not None:
      oprot.writeFieldBegin('accessId', TType.STRING, 3)
      oprot.writeString(self.accessId)
      oprot.writeFieldEnd()
    if self.accessKey is not None:
      oprot.writeFieldBegin('accessKey', TType.STRING, 4)
      oprot.writeString(self.accessKey)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.table is None:
      raise TProtocol.TProtocolException(message='Required field table is unset!')
    if self.tdelete is None:
      raise TProtocol.TProtocolException(message='Required field tdelete is unset!')
    if self.accessId is None:
      raise TProtocol.TProtocolException(message='Required field accessId is unset!')
    if self.accessKey is None:
      raise TProtocol.TProtocolException(message='Required field accessKey is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class deleteSingle_result:
  """
  Attributes:
   - io
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'io', (TIOError, TIOError.thrift_spec), None, ), # 1
  )

  def __init__(self, io=None,):
    self.io = io

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.io = TIOError()
          self.io.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('deleteSingle_result')
    if self.io is not None:
      oprot.writeFieldBegin('io', TType.STRUCT, 1)
      self.io.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class deleteMultiple_args:
  """
  Attributes:
   - table: the table to delete from
   - tdeletes: list of TDeletes to delete
   - accessId: the accessId of bcid to support bdoc
   - accessKey: the accessId of bcid to support bdoc
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'table', None, None, ), # 1
    (2, TType.LIST, 'tdeletes', (TType.STRUCT,(TDelete, TDelete.thrift_spec)), None, ), # 2
    (3, TType.STRING, 'accessId', None, None, ), # 3
    (4, TType.STRING, 'accessKey', None, None, ), # 4
  )

  def __init__(self, table=None, tdeletes=None, accessId=None, accessKey=None,):
    self.table = table
    self.tdeletes = tdeletes
    self.accessId = accessId
    self.accessKey = accessKey

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.table = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.tdeletes = []
          (_etype190, _size187) = iprot.readListBegin()
          for _i191 in xrange(_size187):
            _elem192 = TDelete()
            _elem192.read(iprot)
            self.tdeletes.append(_elem192)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.accessId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.accessKey = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('deleteMultiple_args')
    if self.table is not None:
      oprot.writeFieldBegin('table', TType.STRING, 1)
      oprot.writeString(self.table)
      oprot.writeFieldEnd()
    if self.tdeletes is not None:
      oprot.writeFieldBegin('tdeletes', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.tdeletes))
      for iter193 in self.tdeletes:
        iter193.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.accessId is not None:
      oprot.writeFieldBegin('accessId', TType.STRING, 3)
      oprot.writeString(self.accessId)
      oprot.writeFieldEnd()
    if self.accessKey is not None:
      oprot.writeFieldBegin('accessKey', TType.STRING, 4)
      oprot.writeString(self.accessKey)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.table is None:
      raise TProtocol.TProtocolException(message='Required field table is unset!')
    if self.tdeletes is None:
      raise TProtocol.TProtocolException(message='Required field tdeletes is unset!')
    if self.accessId is None:
      raise TProtocol.TProtocolException(message='Required field accessId is unset!')
    if self.accessKey is None:
      raise TProtocol.TProtocolException(message='Required field accessKey is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class deleteMultiple_result:
  """
  Attributes:
   - success
   - io
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(TDelete, TDelete.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'io', (TIOError, TIOError.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, io=None,):
    self.success = success
    self.io = io

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype197, _size194) = iprot.readListBegin()
          for _i198 in xrange(_size194):
            _elem199 = TDelete()
            _elem199.read(iprot)
            self.success.append(_elem199)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.io = TIOError()
          self.io.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('deleteMultiple_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter200 in self.success:
        iter200.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.io is not None:
      oprot.writeFieldBegin('io', TType.STRUCT, 1)
      self.io.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class checkAndDelete_args:
  """
  Attributes:
   - table: to check in and delete from
   - row: row to check
   - family: column family to check
   - qualifier: column qualifier to check
   - value: the expected value, if not provided the
  check is for the non-existence of the
  column in question
   - tdelete: the TDelete to execute if the check succeeds
   - accessId: the accessId of bcid to support bdoc
   - accessKey: the accessId of bcid to support bdoc
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'table', None, None, ), # 1
    (2, TType.STRING, 'row', None, None, ), # 2
    (3, TType.STRING, 'family', None, None, ), # 3
    (4, TType.STRING, 'qualifier', None, None, ), # 4
    (5, TType.STRING, 'value', None, None, ), # 5
    (6, TType.STRUCT, 'tdelete', (TDelete, TDelete.thrift_spec), None, ), # 6
    (7, TType.STRING, 'accessId', None, None, ), # 7
    (8, TType.STRING, 'accessKey', None, None, ), # 8
  )

  def __init__(self, table=None, row=None, family=None, qualifier=None, value=None, tdelete=None, accessId=None, accessKey=None,):
    self.table = table
    self.row = row
    self.family = family
    self.qualifier = qualifier
    self.value = value
    self.tdelete = tdelete
    self.accessId = accessId
    self.accessKey = accessKey

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.table = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.row = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.family = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.qualifier = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.value = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.tdelete = TDelete()
          self.tdelete.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.accessId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRING:
          self.accessKey = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('checkAndDelete_args')
    if self.table is not None:
      oprot.writeFieldBegin('table', TType.STRING, 1)
      oprot.writeString(self.table)
      oprot.writeFieldEnd()
    if self.row is not None:
      oprot.writeFieldBegin('row', TType.STRING, 2)
      oprot.writeString(self.row)
      oprot.writeFieldEnd()
    if self.family is not None:
      oprot.writeFieldBegin('family', TType.STRING, 3)
      oprot.writeString(self.family)
      oprot.writeFieldEnd()
    if self.qualifier is not None:
      oprot.writeFieldBegin('qualifier', TType.STRING, 4)
      oprot.writeString(self.qualifier)
      oprot.writeFieldEnd()
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.STRING, 5)
      oprot.writeString(self.value)
      oprot.writeFieldEnd()
    if self.tdelete is not None:
      oprot.writeFieldBegin('tdelete', TType.STRUCT, 6)
      self.tdelete.write(oprot)
      oprot.writeFieldEnd()
    if self.accessId is not None:
      oprot.writeFieldBegin('accessId', TType.STRING, 7)
      oprot.writeString(self.accessId)
      oprot.writeFieldEnd()
    if self.accessKey is not None:
      oprot.writeFieldBegin('accessKey', TType.STRING, 8)
      oprot.writeString(self.accessKey)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.table is None:
      raise TProtocol.TProtocolException(message='Required field table is unset!')
    if self.row is None:
      raise TProtocol.TProtocolException(message='Required field row is unset!')
    if self.family is None:
      raise TProtocol.TProtocolException(message='Required field family is unset!')
    if self.qualifier is None:
      raise TProtocol.TProtocolException(message='Required field qualifier is unset!')
    if self.tdelete is None:
      raise TProtocol.TProtocolException(message='Required field tdelete is unset!')
    if self.accessId is None:
      raise TProtocol.TProtocolException(message='Required field accessId is unset!')
    if self.accessKey is None:
      raise TProtocol.TProtocolException(message='Required field accessKey is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class checkAndDelete_result:
  """
  Attributes:
   - success
   - io
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'io', (TIOError, TIOError.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, io=None,):
    self.success = success
    self.io = io

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.io = TIOError()
          self.io.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('checkAndDelete_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.io is not None:
      oprot.writeFieldBegin('io', TType.STRUCT, 1)
      self.io.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class increment_args:
  """
  Attributes:
   - table: the table to increment the value on
   - tincrement: the TIncrement to increment
   - accessId: the accessId of bcid to support bdoc
   - accessKey: the accessId of bcid to support bdoc
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'table', None, None, ), # 1
    (2, TType.STRUCT, 'tincrement', (TIncrement, TIncrement.thrift_spec), None, ), # 2
    (3, TType.STRING, 'accessId', None, None, ), # 3
    (4, TType.STRING, 'accessKey', None, None, ), # 4
  )

  def __init__(self, table=None, tincrement=None, accessId=None, accessKey=None,):
    self.table = table
    self.tincrement = tincrement
    self.accessId = accessId
    self.accessKey = accessKey

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.table = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.tincrement = TIncrement()
          self.tincrement.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.accessId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.accessKey = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('increment_args')
    if self.table is not None:
      oprot.writeFieldBegin('table', TType.STRING, 1)
      oprot.writeString(self.table)
      oprot.writeFieldEnd()
    if self.tincrement is not None:
      oprot.writeFieldBegin('tincrement', TType.STRUCT, 2)
      self.tincrement.write(oprot)
      oprot.writeFieldEnd()
    if self.accessId is not None:
      oprot.writeFieldBegin('accessId', TType.STRING, 3)
      oprot.writeString(self.accessId)
      oprot.writeFieldEnd()
    if self.accessKey is not None:
      oprot.writeFieldBegin('accessKey', TType.STRING, 4)
      oprot.writeString(self.accessKey)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.table is None:
      raise TProtocol.TProtocolException(message='Required field table is unset!')
    if self.tincrement is None:
      raise TProtocol.TProtocolException(message='Required field tincrement is unset!')
    if self.accessId is None:
      raise TProtocol.TProtocolException(message='Required field accessId is unset!')
    if self.accessKey is None:
      raise TProtocol.TProtocolException(message='Required field accessKey is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class increment_result:
  """
  Attributes:
   - success
   - io
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (TResult, TResult.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'io', (TIOError, TIOError.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, io=None,):
    self.success = success
    self.io = io

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = TResult()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.io = TIOError()
          self.io.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('increment_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.io is not None:
      oprot.writeFieldBegin('io', TType.STRUCT, 1)
      self.io.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class append_args:
  """
  Attributes:
   - table: the table to append the value on
   - tappend: the TAppend to append
   - accessId: the accessId of bcid to support bdoc
   - accessKey: the accessId of bcid to support bdoc
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'table', None, None, ), # 1
    (2, TType.STRUCT, 'tappend', (TAppend, TAppend.thrift_spec), None, ), # 2
    (3, TType.STRING, 'accessId', None, None, ), # 3
    (4, TType.STRING, 'accessKey', None, None, ), # 4
  )

  def __init__(self, table=None, tappend=None, accessId=None, accessKey=None,):
    self.table = table
    self.tappend = tappend
    self.accessId = accessId
    self.accessKey = accessKey

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.table = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.tappend = TAppend()
          self.tappend.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.accessId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.accessKey = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('append_args')
    if self.table is not None:
      oprot.writeFieldBegin('table', TType.STRING, 1)
      oprot.writeString(self.table)
      oprot.writeFieldEnd()
    if self.tappend is not None:
      oprot.writeFieldBegin('tappend', TType.STRUCT, 2)
      self.tappend.write(oprot)
      oprot.writeFieldEnd()
    if self.accessId is not None:
      oprot.writeFieldBegin('accessId', TType.STRING, 3)
      oprot.writeString(self.accessId)
      oprot.writeFieldEnd()
    if self.accessKey is not None:
      oprot.writeFieldBegin('accessKey', TType.STRING, 4)
      oprot.writeString(self.accessKey)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.table is None:
      raise TProtocol.TProtocolException(message='Required field table is unset!')
    if self.tappend is None:
      raise TProtocol.TProtocolException(message='Required field tappend is unset!')
    if self.accessId is None:
      raise TProtocol.TProtocolException(message='Required field accessId is unset!')
    if self.accessKey is None:
      raise TProtocol.TProtocolException(message='Required field accessKey is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class append_result:
  """
  Attributes:
   - success
   - io
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (TResult, TResult.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'io', (TIOError, TIOError.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, io=None,):
    self.success = success
    self.io = io

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = TResult()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.io = TIOError()
          self.io.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('append_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.io is not None:
      oprot.writeFieldBegin('io', TType.STRUCT, 1)
      self.io.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class openScanner_args:
  """
  Attributes:
   - table: the table to get the Scanner for
   - tscan: the scan object to get a Scanner for
   - accessId: the accessId of bcid to support bdoc
   - accessKey: the accessId of bcid to support bdoc
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'table', None, None, ), # 1
    (2, TType.STRUCT, 'tscan', (TScan, TScan.thrift_spec), None, ), # 2
    (3, TType.STRING, 'accessId', None, None, ), # 3
    (4, TType.STRING, 'accessKey', None, None, ), # 4
  )

  def __init__(self, table=None, tscan=None, accessId=None, accessKey=None,):
    self.table = table
    self.tscan = tscan
    self.accessId = accessId
    self.accessKey = accessKey

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.table = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.tscan = TScan()
          self.tscan.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.accessId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.accessKey = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('openScanner_args')
    if self.table is not None:
      oprot.writeFieldBegin('table', TType.STRING, 1)
      oprot.writeString(self.table)
      oprot.writeFieldEnd()
    if self.tscan is not None:
      oprot.writeFieldBegin('tscan', TType.STRUCT, 2)
      self.tscan.write(oprot)
      oprot.writeFieldEnd()
    if self.accessId is not None:
      oprot.writeFieldBegin('accessId', TType.STRING, 3)
      oprot.writeString(self.accessId)
      oprot.writeFieldEnd()
    if self.accessKey is not None:
      oprot.writeFieldBegin('accessKey', TType.STRING, 4)
      oprot.writeString(self.accessKey)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.table is None:
      raise TProtocol.TProtocolException(message='Required field table is unset!')
    if self.tscan is None:
      raise TProtocol.TProtocolException(message='Required field tscan is unset!')
    if self.accessId is None:
      raise TProtocol.TProtocolException(message='Required field accessId is unset!')
    if self.accessKey is None:
      raise TProtocol.TProtocolException(message='Required field accessKey is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class openScanner_result:
  """
  Attributes:
   - success
   - io
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'io', (TIOError, TIOError.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, io=None,):
    self.success = success
    self.io = io

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.io = TIOError()
          self.io.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('openScanner_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.io is not None:
      oprot.writeFieldBegin('io', TType.STRUCT, 1)
      self.io.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getScannerRows_args:
  """
  Attributes:
   - scannerId: the Id of the Scanner to return rows from. This is an Id returned from the openScanner function.
   - numRows: number of rows to return
   - accessId: the accessId of bcid to support bdoc
   - accessKey: the accessId of bcid to support bdoc
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'scannerId', None, None, ), # 1
    (2, TType.I32, 'numRows', None, 1, ), # 2
    (3, TType.STRING, 'accessId', None, None, ), # 3
    (4, TType.STRING, 'accessKey', None, None, ), # 4
  )

  def __init__(self, scannerId=None, numRows=thrift_spec[2][4], accessId=None, accessKey=None,):
    self.scannerId = scannerId
    self.numRows = numRows
    self.accessId = accessId
    self.accessKey = accessKey

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.scannerId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.numRows = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.accessId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.accessKey = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getScannerRows_args')
    if self.scannerId is not None:
      oprot.writeFieldBegin('scannerId', TType.I32, 1)
      oprot.writeI32(self.scannerId)
      oprot.writeFieldEnd()
    if self.numRows is not None:
      oprot.writeFieldBegin('numRows', TType.I32, 2)
      oprot.writeI32(self.numRows)
      oprot.writeFieldEnd()
    if self.accessId is not None:
      oprot.writeFieldBegin('accessId', TType.STRING, 3)
      oprot.writeString(self.accessId)
      oprot.writeFieldEnd()
    if self.accessKey is not None:
      oprot.writeFieldBegin('accessKey', TType.STRING, 4)
      oprot.writeString(self.accessKey)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.scannerId is None:
      raise TProtocol.TProtocolException(message='Required field scannerId is unset!')
    if self.accessId is None:
      raise TProtocol.TProtocolException(message='Required field accessId is unset!')
    if self.accessKey is None:
      raise TProtocol.TProtocolException(message='Required field accessKey is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getScannerRows_result:
  """
  Attributes:
   - success
   - io
   - ia: if the scannerId is invalid
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(TResult, TResult.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'io', (TIOError, TIOError.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ia', (TIllegalArgument, TIllegalArgument.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, io=None, ia=None,):
    self.success = success
    self.io = io
    self.ia = ia

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype204, _size201) = iprot.readListBegin()
          for _i205 in xrange(_size201):
            _elem206 = TResult()
            _elem206.read(iprot)
            self.success.append(_elem206)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.io = TIOError()
          self.io.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ia = TIllegalArgument()
          self.ia.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getScannerRows_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter207 in self.success:
        iter207.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.io is not None:
      oprot.writeFieldBegin('io', TType.STRUCT, 1)
      self.io.write(oprot)
      oprot.writeFieldEnd()
    if self.ia is not None:
      oprot.writeFieldBegin('ia', TType.STRUCT, 2)
      self.ia.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class closeScanner_args:
  """
  Attributes:
   - scannerId: the Id of the Scanner to close *
   - accessId: the accessId of bcid to support bdoc
   - accessKey: the accessId of bcid to support bdoc
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'scannerId', None, None, ), # 1
    None, # 2
    (3, TType.STRING, 'accessId', None, None, ), # 3
    (4, TType.STRING, 'accessKey', None, None, ), # 4
  )

  def __init__(self, scannerId=None, accessId=None, accessKey=None,):
    self.scannerId = scannerId
    self.accessId = accessId
    self.accessKey = accessKey

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.scannerId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.accessId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.accessKey = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('closeScanner_args')
    if self.scannerId is not None:
      oprot.writeFieldBegin('scannerId', TType.I32, 1)
      oprot.writeI32(self.scannerId)
      oprot.writeFieldEnd()
    if self.accessId is not None:
      oprot.writeFieldBegin('accessId', TType.STRING, 3)
      oprot.writeString(self.accessId)
      oprot.writeFieldEnd()
    if self.accessKey is not None:
      oprot.writeFieldBegin('accessKey', TType.STRING, 4)
      oprot.writeString(self.accessKey)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.scannerId is None:
      raise TProtocol.TProtocolException(message='Required field scannerId is unset!')
    if self.accessId is None:
      raise TProtocol.TProtocolException(message='Required field accessId is unset!')
    if self.accessKey is None:
      raise TProtocol.TProtocolException(message='Required field accessKey is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class closeScanner_result:
  """
  Attributes:
   - io
   - ia: if the scannerId is invalid
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'io', (TIOError, TIOError.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ia', (TIllegalArgument, TIllegalArgument.thrift_spec), None, ), # 2
  )

  def __init__(self, io=None, ia=None,):
    self.io = io
    self.ia = ia

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.io = TIOError()
          self.io.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ia = TIllegalArgument()
          self.ia.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('closeScanner_result')
    if self.io is not None:
      oprot.writeFieldBegin('io', TType.STRUCT, 1)
      self.io.write(oprot)
      oprot.writeFieldEnd()
    if self.ia is not None:
      oprot.writeFieldBegin('ia', TType.STRUCT, 2)
      self.ia.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class mutateRow_args:
  """
  Attributes:
   - table: table to apply the mutations
   - trowMutations: mutations to apply
   - accessId: the accessId of bcid to support bdoc
   - accessKey: the accessId of bcid to support bdoc
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'table', None, None, ), # 1
    (2, TType.STRUCT, 'trowMutations', (TRowMutations, TRowMutations.thrift_spec), None, ), # 2
    (3, TType.STRING, 'accessId', None, None, ), # 3
    (4, TType.STRING, 'accessKey', None, None, ), # 4
  )

  def __init__(self, table=None, trowMutations=None, accessId=None, accessKey=None,):
    self.table = table
    self.trowMutations = trowMutations
    self.accessId = accessId
    self.accessKey = accessKey

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.table = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.trowMutations = TRowMutations()
          self.trowMutations.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.accessId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.accessKey = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('mutateRow_args')
    if self.table is not None:
      oprot.writeFieldBegin('table', TType.STRING, 1)
      oprot.writeString(self.table)
      oprot.writeFieldEnd()
    if self.trowMutations is not None:
      oprot.writeFieldBegin('trowMutations', TType.STRUCT, 2)
      self.trowMutations.write(oprot)
      oprot.writeFieldEnd()
    if self.accessId is not None:
      oprot.writeFieldBegin('accessId', TType.STRING, 3)
      oprot.writeString(self.accessId)
      oprot.writeFieldEnd()
    if self.accessKey is not None:
      oprot.writeFieldBegin('accessKey', TType.STRING, 4)
      oprot.writeString(self.accessKey)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.table is None:
      raise TProtocol.TProtocolException(message='Required field table is unset!')
    if self.trowMutations is None:
      raise TProtocol.TProtocolException(message='Required field trowMutations is unset!')
    if self.accessId is None:
      raise TProtocol.TProtocolException(message='Required field accessId is unset!')
    if self.accessKey is None:
      raise TProtocol.TProtocolException(message='Required field accessKey is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class mutateRow_result:
  """
  Attributes:
   - io
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'io', (TIOError, TIOError.thrift_spec), None, ), # 1
  )

  def __init__(self, io=None,):
    self.io = io

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.io = TIOError()
          self.io.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('mutateRow_result')
    if self.io is not None:
      oprot.writeFieldBegin('io', TType.STRUCT, 1)
      self.io.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getScannerResults_args:
  """
  Attributes:
   - table: the table to get the Scanner for
   - tscan: the scan object to get a Scanner for
   - numRows: number of rows to return
   - accessId: the accessId of bcid to support bdoc
   - accessKey: the accessId of bcid to support bdoc
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'table', None, None, ), # 1
    (2, TType.STRUCT, 'tscan', (TScan, TScan.thrift_spec), None, ), # 2
    (3, TType.I32, 'numRows', None, 1, ), # 3
    (4, TType.STRING, 'accessId', None, None, ), # 4
    (5, TType.STRING, 'accessKey', None, None, ), # 5
  )

  def __init__(self, table=None, tscan=None, numRows=thrift_spec[3][4], accessId=None, accessKey=None,):
    self.table = table
    self.tscan = tscan
    self.numRows = numRows
    self.accessId = accessId
    self.accessKey = accessKey

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.table = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.tscan = TScan()
          self.tscan.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.numRows = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.accessId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.accessKey = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getScannerResults_args')
    if self.table is not None:
      oprot.writeFieldBegin('table', TType.STRING, 1)
      oprot.writeString(self.table)
      oprot.writeFieldEnd()
    if self.tscan is not None:
      oprot.writeFieldBegin('tscan', TType.STRUCT, 2)
      self.tscan.write(oprot)
      oprot.writeFieldEnd()
    if self.numRows is not None:
      oprot.writeFieldBegin('numRows', TType.I32, 3)
      oprot.writeI32(self.numRows)
      oprot.writeFieldEnd()
    if self.accessId is not None:
      oprot.writeFieldBegin('accessId', TType.STRING, 4)
      oprot.writeString(self.accessId)
      oprot.writeFieldEnd()
    if self.accessKey is not None:
      oprot.writeFieldBegin('accessKey', TType.STRING, 5)
      oprot.writeString(self.accessKey)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.table is None:
      raise TProtocol.TProtocolException(message='Required field table is unset!')
    if self.tscan is None:
      raise TProtocol.TProtocolException(message='Required field tscan is unset!')
    if self.accessId is None:
      raise TProtocol.TProtocolException(message='Required field accessId is unset!')
    if self.accessKey is None:
      raise TProtocol.TProtocolException(message='Required field accessKey is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getScannerResults_result:
  """
  Attributes:
   - success
   - io
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(TResult, TResult.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'io', (TIOError, TIOError.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, io=None,):
    self.success = success
    self.io = io

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype211, _size208) = iprot.readListBegin()
          for _i212 in xrange(_size208):
            _elem213 = TResult()
            _elem213.read(iprot)
            self.success.append(_elem213)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.io = TIOError()
          self.io.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getScannerResults_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter214 in self.success:
        iter214.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.io is not None:
      oprot.writeFieldBegin('io', TType.STRUCT, 1)
      self.io.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
