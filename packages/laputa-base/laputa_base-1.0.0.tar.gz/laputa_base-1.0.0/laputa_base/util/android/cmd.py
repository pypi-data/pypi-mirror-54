# !/usr/bin/env python3# coding=utf-8"""Copyright (C) 2016-2019 Zhiyang Liu in Software Development of NIO/NEXTEV) All rights reserved.Author: zhiyang.liu.o@nio.comDate: 2019-05-20History:---------------------------------------------Modified            Author              Content---------------------------------------------Modified            Author              Content2019-05-29          Long Li             add get_logcat func"""import osimport mathimport sysfrom src.config.laputa_config import adb_pathget_log = Falseif os.getenv('get_log') is not None:    get_log = True  # 执行文件为test_run.py时开启抓取手机日志功能class Cmd:    def get_cmd_return(self, cmd):        return os.popen(cmd).readlines()    # 获取设备id    def get_devices(self):        comd = adb_path + ' devices'        content = self.get_cmd_return(comd)        device_list = []        for one in content:            if 'List' in one:                continue            if 'device' in one:                device = one.split('\t')[0]                if os.getenv('run_phone') == 'true':                    if device == 'RTJ0217727000776':                        device_list.append(device)                else:                    device_list.append(device)        return device_list    def get_screen_size(self, udid, type=1):        """        获取屏幕分辩率，若adb只返回一种尺寸，则只返回该尺寸，与type无关        :param udid:设备号        :param type: 1获取屏幕大小，2获取物理尺寸        :return:        """        size_dict = {}        sizes = self.get_cmd_return(adb_path + ' -s %s shell wm size' % udid)        size = ''        for s in sizes:            if 'Physical' in s:                size = s.split(':')[-1].strip()                if type == 2:                    break            if 'Override' in s:                size = s.split(':')[-1].strip()                if type == 1:                    break        x, y = size.split('x')        size_dict['x'] = int(x)        size_dict['y'] = int(y)        return size_dict    # 获取屏幕密度    def get_screen_density(self, udid):        density = self.get_cmd_return(adb_path + ' -s %s shell wm density' % udid)        density = int(density[0].split(':')[-1].strip())        return density    # 获取物理尺寸    def get_physical_dimension(self, udid):        size = self.get_screen_size(udid, type=2)        x, y = size['x'], size['y']        density = self.get_screen_density(udid)        dimension = math.sqrt(x * x + y * y) / density        return round(dimension, 1)    # 获取系统版本    def get_system_version(self, udid):        version = os.popen(adb_path + ' -s %s shell getprop ro.build.version.release' % udid).readlines()        version = version[0].split('\n')[0]        return version    # 获取手机型号    def get_phone_name(self, udid):        name = os.popen(adb_path + ' -s %s shell getprop ro.product.model' % udid).readlines()        name = name[0].split('\n')[0].replace(' ', '_')        return name    # 获取手机品牌    def get_phone_product(self, udid):        name = os.popen(adb_path + ' -s %s shell getprop ro.product.brand' % udid).readlines()        name = name[0].split('\n')[0]        return name    def kill_port(self, port):        if os.name == 'nt':            pid_line = os.popen('netstat -ano|findstr 127.0.0.1:%s' % port).readlines()            if len(pid_line) > 0:                for i in pid_line:                    if 'LISTEN' in i:                        i = i.strip('\n').strip(' ')                        line = i.split(' ')[-1]                        os.system('tskill %s' % line)            os.system('taskkill /f /im cmd.exe /fi "windowtitle eq appium"')  # win10 appium结束后遗留窗口            os.system('taskkill /f /im cmd.exe /fi "windowtitle eq 管理员: appium"')  # win7 appium结束后遗留窗口        else:            pid_line = os.popen("lsof -i:%s|grep node | awk '{print $2}'" % port).readline().strip('\n')            if len(pid_line) > 0:                os.system('kill %s' % pid_line)    def create_log_path(self, path):    # def create_log_path(self, path, udid):        """        创建log存储目录，并将目录写入手机中以供调用        """        dir_path = os.path.abspath(path + '/log/')        os.makedirs(dir_path, exist_ok=True)        os.environ['log_path'] = dir_path        # dir_path = os.path.abspath(path + '/log').replace('\\', '/')        # os.makedirs(dir_path)        # os.system(adb_path + ' -s %s shell "echo %s > /sdcard/report_path"' % (udid, dir_path.replace('/', '*')))    def start_logcat(self, udid):        """        logcat日志临时存放在手机中，测试完成后取出        """        if get_log:            os.popen(adb_path + ' -s %s shell "killall -9 logcat"' % udid)            os.system(adb_path + ' -s %s shell "logcat -c"' % udid)            os.popen(adb_path + ' -s %s shell "logcat > /sdcard/logcat.log"' % udid)    def end_logcat(self, udid, case_id,case_result):        """        报告路径从提前写入到手机中，用例结束后将logcat压缩取出更名存入到报告目录下        :param udid: 通过设备id指定设备执行        :param case_id: 脚本名        :return: 返回服务器log文件链接        """        if get_log:            # log_path = os.popen(adb_path + ' -s %s shell "cat /sdcard/report_path"' % udid) \            #     .readline().strip('\n').replace('*', '/')            log_path = os.getenv('log_path')            os.popen(adb_path + ' -s %s shell "killall -9 logcat"' % udid)            if case_result != 'Pass':                os.system(adb_path + ' -s %s shell "rm -rf /sdcard/logcat.log.gz"' % udid)                os.system(adb_path + ' -s %s shell "gzip /sdcard/logcat.log"' % udid)                if '\\' in case_id:                    case_id.replace('\\', '-')                try:                    os.system(adb_path + ' -s %s pull /sdcard/logcat.log.gz %s/%s.log.gz' % (udid, log_path, case_id))                except:                    passif __name__ == "__main__":    dc = Cmd()    print(dc.get_devices())